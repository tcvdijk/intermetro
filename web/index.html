<!DOCTYPE html>
<html>
<head>
  <title>Metro Maps</title>
  <style type="text/css">
    :root {
      --border-style: 1px solid #424242;
    }
    .flex-container {
      /* width: 700px; */
      margin-right: 710px;
      /* display: -webkit-flex;
      display: flex;  
      -webkit-flex-flow: row wrap;
      flex-flow: row wrap; */
      /*text-align: center;*/
      font-weight: normal;
      font-family: Arial, Helvetica, sans-serif;
    }

    #toolBox{
      display: grid;
      grid-template-columns: auto auto;
      grid-gap: 7px;
      margin-bottom: 0.5em;
    }

    .toolBoxElem{
      border: var(--border-style);
      padding: 2px;
    }

    .legacyTool{
      color: #424242;
      --border-style: 1px dashed #afafaf;
    }

    span[contenteditable="true"] {
      border-radius: 5px;
      border: var(--border-style);
      padding: 2px;
      
    }

    #parameters{
      line-height: 1.8em;
    }
    
    #canvas {
      position: fixed;
      right: 0px;
      top: 0px;
      margin: 10px;
      padding: 0;
      width: 700px;
      height: 700px;
      border: var(--border-style);
      outline: none;
    }
    
    #imgCanvas {
      width: 700px;
      height: 700px;
    }


    .versionLine{
      padding-bottom: 10px;
    }

    .versionLine:after {
      content: "";
      display: table;
      clear: both;
    }

    .versionAlternative{
      float: left;
      box-sizing: border-box;
      width: 100%;
      height: 80px;
      padding: 3px;
      border: var(--border-style);
    }

    .vAText{
      display: inline-block;
    }

    .active{
      border: 1px solid red;
    }

    .smallImgSpan{
      float: right;
    }

    .smallImg{
      border: var(--border-style);
    }

    .smallImg:active{
      position: fixed;
      background-color: white;
      top: 10px;
      /* left: var(--smallImg-left); */
      right: 720px;
      width: 700px;
      height: 700px;
      /* display: block; */
      z-index: 10;
    }

    /* @media all and (min-width: 500px) {
      .aside { flex: 1 auto; }
      .main    { flex: 3 0px; }
      .aside { order: 1; } 
      .main    { order: 2; }
      .footer  { order: 4; }
    } */

  </style>
</head>
<body>
  <div class="flex-container">
    <aside class="aside">
      <div id="parameters">
        <div><span>Network: </span>&nbsp;&nbsp;<select onchange="MetroMap.GraphCreation.loadLocation(this)">
          <option value="london">London</option>
          <option value="montreal">Montreal</option>
          <option value="sydney">Sydney</option>
          <option value="washington">Washington</option>
          <option value="wien">Wien</option>
          <option value="wurzburg" selected="selected">Wurzburg</option>
        </select></div>
        <div><span>Grid Resolution = </span><span id="GridResIn" contenteditable="true" onkeyup="Util.updateCosts()">0.75</span>&nbsp;&nbsp;<button onclick="MetroMap.GraphCreation.rebuildGrid()">Rebuild Grid</button></div>
        <div><span>45&#176; Cost = </span><span id="45CostIn" contenteditable="true" onkeyup="Util.updateCosts()">3</span>&nbsp;&nbsp;&nbsp;&nbsp;
        <span>90&#176; Cost = </span><span id="90CostIn" contenteditable="true" onkeyup="Util.updateCosts()">2.5</span>&nbsp;&nbsp;&nbsp;&nbsp;
        <span>135&#176; Cost = </span><span id="135CostIn" contenteditable="true" onkeyup="Util.updateCosts()">2</span>&nbsp;&nbsp;&nbsp;&nbsp;
        <span>180&#176; Cost = </span><span id="180CostIn" contenteditable="true" onkeyup="Util.updateCosts()">1</span></div>
        <div><span>Move Cost = </span><span id="MoveCostIn" contenteditable="true" onkeyup="Util.updateCosts()">0.5</span>&nbsp;&nbsp;&nbsp;&nbsp;
        <span>Sink Cost = </span><span id="SinkCostIn" contenteditable="true" onkeyup="Util.updateCosts()">2</span>&nbsp;&nbsp;&nbsp;&nbsp;
        <span>Hop Cost = </span><span id="HopCostIn" contenteditable="true" onkeyup="Util.updateCosts()">1</span>&nbsp;&nbsp;&nbsp;&nbsp;
        <span>Compression Cost = </span><span id="CompressionCostIn" contenteditable="true" onkeyup="Util.updateCosts()">10</span></div>
        <div><span>Candidate Radius = </span><span id="CandidateRadiusIn" contenteditable="true" onkeyup="Util.updateCosts()">3</span>&nbsp;&nbsp;&nbsp;&nbsp;
        <span>Live Preview Range = </span><span id="LivePreviewRangeIn" contenteditable="true" onkeyup="Util.updateCosts()">8</span>&nbsp;&nbsp;&nbsp;&nbsp;
        <button onclick="MetroMap.Routing.redrawBtn()">Redraw</button></div>
        <input type="checkbox" id="cbShowMG" onchange="Util.updateObjectsShown()"><label for="cbShowMG">Show Original</label>&nbsp;
        <input type="checkbox" id="cbShowGrid" onchange="Util.updateObjectsShown()"><label for="cbShowGrid">Show Grid</label>&nbsp;
        <input type="checkbox" id="cbShowCG" onchange="Util.updateObjectsShown()" checked><label for="cbShowCG">Show Current</label>&nbsp;
        <input type="checkbox" id="cbShowResult" onchange="Util.updateObjectsShown()" checked><label for="cbShowResult">Show Result</label>&nbsp;
        <input type="checkbox" id="cbShowLineDrawing" onchange="Util.updateObjectsShown()"><label for="cbShowLineDrawing">Show Line Drawing</label>
        <!--div>
          <button onclick="MetroMap.Routing.recalcAll(null)">Recalc All</button>
          <button onclick="MetroMap.Post.localSearchStep()">Search Step</button>
          <button onclick="MetroMap.Post.localSearchStepAll()">Search Step All</button>
          <button onclick="Version.alternative(Version.history[0][0], 'Alt', 'localSearchAll')">Test</button>
          <button onclick="Writing.makeColoredTable()">Writing</button>
        </div-->
      </div>

      <hr>
      <div id="toolBox" onclick="Tool.updateCurrentTool();"></div>
      <div><button onclick="Version.alternative(Version.getSelVer(), 'Alt', 'localSearch')">Local Search</button>&nbsp;&nbsp;
        <button onclick="Version.alternative(Version.getSelVer(), 'Alt', 'localSearchAll')">Local Search All</button>&nbsp;&nbsp;
        <button onclick="Util.export()">Export</button>&nbsp;&nbsp;
        <button onclick="Util.import()">Import</button>&nbsp;&nbsp;
        <!-- <button onclick="MetroMap.Post.localSearchStep()">Single Search Step</button>&nbsp;&nbsp;
      <button onclick="Writing.createSnapshots()">Writing</button></div> -->
      <hr>
      <div><span id="timeOut"></span></div>
      <div id="edgeOrder"></div>
      <div id="versionList"></div>
    </aside>
    <canvas id="canvas" tabindex="0"></canvas>
    <canvas id="imgCanvas" hidden="true"></canvas>
  </div>
  
  <!-- <script type="module"> -->
<script>

  var IP = "tcvdijk.github.io/intermetro"




  // import { Util } from "./libraries.js";

  var Writing = {
    suppressDialogue: !true,
    measurePerformance: false,
    loadTime: Date.now(),
    hlImageE: [],
    hlImageV: [],
    hlCGV: false,
    createSnapshots: () => {
      let snaps = {
        // 'miGood': '{"region":[67.00000000000458,3.999999999974946,573.9999999999915,688.0000000000101],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.880018641932843,"y":-49.80724008430357,"w":0.09700081928193433,"h":0.09700081928193433},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":true,"cbShowResult":true,"cbShowLineDrawing":false}}',
        // 'miGood2': '{"region":[67.00000000000458,3.999999999974946,573.9999999999915,688.0000000000101],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{},"frozenEdges":{},"movedInputs":{"14":{"x":9.943674081410862,"y":-49.80378187465752},"15":{"x":9.94721807381427,"y":-49.8045354598554},"16":{"x":9.951694798284281,"y":-49.80440109970383},"17":{"x":9.953836771714903,"y":-49.80418787598508},"24":{"x":9.929564623807991,"y":-49.78425616757787},"25":{"x":9.930077996138728,"y":-49.782348427723235},"26":{"x":9.93041869712495,"y":-49.78202722188884},"27":{"x":9.932757187000412,"y":-49.77875853477049},"28":{"x":9.934604584718608,"y":-49.77591409928898},"29":{"x":9.936270956027236,"y":-49.77348741706027},"30":{"x":9.937255925363425,"y":-49.77164558938547},"31":{"x":9.93924071748478,"y":-49.76868511133374},"32":{"x":9.939592558557752,"y":-49.76819866087925},"33":{"x":9.939704887765739,"y":-49.766140529853594},"34":{"x":9.926008151115251,"y":-49.77803628581375},"35":{"x":9.926328428609102,"y":-49.77479637725276},"36":{"x":9.927494424354865,"y":-49.77111643526547},"37":{"x":9.929529346866575,"y":-49.766657615546784},"38":{"x":9.938287311727668,"y":-49.76109592724096},"39":{"x":9.94243606569887,"y":-49.759288448167084},"40":{"x":9.947600424244795,"y":-49.75789779400546},"41":{"x":9.945591495268811,"y":-49.75431718445832},"42":{"x":9.94397896771277,"y":-49.75137898657994},"43":{"x":9.955365064704631,"y":-49.73930406089176},"44":{"x":9.958937319186871,"y":-49.73812321169715},"45":{"x":9.961972064483769,"y":-49.73372659079601},"46":{"x":9.9614447670446,"y":-49.73077446780916},"47":{"x":9.958439106608257,"y":-49.72892675956869},"48":{"x":9.966136241005497,"y":-49.71398861725691}}},"vp":{"x":9.880018641932843,"y":-49.80724008430357,"w":0.09700081928193433,"h":0.09700081928193433},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":true,"cbShowResult":true,"cbShowLineDrawing":false}}',
        // 'psGood': '{"region":[30.000000000002228,161.00000000004573,638.9999999999854,387.99999999996123],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.896881370723966,"y":-49.81009897872099,"w":0.044274812408097386,"h":0.044274812408097386},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":true,"cbShowResult":true,"cbShowLineDrawing":false},"hle":["18"],"hlv":[2]}',
        // 'psGood2': '{"region":[30.000000000002228,161.00000000004573,638.9999999999854,387.99999999996123],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{"2":"gridG,vertices,2421","23":"gridG,vertices,4509","25":"gridG,vertices,4221","27":"gridG,vertices,4824","34":"gridG,vertices,3933"},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.896881370723966,"y":-49.81009897872099,"w":0.044274812408097386,"h":0.044274812408097386},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":["18"],"hlv":[2]}',
        // 'psBad': '{"region":[58.00000000000002,184.99999999999997,568.0000000000001,311],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":2,"8":3,"9":3,"10":3,"11":2,"12":3,"13":2,"14":2,"15":2,"16":3,"17":3,"18":2,"19":2,"20":2,"21":3,"22":3,"23":3,"24":3,"25":3,"26":3,"27":3,"28":3,"29":2,"30":3,"31":3,"32":3,"33":3,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":2,"42":2,"43":3,"44":3,"45":3,"46":3,"47":3,"48":3,"49":2,"50":3,"51":2,"52":3,"53":3,"54":3,"55":3,"56":3,"57":3,"58":3,"59":3,"60":2,"61":2,"62":3,"63":3,"64":3,"65":3,"66":2,"67":3,"68":3,"69":3,"70":3,"71":3,"72":3,"73":3,"74":3,"75":3,"76":2,"77":3,"78":3,"79":3,"80":3,"81":3,"82":3,"83":2},"straightEdges":[],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":101.41239710108074,"y":-326.98822529393954,"w":191.75042111671218,"h":191.75042111671218},"loc":"wien","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":[],"hlv":[29]}',
        // 'psBad2': '{"region":[26.000000000003794,129.9999999999853,669.9999999999968,347.0000000000001],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[["mG,edges,49"],["mG,edges,0"]],"positionedStations":{"1":"gridG,vertices,1233","2":"gridG,vertices,2439","3":"gridG,vertices,2727","4":"gridG,vertices,3015","5":"gridG,vertices,3006","6":"gridG,vertices,3303","7":"gridG,vertices,3600","8":"gridG,vertices,3897","9":"gridG,vertices,4194","10":"gridG,vertices,4491","11":"gridG,vertices,4779","12":"gridG,vertices,5076","13":"gridG,vertices,5373","14":"gridG,vertices,5670","15":"gridG,vertices,5967","16":"gridG,vertices,6552","17":"gridG,vertices,6849","18":"gridG,vertices,6561","19":"gridG,vertices,6273","20":"gridG,vertices,5976","21":"gridG,vertices,5679","22":"gridG,vertices,4500","23":"gridG,vertices,4509","24":"gridG,vertices,4212","25":"gridG,vertices,4806","26":"gridG,vertices,4221","27":"gridG,vertices,4527","28":"gridG,vertices,4833","29":"gridG,vertices,5139","30":"gridG,vertices,5445","31":"gridG,vertices,5148","32":"gridG,vertices,4851","33":"gridG,vertices,5157","34":"gridG,vertices,4230","35":"gridG,vertices,3942","36":"gridG,vertices,3951","37":"gridG,vertices,3960","38":"gridG,vertices,4572","39":"gridG,vertices,4878","40":"gridG,vertices,5490","41":"gridG,vertices,5787","42":"gridG,vertices,6084","43":"gridG,vertices,6696","44":"gridG,vertices,7002","45":"gridG,vertices,7308","46":"gridG,vertices,7659","47":"gridG,vertices,7353"},"frozenEdges":{"1":{"groupID":2,"bendToPortSeq":[2,2,3,3],"iSTDiff":4,"jSTDiff":2},"2":{"groupID":2,"bendToPortSeq":[1],"iSTDiff":1,"jSTDiff":-1},"3":{"groupID":2,"bendToPortSeq":[1],"iSTDiff":1,"jSTDiff":-1},"4":{"groupID":2,"bendToPortSeq":[0],"iSTDiff":0,"jSTDiff":-1},"5":{"groupID":2,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"6":{"groupID":2,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"7":{"groupID":2,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"8":{"groupID":2,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"9":{"groupID":2,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"10":{"groupID":2,"bendToPortSeq":[3],"iSTDiff":1,"jSTDiff":1},"11":{"groupID":2,"bendToPortSeq":[0],"iSTDiff":0,"jSTDiff":-1},"12":{"groupID":2,"bendToPortSeq":[4],"iSTDiff":0,"jSTDiff":1},"13":{"groupID":2,"bendToPortSeq":[6],"iSTDiff":-1,"jSTDiff":0},"16":{"groupID":1,"bendToPortSeq":[3],"iSTDiff":1,"jSTDiff":1},"17":{"groupID":1,"bendToPortSeq":[3],"iSTDiff":1,"jSTDiff":1},"18":{"groupID":1,"bendToPortSeq":[6],"iSTDiff":-1,"jSTDiff":0},"19":{"groupID":1,"bendToPortSeq":[5],"iSTDiff":-1,"jSTDiff":1},"20":{"groupID":1,"bendToPortSeq":[4],"iSTDiff":0,"jSTDiff":1},"21":{"groupID":1,"bendToPortSeq":[4],"iSTDiff":0,"jSTDiff":1},"22":{"groupID":1,"bendToPortSeq":[3,3],"iSTDiff":2,"jSTDiff":2},"23":{"groupID":1,"bendToPortSeq":[3],"iSTDiff":1,"jSTDiff":1},"24":{"groupID":1,"bendToPortSeq":[3,3],"iSTDiff":2,"jSTDiff":2},"25":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"26":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"27":{"groupID":1,"bendToPortSeq":[3,3],"iSTDiff":2,"jSTDiff":2},"28":{"groupID":1,"bendToPortSeq":[3],"iSTDiff":1,"jSTDiff":1},"29":{"groupID":1,"bendToPortSeq":[3],"iSTDiff":1,"jSTDiff":1},"30":{"groupID":1,"bendToPortSeq":[3,4,4,4,4,4],"iSTDiff":1,"jSTDiff":6},"31":{"groupID":1,"bendToPortSeq":[7],"iSTDiff":-1,"jSTDiff":-1},"33":{"groupID":1,"bendToPortSeq":[3],"iSTDiff":1,"jSTDiff":1},"34":{"groupID":1,"bendToPortSeq":[3],"iSTDiff":1,"jSTDiff":1},"35":{"groupID":1,"bendToPortSeq":[6],"iSTDiff":-1,"jSTDiff":0},"36":{"groupID":1,"bendToPortSeq":[6],"iSTDiff":-1,"jSTDiff":0},"37":{"groupID":1,"bendToPortSeq":[3],"iSTDiff":1,"jSTDiff":1},"38":{"groupID":2,"bendToPortSeq":[1],"iSTDiff":1,"jSTDiff":-1},"39":{"groupID":2,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"40":{"groupID":2,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"41":{"groupID":2,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"42":{"groupID":2,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"43":{"groupID":2,"bendToPortSeq":[4],"iSTDiff":0,"jSTDiff":1},"44":{"groupID":2,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"45":{"groupID":2,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"46":{"groupID":2,"bendToPortSeq":[1],"iSTDiff":1,"jSTDiff":-1},"47":{"groupID":2,"bendToPortSeq":[1],"iSTDiff":1,"jSTDiff":-1},"48":{"groupID":2,"bendToPortSeq":[6],"iSTDiff":-1,"jSTDiff":0},"49":{"groupID":2,"bendToPortSeq":[6,5],"iSTDiff":-2,"jSTDiff":1}},"movedInputs":{}},"vp":{"x":9.886914968049483,"y":-49.82292769312881,"w":0.0740823201302588,"h":0.0740823201302588},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":[],"hlv":[25]}',
        // 'psBad3': '{"region":[26.000000000003794,129.9999999999853,669.9999999999968,347.0000000000001],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[["mG,edges,49"],["mG,edges,0"]],"positionedStations":{"25":"gridG,vertices,4806"},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.886914968049483,"y":-49.82292769312881,"w":0.0740823201302588,"h":0.0740823201302588},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":[],"hlv":[25]}',
        // 'seGood': '{"region":[108.00000000000277,89.99999999994957,549.0000000000089,343.0000000001594],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.938731707505898,"y":-49.80857726486447,"w":0.019704527759078543,"h":0.019704527759078543},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":["49"],"hlv":[]}',
        // 'seGood2': '{"region":[108.00000000000277,89.99999999994957,549.0000000000089,343.0000000001594],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[["mG,edges,15"]],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.938731707505898,"y":-49.80857726486447,"w":0.019704527759078543,"h":0.019704527759078543},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":["49"],"hlv":[]}',
        // 'seNeut': '{"region":[41.000000000022204,255.9999999999978,614.9999999999818,151.00000000000355],"rs":{"disallowBends":false,"contractAllowed":{"0":3,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":3,"10":3,"11":3,"12":2,"13":3,"14":3,"15":2,"16":2,"17":2,"18":3,"19":2,"20":3,"21":2,"22":3,"23":3,"24":3,"25":3,"26":2,"27":3,"28":3,"29":3,"30":2,"31":3,"32":3,"33":3,"34":3,"35":3,"36":2,"37":3,"38":3,"39":2,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":3,"47":3,"48":3,"49":3,"50":2,"51":3,"52":3,"53":3,"54":3,"55":2,"56":2,"57":3,"58":2,"59":3,"60":3,"61":3,"62":2,"63":3,"64":3,"65":3,"66":2,"67":3,"68":3,"69":3,"70":3,"71":3,"72":3,"73":3,"74":3,"75":3,"76":3,"77":3,"78":3,"79":3,"80":3,"81":3,"82":2,"83":3,"84":2,"85":3,"86":2,"87":3,"88":3,"89":3,"90":3,"91":3,"92":3,"93":3,"94":2,"95":3,"96":3,"97":3,"98":3,"99":3,"100":3,"101":3,"102":3,"103":2,"104":3,"105":3,"106":3,"107":3,"108":2,"109":3,"110":3,"111":3,"112":3,"113":3,"114":3,"115":3,"116":3,"117":3,"118":3,"119":3,"120":3,"121":3,"122":2,"123":2,"124":3,"125":3,"126":2,"127":3,"128":3,"129":3,"130":3,"131":3,"132":3,"133":3,"134":3,"135":2,"136":3,"137":3,"138":3,"139":3,"140":3,"141":3,"142":2,"143":3,"144":2,"145":2,"146":3,"147":3,"148":3,"149":3,"150":2,"151":3,"152":3,"153":3,"154":3,"155":3,"156":3,"157":3,"158":3,"159":2,"160":3,"161":3,"162":3,"163":3,"164":3,"165":3,"166":3,"167":2,"168":3,"169":3,"170":2,"171":3,"172":3,"173":2},"straightEdges":[],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":150.65770374439919,"y":33.657545437305764,"w":0.22718455709032806,"h":0.22718455709032806},"loc":"sydney","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":["149","146"],"hlv":[]}',
        // 'seNeut2': '{"region":[41.000000000022204,255.9999999999978,614.9999999999818,151.00000000000355],"rs":{"disallowBends":false,"contractAllowed":{"0":3,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":3,"10":3,"11":3,"12":2,"13":3,"14":3,"15":2,"16":2,"17":2,"18":3,"19":2,"20":3,"21":2,"22":3,"23":3,"24":3,"25":3,"26":2,"27":3,"28":3,"29":3,"30":2,"31":3,"32":3,"33":3,"34":3,"35":3,"36":2,"37":3,"38":3,"39":2,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":3,"47":3,"48":3,"49":3,"50":2,"51":3,"52":3,"53":3,"54":3,"55":2,"56":2,"57":3,"58":2,"59":3,"60":3,"61":3,"62":2,"63":3,"64":3,"65":3,"66":2,"67":3,"68":3,"69":3,"70":3,"71":3,"72":3,"73":3,"74":3,"75":3,"76":3,"77":3,"78":3,"79":3,"80":3,"81":3,"82":2,"83":3,"84":2,"85":3,"86":2,"87":3,"88":3,"89":3,"90":3,"91":3,"92":3,"93":3,"94":2,"95":3,"96":3,"97":3,"98":3,"99":3,"100":3,"101":3,"102":3,"103":2,"104":3,"105":3,"106":3,"107":3,"108":2,"109":3,"110":3,"111":3,"112":3,"113":3,"114":3,"115":3,"116":3,"117":3,"118":3,"119":3,"120":3,"121":3,"122":2,"123":2,"124":3,"125":3,"126":2,"127":3,"128":3,"129":3,"130":3,"131":3,"132":3,"133":3,"134":3,"135":2,"136":3,"137":3,"138":3,"139":3,"140":3,"141":3,"142":2,"143":3,"144":2,"145":2,"146":3,"147":3,"148":3,"149":3,"150":2,"151":3,"152":3,"153":3,"154":3,"155":3,"156":3,"157":3,"158":3,"159":2,"160":3,"161":3,"162":3,"163":3,"164":3,"165":3,"166":3,"167":2,"168":3,"169":3,"170":2,"171":3,"172":3,"173":2},"straightEdges":[["mG,edges,11"],["mG,edges,14"]],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":150.65770374439919,"y":33.657545437305764,"w":0.22718455709032806,"h":0.22718455709032806},"loc":"sydney","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":["149","146"],"hlv":[]}',
        // 'seNeut3': '{"region":[41.000000000022204,255.9999999999978,614.9999999999818,151.00000000000355],"rs":{"disallowBends":false,"contractAllowed":{"0":3,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":3,"10":3,"11":3,"12":2,"13":3,"14":3,"15":2,"16":2,"17":2,"18":3,"19":2,"20":3,"21":2,"22":3,"23":3,"24":3,"25":3,"26":2,"27":3,"28":3,"29":3,"30":2,"31":3,"32":3,"33":3,"34":3,"35":3,"36":2,"37":3,"38":3,"39":2,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":3,"47":3,"48":3,"49":3,"50":2,"51":3,"52":3,"53":3,"54":3,"55":2,"56":2,"57":3,"58":2,"59":3,"60":3,"61":3,"62":2,"63":3,"64":3,"65":3,"66":2,"67":3,"68":3,"69":3,"70":3,"71":3,"72":3,"73":3,"74":3,"75":3,"76":3,"77":3,"78":3,"79":3,"80":3,"81":3,"82":2,"83":3,"84":2,"85":3,"86":2,"87":3,"88":3,"89":3,"90":3,"91":3,"92":3,"93":3,"94":2,"95":3,"96":3,"97":3,"98":3,"99":3,"100":3,"101":3,"102":3,"103":2,"104":3,"105":3,"106":3,"107":3,"108":2,"109":3,"110":3,"111":3,"112":3,"113":3,"114":3,"115":3,"116":3,"117":3,"118":3,"119":3,"120":3,"121":3,"122":2,"123":2,"124":3,"125":3,"126":2,"127":3,"128":3,"129":3,"130":3,"131":3,"132":3,"133":3,"134":3,"135":2,"136":3,"137":3,"138":3,"139":3,"140":3,"141":3,"142":2,"143":3,"144":2,"145":2,"146":3,"147":3,"148":3,"149":3,"150":2,"151":3,"152":3,"153":3,"154":3,"155":3,"156":3,"157":3,"158":3,"159":2,"160":3,"161":3,"162":3,"163":3,"164":3,"165":3,"166":3,"167":2,"168":3,"169":3,"170":2,"171":3,"172":3,"173":2},"straightEdges":[["mG,edges,11"],["mG,edges,14"]],"positionedStations":{"100":"gridG,vertices,8271","130":"gridG,vertices,9225"},"frozenEdges":{},"movedInputs":{}},"vp":{"x":150.65770374439919,"y":33.657545437305764,"w":0.22718455709032806,"h":0.22718455709032806},"loc":"sydney","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":[],"hlv":[100,130]}',
        // 'seBad': '{"region":[57.99999999999999,103.99999999999997,526.0000000000001,445.0000000000001],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":2,"8":3,"9":3,"10":3,"11":2,"12":3,"13":2,"14":2,"15":2,"16":3,"17":3,"18":2,"19":2,"20":2,"21":3,"22":3,"23":3,"24":3,"25":3,"26":3,"27":3,"28":3,"29":2,"30":3,"31":3,"32":3,"33":3,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":2,"42":2,"43":3,"44":3,"45":3,"46":3,"47":3,"48":3,"49":2,"50":3,"51":2,"52":3,"53":3,"54":3,"55":3,"56":3,"57":3,"58":3,"59":3,"60":2,"61":2,"62":3,"63":3,"64":3,"65":3,"66":2,"67":3,"68":3,"69":3,"70":3,"71":3,"72":3,"73":3,"74":3,"75":3,"76":2,"77":3,"78":3,"79":3,"80":3,"81":3,"82":3,"83":2},"straightEdges":[["mG,edges,5","mG,edges,4","mG,edges,3","mG,edges,2","mG,edges,1","mG,edges,0","mG,edges,6"]],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":70.47889322283358,"y":-250.73414843522778,"w":159.5961768622163,"h":159.5961768622163},"loc":"wien","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":["0"],"hlv":[]}',
        // 'seBuffer': '{"region":[42.99999999999999,17.999999999999993,601.0000000000001,662],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":1,"2":1,"3":1,"4":1,"5":1,"6":3,"7":2,"8":3,"9":3,"10":3,"11":2,"12":3,"13":2,"14":2,"15":2,"16":3,"17":3,"18":2,"19":2,"20":2,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":3,"28":3,"29":2,"30":3,"31":3,"32":3,"33":3,"34":3,"35":3,"36":3,"37":1,"38":1,"39":1,"40":1,"41":3,"42":3,"43":1,"44":1,"45":1,"46":1,"47":3,"48":3,"49":2,"50":3,"51":2,"52":3,"53":3,"54":1,"55":1,"56":1,"57":1,"58":1,"59":1,"60":3,"61":3,"62":1,"63":1,"64":3,"65":3,"66":2,"67":1,"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1,"75":1,"76":3,"77":3,"78":3,"79":3,"80":3,"81":3,"82":1,"83":2,"88":3,"89":3},"straightEdges":[["mG,edges,24","mG,edges,23","mG,edges,22","mG,edges,21","mG,edges,20","mG,edges,19","mG,edges,25"],["mG,edges,4","mG,edges,3","mG,edges,2","mG,edges,1","mG,edges,0","mG,edges,5"],["mG,edges,45","mG,edges,44","mG,edges,43","mG,edges,42","mG,edges,46"],["mG,edges,38","mG,edges,39","mG,edges,40","mG,edges,41","mG,edges,37"],["mG,edges,71","mG,edges,72","mG,edges,73","mG,edges,74","mG,edges,75","mG,edges,76","mG,edges,77","mG,edges,78","mG,edges,79","mG,edges,70"],["mG,edges,63","mG,edges,62","mG,edges,64"],["mG,edges,57","mG,edges,58","mG,edges,59","mG,edges,60","mG,edges,61","mG,edges,55","mG,edges,56"]],"positionedStations":{"18":"gridG,vertices,5769","29":"gridG,vertices,4500","66":"gridG,vertices,6453"},"frozenEdges":{},"movedInputs":{}},"vp":{"x":58.44016116637684,"y":-473.612607382483,"w":413.1263033002,"h":413.1263033002},"loc":"wien","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":["52","0","34","38"],"hlv":[18,13,39]}',
        // 'seBufferOrig': '{"region":[30,8.999999999999941,599,677.0000000000001],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":1,"2":1,"3":1,"4":1,"5":1,"6":3,"7":2,"8":3,"9":3,"10":3,"11":2,"12":3,"13":2,"14":2,"15":2,"16":3,"17":3,"18":2,"19":2,"20":2,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":3,"28":3,"29":2,"30":3,"31":3,"32":3,"33":3,"34":3,"35":3,"36":3,"37":1,"38":1,"39":1,"40":1,"41":3,"42":3,"43":1,"44":1,"45":1,"46":1,"47":3,"48":3,"49":2,"50":3,"51":2,"52":3,"53":3,"54":1,"55":1,"56":1,"57":1,"58":1,"59":1,"60":3,"61":3,"62":1,"63":1,"64":3,"65":3,"66":2,"67":1,"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1,"75":1,"76":3,"77":3,"78":3,"79":3,"80":3,"81":3,"82":1,"83":2,"88":3,"89":3},"straightEdges":[["mG,edges,24","mG,edges,23","mG,edges,22","mG,edges,21","mG,edges,20","mG,edges,19","mG,edges,25"],["mG,edges,4","mG,edges,3","mG,edges,2","mG,edges,1","mG,edges,0","mG,edges,5"],["mG,edges,45","mG,edges,44","mG,edges,43","mG,edges,42","mG,edges,46"],["mG,edges,38","mG,edges,39","mG,edges,40","mG,edges,41","mG,edges,37"],["mG,edges,71","mG,edges,72","mG,edges,73","mG,edges,74","mG,edges,75","mG,edges,76","mG,edges,77","mG,edges,78","mG,edges,79","mG,edges,70"],["mG,edges,63","mG,edges,62","mG,edges,64"],["mG,edges,57","mG,edges,58","mG,edges,59","mG,edges,60","mG,edges,61","mG,edges,55","mG,edges,56"]],"positionedStations":{"18":"gridG,vertices,5769","29":"gridG,vertices,4500","66":"gridG,vertices,6453"},"frozenEdges":{},"movedInputs":{}},"vp":{"x":-10.031311611154148,"y":-519.1678925232476,"w":526.8684274534924,"h":526.8684274534924},"loc":"wien","cb":{"cbShowMG":true,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":[3, 1, 32, 37],"hlv":[18,13,39]}',
        // 'feBad': '{"region":[37.00000000001045,325.0000000000297,645.9999999999977,125.00000000001143],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{"7":"gridG,vertices,3906"},"frozenEdges":{"0":{"groupID":1,"bendToPortSeq":[2,2],"iSTDiff":2,"jSTDiff":0},"1":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"2":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"3":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"4":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"5":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"6":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"7":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0}},"movedInputs":{"5":{"x":9.919142427694597,"y":-49.79433110650478},"6":{"x":9.921918230535828,"y":-49.79532322965289},"7":{"x":9.925333868272034,"y":-49.795105908965546},"8":{"x":9.926772542527807,"y":-49.79719102220734},"23":{"x":9.932081160782714,"y":-49.79172408453254},"24":{"x":9.929427241547868,"y":-49.791400045104325}}},"vp":{"x":9.889361387728856,"y":-49.820249298617455,"w":0.04233070730353245,"h":0.04233070730353245},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":true,"cbShowResult":true,"cbShowLineDrawing":false},"hle":[],"hlv":[8]}',
        // 'feBad2': '{"region":[37.00000000001045,325.0000000000297,645.9999999999977,125.00000000001143],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{"0":"gridG,vertices,1233","1":"gridG,vertices,1827","2":"gridG,vertices,2124","3":"gridG,vertices,2421","4":"gridG,vertices,2718","5":"gridG,vertices,3015","6":"gridG,vertices,3312","7":"gridG,vertices,3609","8":"gridG,vertices,3906"},"frozenEdges":{"0":{"groupID":1,"bendToPortSeq":[2,2],"iSTDiff":2,"jSTDiff":0},"1":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"2":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"3":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"4":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"5":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"6":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"7":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0}},"movedInputs":{"5":{"x":9.919142427694597,"y":-49.79433110650478},"6":{"x":9.921918230535828,"y":-49.79532322965289},"7":{"x":9.925333868272034,"y":-49.795105908965546},"8":{"x":9.926772542527807,"y":-49.79719102220734},"23":{"x":9.932081160782714,"y":-49.79172408453254},"24":{"x":9.929427241547868,"y":-49.791400045104325}}},"vp":{"x":9.889361387728856,"y":-49.820249298617455,"w":0.04233070730353245,"h":0.04233070730353245},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":true,"cbShowResult":true,"cbShowLineDrawing":false},"hle":[],"hlv":[8]}',
        // 'feGood': '{"region":[52.00000000002366,39.00000000001774,599.9999999999524,592.9999999999876],"rs":{"disallowBends":false,"contractAllowed":{"0":3,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":3,"10":3,"11":3,"12":2,"13":3,"14":3,"15":2,"16":2,"17":2,"18":3,"19":2,"20":3,"21":2,"22":3,"23":3,"24":3,"25":3,"26":2,"27":3,"28":3,"29":3,"30":2,"31":3,"32":3,"33":3,"34":3,"35":3,"36":2,"37":3,"38":3,"39":2,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":3,"47":3,"48":3,"49":3,"50":2,"51":3,"52":3,"53":3,"54":3,"55":2,"56":2,"57":3,"58":2,"59":3,"60":3,"61":3,"62":2,"63":3,"64":3,"65":3,"66":2,"67":3,"68":3,"69":3,"70":3,"71":3,"72":3,"73":3,"74":3,"75":3,"76":3,"77":3,"78":3,"79":3,"80":3,"81":3,"82":2,"83":3,"84":2,"85":3,"86":2,"87":3,"88":3,"89":3,"90":3,"91":3,"92":3,"93":3,"94":2,"95":3,"96":3,"97":3,"98":3,"99":3,"100":3,"101":3,"102":3,"103":2,"104":3,"105":3,"106":3,"107":3,"108":2,"109":3,"110":3,"111":3,"112":3,"113":3,"114":3,"115":3,"116":3,"117":3,"118":3,"119":3,"120":3,"121":3,"122":2,"123":2,"124":3,"125":3,"126":2,"127":3,"128":3,"129":3,"130":3,"131":3,"132":3,"133":3,"134":3,"135":2,"136":3,"137":3,"138":3,"139":3,"140":3,"141":3,"142":2,"143":3,"144":2,"145":2,"146":3,"147":3,"148":3,"149":3,"150":2,"151":3,"152":3,"153":3,"154":3,"155":3,"156":3,"157":3,"158":3,"159":2,"160":3,"161":3,"162":3,"163":3,"164":3,"165":3,"166":3,"167":2,"168":3,"169":3,"170":2,"171":3,"172":3,"173":2},"straightEdges":[],"positionedStations":{"30":"gridG,vertices,22662","53":"gridG,vertices,22203","59":"gridG,vertices,23148","81":"gridG,vertices,20754","103":"gridG,vertices,23139","122":"gridG,vertices,22671","147":"gridG,vertices,21258","150":"gridG,vertices,22653"},"frozenEdges":{"6":{"groupID":2,"bendToPortSeq":[0],"iSTDiff":0,"jSTDiff":-1},"7":{"groupID":2,"bendToPortSeq":[6],"iSTDiff":-1,"jSTDiff":0},"8":{"groupID":2,"bendToPortSeq":[3],"iSTDiff":1,"jSTDiff":1},"9":{"groupID":2,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"10":{"groupID":2,"bendToPortSeq":[0],"iSTDiff":0,"jSTDiff":-1},"11":{"groupID":2,"bendToPortSeq":[6],"iSTDiff":-1,"jSTDiff":0},"12":{"groupID":2,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"17":{"groupID":1,"bendToPortSeq":[0],"iSTDiff":0,"jSTDiff":-1},"19":{"groupID":1,"bendToPortSeq":[2],"iSTDiff":1,"jSTDiff":0},"20":{"groupID":1,"bendToPortSeq":[0],"iSTDiff":0,"jSTDiff":-1},"21":{"groupID":1,"bendToPortSeq":[1],"iSTDiff":1,"jSTDiff":-1},"22":{"groupID":1,"bendToPortSeq":[6],"iSTDiff":-1,"jSTDiff":0},"23":{"groupID":1,"bendToPortSeq":[7],"iSTDiff":-1,"jSTDiff":-1},"27":{"groupID":1,"bendToPortSeq":[5],"iSTDiff":-1,"jSTDiff":1},"28":{"groupID":1,"bendToPortSeq":[4],"iSTDiff":0,"jSTDiff":1},"29":{"groupID":1,"bendToPortSeq":[0],"iSTDiff":0,"jSTDiff":-1},"163":{"groupID":1,"bendToPortSeq":[1],"iSTDiff":1,"jSTDiff":-1}},"movedInputs":{}},"vp":{"x":151.1242960564338,"y":33.83290875973731,"w":0.1196556504881154,"h":0.1196556504881154},"loc":"sydney","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":["7","6","8","9","10","12","11","27","29","23","22","163","28","17","20","21","19"],"hlv":[]}',
        // 'selQ': '{"region":[23.999999999993335,26.999999999979796,655.0000000000144,656.0000000000664],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.921974488271497,"y":-49.80753534648536,"w":0.03679590341151506,"h":0.03679590341151506},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":true,"cbShowResult":false,"cbShowLineDrawing":false},"hle":[],"hlv":[10,11,12,13,14,21,15,20,19,16,17,18],"hlCGV":true}',
        // 'selW': '{"region":[23.999999999993335,26.999999999979796,655.0000000000144,656.0000000000664],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.921974488271497,"y":-49.80753534648536,"w":0.03679590341151506,"h":0.03679590341151506},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":["33","17","16","15","14","13","12","11","38","39","40","41","43","44","45"],"hlv":[],"hlCGV":true}',
        // 'miBefore': '{"region":[68.9999999999992,35.99999999999284,560.0000000000007,618.0000000000064],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{},"frozenEdges":{},"movedInputs":{"0":{"x":9.892016415296917,"y":-49.79716225731863},"1":{"x":9.897630830265486,"y":-49.79652627802374},"2":{"x":9.903273956630906,"y":-49.796527251648016},"3":{"x":9.910745549406649,"y":-49.79651654178085},"4":{"x":9.915363449398223,"y":-49.79657495923807},"15":{"x":9.947631811684884,"y":-49.80150111695586},"16":{"x":9.952108536154896,"y":-49.80136675680429},"17":{"x":9.954250509585517,"y":-49.80115353308554},"18":{"x":9.954512718225745,"y":-49.798870142929125},"19":{"x":9.951787543847404,"y":-49.79901423932355},"20":{"x":9.94891243132892,"y":-49.79919922793799},"21":{"x":9.945421014636995,"y":-49.79923973705765},"24":{"x":9.929015094767497,"y":-49.79002622250309},"25":{"x":9.929528467098233,"y":-49.78811848264845},"26":{"x":9.930281314864827,"y":-49.78532439613182},"27":{"x":9.93261980474029,"y":-49.78205570901347},"28":{"x":9.934467202458485,"y":-49.77921127353196},"29":{"x":9.936133573767114,"y":-49.77678459130325},"30":{"x":9.938629747964665,"y":-49.773981087807584},"31":{"x":9.940751922346145,"y":-49.77143275653622},"32":{"x":9.944263555401967,"y":-49.76984724800074},"33":{"x":9.946848765292184,"y":-49.76723958793458},"34":{"x":9.925870768855129,"y":-49.78133346005673},"35":{"x":9.926328428609104,"y":-49.77768140471538},"36":{"x":9.927494424354867,"y":-49.77400146272809},"37":{"x":9.929529346866577,"y":-49.7695426430094},"38":{"x":9.936089195565687,"y":-49.76370619018333},"39":{"x":9.940237949536888,"y":-49.76189871110945},"40":{"x":9.941830369319591,"y":-49.75913423434659},"41":{"x":9.94339337910683,"y":-49.75692744740069},"42":{"x":9.943978967712772,"y":-49.754264014042555},"43":{"x":9.955365064704633,"y":-49.74218908835438},"44":{"x":9.958937319186873,"y":-49.74100823915977},"45":{"x":9.96197206448377,"y":-49.73661161825863},"46":{"x":9.961444767044602,"y":-49.73365949527178},"47":{"x":9.958439106608258,"y":-49.731811787031305},"48":{"x":9.966136241005499,"y":-49.71687364471953}}},"vp":{"x":9.880649081457522,"y":-49.810499654993976,"w":0.09644234660700021,"h":0.09644234660700021},"loc":"wurzburg","cb":{"cbShowMG":true,"cbShowGrid":false,"cbShowCG":true,"cbShowResult":false,"cbShowLineDrawing":false},"hle":[],"hlv":[],"hlCGV":false}',
        // 'miAfter': '{"region":[68.9999999999992,35.99999999999284,560.0000000000007,618.0000000000064],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{},"frozenEdges":{},"movedInputs":{"0":{"x":9.892016415296917,"y":-49.79716225731863},"1":{"x":9.897630830265486,"y":-49.79652627802374},"2":{"x":9.903273956630906,"y":-49.796527251648016},"3":{"x":9.910745549406649,"y":-49.79651654178085},"4":{"x":9.915363449398223,"y":-49.79657495923807},"15":{"x":9.947631811684884,"y":-49.80150111695586},"16":{"x":9.952108536154896,"y":-49.80136675680429},"17":{"x":9.954250509585517,"y":-49.80115353308554},"18":{"x":9.954512718225745,"y":-49.798870142929125},"19":{"x":9.951787543847404,"y":-49.79901423932355},"20":{"x":9.94891243132892,"y":-49.79919922793799},"21":{"x":9.945421014636995,"y":-49.79923973705765},"24":{"x":9.929015094767497,"y":-49.79002622250309},"25":{"x":9.929528467098233,"y":-49.78811848264845},"26":{"x":9.930281314864827,"y":-49.78532439613182},"27":{"x":9.93261980474029,"y":-49.78205570901347},"28":{"x":9.934467202458485,"y":-49.77921127353196},"29":{"x":9.936133573767114,"y":-49.77678459130325},"30":{"x":9.938629747964665,"y":-49.773981087807584},"31":{"x":9.940751922346145,"y":-49.77143275653622},"32":{"x":9.944263555401967,"y":-49.76984724800074},"33":{"x":9.946848765292184,"y":-49.76723958793458},"34":{"x":9.925870768855129,"y":-49.78133346005673},"35":{"x":9.926328428609104,"y":-49.77768140471538},"36":{"x":9.927494424354867,"y":-49.77400146272809},"37":{"x":9.929529346866577,"y":-49.7695426430094},"38":{"x":9.936089195565687,"y":-49.76370619018333},"39":{"x":9.940237949536888,"y":-49.76189871110945},"40":{"x":9.941830369319591,"y":-49.75913423434659},"41":{"x":9.94339337910683,"y":-49.75692744740069},"42":{"x":9.943978967712772,"y":-49.754264014042555},"43":{"x":9.955365064704633,"y":-49.74218908835438},"44":{"x":9.958937319186873,"y":-49.74100823915977},"45":{"x":9.96197206448377,"y":-49.73661161825863},"46":{"x":9.961444767044602,"y":-49.73365949527178},"47":{"x":9.958439106608258,"y":-49.731811787031305},"48":{"x":9.966136241005499,"y":-49.71687364471953}}},"vp":{"x":9.880649081457522,"y":-49.810499654993976,"w":0.09644234660700021,"h":0.09644234660700021},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":true,"cbShowResult":true,"cbShowLineDrawing":false},"hle":[],"hlv":[],"hlCGV":false}',
        // 'psAfter': '{"region":[10.000000000003494,34.999999999981505,678.0000000000034,638.0000000000305],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{"0":"gridG,vertices,1521","1":"gridG,vertices,1827","2":"gridG,vertices,2133","3":"gridG,vertices,2439","4":"gridG,vertices,2736","5":"gridG,vertices,2709","6":"gridG,vertices,3006","7":"gridG,vertices,3303","8":"gridG,vertices,3906","9":"gridG,vertices,4212","10":"gridG,vertices,4509","11":"gridG,vertices,4797","12":"gridG,vertices,5085","13":"gridG,vertices,5373","14":"gridG,vertices,5670","15":"gridG,vertices,5661","16":"gridG,vertices,5652","17":"gridG,vertices,6246","18":"gridG,vertices,6840","19":"gridG,vertices,6849","20":"gridG,vertices,6858","21":"gridG,vertices,6264","22":"gridG,vertices,4221","23":"gridG,vertices,4230","24":"gridG,vertices,4239","25":"gridG,vertices,4248","26":"gridG,vertices,4257","27":"gridG,vertices,4266","28":"gridG,vertices,4275","29":"gridG,vertices,4572","30":"gridG,vertices,4869","31":"gridG,vertices,5166","32":"gridG,vertices,5463","33":"gridG,vertices,5760","34":"gridG,vertices,3078","35":"gridG,vertices,3087","36":"gridG,vertices,3096","37":"gridG,vertices,3105","38":"gridG,vertices,3402","39":"gridG,vertices,3996","40":"gridG,vertices,4293","41":"gridG,vertices,4302","42":"gridG,vertices,4311","43":"gridG,vertices,4320","44":"gridG,vertices,4617","45":"gridG,vertices,4914","46":"gridG,vertices,5211","47":"gridG,vertices,5508","48":"gridG,vertices,5787"},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.897987158388133,"y":-49.81195737386614,"w":0.06087791117314478,"h":0.06087791117314478},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":[],"hlv":[],"hlCGV":false}',
        // 'seBefore': '{"region":[24.999999999996525,180.0000000000077,673.9999999999939,248.99999999999156],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.896817006462474,"y":-49.82168341649418,"w":0.060993476222135946,"h":0.060993476222135946},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":["49","0","1","2","3","4","5","10","12","13","15","14","16"],"hlv":[],"hlCGV":false}',
        // 'seAfter': '{"region":[24.999999999996525,180.0000000000077,673.9999999999939,248.99999999999156],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":1,"2":1,"3":1,"4":1,"5":1,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":1,"24":1,"25":1,"26":1,"27":2,"28":1,"29":3,"30":3,"31":3,"32":3,"33":3,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[["mG,edges,5","mG,edges,4","mG,edges,3","mG,edges,2","mG,edges,1","mG,edges,0"],["mG,edges,24","mG,edges,25","mG,edges,26","mG,edges,27","mG,edges,28"],["mG,edges,34","mG,edges,33","mG,edges,32"],["mG,edges,22"],["mG,edges,15"]],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.896817006462474,"y":-49.82168341649418,"w":0.060993476222135946,"h":0.060993476222135946},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":false},"hle":["0","5","7","39"],"hlv":[],"hlCGV":false}',
        // 'dcView': '{"at":"dontContract","region":[42.00000000000427,16.000000000012626,613.9999999999936,669.9999999999802],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":0,"16":3,"17":0,"18":0,"19":3,"20":0,"21":3,"22":2,"23":0,"24":0,"25":0,"26":0,"27":2,"28":0,"29":0,"30":0,"31":0,"32":0,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":1,"41":1,"42":1,"43":1,"44":1,"45":3,"46":2,"47":2,"48":2},"straightEdges":[["mG,edges,0","mG,edges,1","mG,edges,2","mG,edges,3","mG,edges,4","mG,edges,5","mG,edges,6","mG,edges,7"],["mG,edges,41","mG,edges,42","mG,edges,43","mG,edges,44","mG,edges,45","mG,edges,46"]],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.88577645459114,"y":-49.805558047611854,"w":0.08637749419057816,"h":0.08637749419057816},"loc":"wurzburg","cb":{"cbShowMG":true,"cbShowGrid":false,"cbShowCG":false,"cbShowResult":false,"cbShowLineDrawing":false},"hle":[],"hlv":[],"hlCGV":false}',
        // 'dcAfter': '{"region":[42.00000000000427,16.000000000012626,613.9999999999936,669.9999999999802],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":0,"16":3,"17":0,"18":0,"19":3,"20":0,"21":3,"22":2,"23":0,"24":0,"25":0,"26":0,"27":2,"28":0,"29":0,"30":0,"31":0,"32":0,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":1,"41":1,"42":1,"43":1,"44":1,"45":3,"46":2,"47":2,"48":2},"straightEdges":[["mG,edges,0","mG,edges,1","mG,edges,2","mG,edges,3","mG,edges,4","mG,edges,5","mG,edges,6","mG,edges,7"],["mG,edges,41","mG,edges,42","mG,edges,43","mG,edges,44","mG,edges,45","mG,edges,46"]],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.88577645459114,"y":-49.805558047611854,"w":0.08637749419057816,"h":0.08637749419057816},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":true,"cbShowResult":true,"cbShowLineDrawing":false},"hle":[],"hlv":[],"hlCGV":false}',
        // 'seCost': '{"region":[50.99999999999428,20.00000000001173,598.0000000000108,660.0000000000034],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.88379888353447,"y":-49.80864610088764,"w":0.09098282578965416,"h":0.09098282578965416},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":true,"cbShowResult":true,"cbShowLineDrawing":false},"hle":["2","33","22","43"],"hlv":[],"hlCGV":false}',
        // 'seCost2': '{"region":[50.99999999999428,20.00000000001173,598.0000000000108,660.0000000000034],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":3,"8":3,"9":2,"10":2,"11":2,"12":3,"13":3,"14":2,"15":3,"16":3,"17":3,"18":3,"19":3,"20":3,"21":3,"22":2,"23":3,"24":3,"25":3,"26":3,"27":2,"28":3,"29":3,"30":3,"31":3,"32":3,"33":2,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":3,"42":3,"43":3,"44":3,"45":3,"46":2,"47":2,"48":2},"straightEdges":[["mG,edges,21"],["mG,edges,39"],["mG,edges,30"],["mG,edges,2"]],"positionedStations":{},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.88379888353447,"y":-49.80864610088764,"w":0.09098282578965416,"h":0.09098282578965416},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":true,"cbShowResult":true,"cbShowLineDrawing":false},"hle":["2","33","22","43"],"hlv":[],"hlCGV":false}',
        // 'viennaLong': '{"region":[16.999999999999996,25.99999999999992,595,662],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":3,"2":3,"3":3,"4":3,"5":3,"6":3,"7":2,"8":3,"9":3,"10":3,"11":2,"12":3,"13":2,"14":2,"15":2,"16":1,"17":1,"18":2,"19":2,"20":2,"21":3,"22":3,"23":3,"24":3,"25":3,"26":3,"27":3,"28":3,"29":2,"30":3,"31":3,"32":3,"33":3,"34":3,"35":3,"36":3,"37":3,"38":3,"39":3,"40":3,"41":2,"42":2,"43":3,"44":3,"45":3,"46":3,"47":1,"48":1,"49":2,"50":3,"51":2,"52":3,"53":3,"54":3,"55":3,"56":3,"57":3,"58":3,"59":3,"60":2,"61":2,"62":3,"63":3,"64":3,"65":3,"66":2,"67":3,"68":3,"69":3,"70":3,"71":3,"72":3,"73":3,"74":3,"75":3,"76":2,"77":3,"78":0,"79":0,"80":3,"81":3,"82":3,"83":2},"straightEdges":[["mG,edges,49","mG,edges,48","mG,edges,47"],["mG,edges,15","mG,edges,16","mG,edges,17"]],"positionedStations":{"0":"gridG,vertices,2187","1":"gridG,vertices,2520","2":"gridG,vertices,2853","3":"gridG,vertices,3186","4":"gridG,vertices,3519","5":"gridG,vertices,3852","6":"gridG,vertices,4185","7":"gridG,vertices,4518","9":"gridG,vertices,5184","10":"gridG,vertices,5508","11":"gridG,vertices,5832","12":"gridG,vertices,6156","14":"gridG,vertices,6138","15":"gridG,vertices,5796","16":"gridG,vertices,5769","17":"gridG,vertices,5760","18":"gridG,vertices,5760","19":"gridG,vertices,5751","20":"gridG,vertices,2592","21":"gridG,vertices,2916","22":"gridG,vertices,3240","23":"gridG,vertices,3564","24":"gridG,vertices,3888","25":"gridG,vertices,4212","26":"gridG,vertices,4536","27":"gridG,vertices,4527","28":"gridG,vertices,4509","29":"gridG,vertices,4500","30":"gridG,vertices,4491","31":"gridG,vertices,4482","32":"gridG,vertices,4473","33":"gridG,vertices,4464","34":"gridG,vertices,4788","35":"gridG,vertices,5112","36":"gridG,vertices,5436","37":"gridG,vertices,6084","38":"gridG,vertices,6408","39":"gridG,vertices,6732","40":"gridG,vertices,7056","41":"gridG,vertices,7380","42":"gridG,vertices,2835","43":"gridG,vertices,3168","49":"gridG,vertices,5148","50":"gridG,vertices,5481","51":"gridG,vertices,5814","61":"gridG,vertices,7200","62":"gridG,vertices,6858","63":"gridG,vertices,6516","64":"gridG,vertices,6174","65":"gridG,vertices,6462","66":"gridG,vertices,6444","67":"gridG,vertices,6768","68":"gridG,vertices,7092","69":"gridG,vertices,7416","70":"gridG,vertices,7740","71":"gridG,vertices,8064","72":"gridG,vertices,8388","73":"gridG,vertices,8712","74":"gridG,vertices,9036","75":"gridG,vertices,9360","76":"gridG,vertices,9684","78":"gridG,vertices,5472","79":"gridG,vertices,5463","80":"gridG,vertices,6120","81":"gridG,vertices,6786","82":"gridG,vertices,7128","83":"gridG,vertices,7470"},"frozenEdges":{},"movedInputs":{"4":{"x":121.83253175262502,"y":-222.2295596919377},"5":{"x":151.83253175262502,"y":-216.2295596919377},"6":{"x":171.83253175262502,"y":-208.2295596919377},"7":{"x":193.82291278412512,"y":-209.89462319718774},"20":{"x":121.43069432906236,"y":-49.12899237337547},"21":{"x":128.43069432906236,"y":-71.12899237337547},"22":{"x":135.43069432906236,"y":-90.12899237337547},"23":{"x":136.43069432906236,"y":-118.12899237337547},"24":{"x":152.43069432906236,"y":-153.12899237337547},"25":{"x":159.43069432906236,"y":-166.12899237337547},"33":{"x":198.6746824737499,"y":-315.90424216568766},"37":{"x":285.7319644340627,"y":-404.9567146417505},"38":{"x":307.7319644340627,"y":-409.9567146417505},"39":{"x":323.7319644340627,"y":-427.9567146417505},"40":{"x":344.7319644340627,"y":-443.9567146417505},"41":{"x":357.7319644340627,"y":-477.9567146417505},"58":{"x":394.7175359813129,"y":-174.08613886581247},"59":{"x":401.7175359813129,"y":-156.08613886581247},"60":{"x":413.7175359813129,"y":-140.08613886581247}}},"vp":{"x":53.58461767429499,"y":-531.5027478476745,"w":481.30252256963456,"h":481.30252256963456},"loc":"wien","cb":{"cbShowMG":false,"cbShowGrid":true,"cbShowCG":false,"cbShowResult":false,"cbShowLineDrawing":true},"hle":[],"hlv":[],"hlCGV":false}',
        // 'wuContract': '{"region":[20.000000000002448,45.999999999987004,649.9999999999864,643.0000000000073],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":2,"10":2,"11":2,"12":0,"13":0,"14":2,"15":0,"16":0,"17":3,"18":3,"19":0,"20":0,"21":3,"22":2,"23":0,"24":0,"25":0,"26":0,"27":2,"28":0,"29":0,"30":0,"31":0,"32":0,"33":2,"34":3,"35":0,"36":0,"37":0,"38":0,"39":0,"40":0,"41":0,"42":0,"43":0,"44":0,"45":0,"46":2,"47":2,"48":2},"straightEdges":[],"positionedStations":{"0":"gridG,vertices,2709","11":"gridG,vertices,4788","12":"gridG,vertices,5085","13":"gridG,vertices,5382","14":"gridG,vertices,5382","15":"gridG,vertices,5976","16":"gridG,vertices,6570","17":"gridG,vertices,5976","18":"gridG,vertices,5985","19":"gridG,vertices,6579","20":"gridG,vertices,5985","21":"gridG,vertices,5391","22":"gridG,vertices,4500","27":"gridG,vertices,4527","33":"gridG,vertices,5445","34":"gridG,vertices,4230","46":"gridG,vertices,5769","47":"gridG,vertices,5778","48":"gridG,vertices,6075"},"frozenEdges":{},"movedInputs":{}},"vp":{"x":9.910105994744322,"y":-49.80277847891895,"w":0.040174105226298155,"h":0.040174105226298155},"loc":"wurzburg","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":false,"cbShowResult":false,"cbShowLineDrawing":true},"hle":[],"hlv":[],"hlCGV":false}',
        // 'sydneySE': '{"region":[4.999999999983762,12.000000000001126,690.0000000000047,658.999999999995],"rs":{"disallowBends":false,"contractAllowed":{"0":1,"1":3,"2":3,"3":1,"4":3,"5":3,"6":1,"7":1,"8":1,"9":1,"10":1,"11":3,"12":2,"13":1,"14":1,"15":2,"16":2,"17":2,"18":1,"19":2,"20":1,"21":2,"22":1,"23":1,"24":1,"25":1,"26":2,"27":1,"28":1,"29":3,"30":2,"31":1,"32":1,"33":1,"34":3,"35":1,"36":2,"37":1,"38":1,"39":2,"40":1,"41":1,"42":3,"43":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":3,"50":2,"51":1,"52":1,"53":1,"54":1,"55":2,"56":2,"57":1,"58":2,"59":3,"60":1,"61":1,"62":2,"63":1,"64":1,"65":3,"66":2,"67":1,"68":1,"69":1,"70":3,"71":1,"72":1,"73":3,"74":1,"75":1,"76":1,"77":1,"78":1,"79":1,"80":1,"81":1,"82":2,"83":1,"84":2,"85":1,"86":2,"87":1,"88":1,"89":1,"90":1,"91":3,"92":3,"93":1,"94":2,"95":3,"96":1,"97":1,"98":1,"99":3,"100":1,"101":3,"102":1,"103":2,"104":1,"105":1,"106":1,"107":1,"108":2,"109":1,"110":3,"111":1,"112":1,"113":1,"114":1,"115":1,"116":1,"117":1,"118":1,"119":1,"120":1,"121":1,"122":2,"123":2,"124":1,"125":1,"126":2,"127":1,"128":1,"129":1,"130":1,"131":1,"132":1,"133":1,"134":1,"135":2,"136":1,"137":3,"138":1,"139":1,"140":1,"141":1,"142":2,"143":1,"144":2,"145":2,"146":1,"147":3,"148":1,"149":1,"150":2,"151":1,"152":1,"153":1,"154":1,"155":1,"156":1,"157":1,"158":3,"159":2,"160":1,"161":1,"162":1,"163":1,"164":1,"165":1,"166":1,"167":2,"168":1,"169":1,"170":2,"171":1,"172":1,"173":2},"straightEdges":[["mG,edges,17","mG,edges,16","mG,edges,15","mG,edges,14","mG,edges,13","mG,edges,12","mG,edges,11","mG,edges,10"],["mG,edges,9","mG,edges,8","mG,edges,7","mG,edges,6","mG,edges,5","mG,edges,4","mG,edges,3","mG,edges,2","mG,edges,1","mG,edges,0"],["mG,edges,24","mG,edges,23","mG,edges,22","mG,edges,21","mG,edges,20","mG,edges,19","mG,edges,18"],["mG,edges,89","mG,edges,90","mG,edges,91","mG,edges,92","mG,edges,93"],["mG,edges,98","mG,edges,99","mG,edges,100","mG,edges,101","mG,edges,102"],["mG,edges,131","mG,edges,130","mG,edges,129","mG,edges,128","mG,edges,127"],["mG,edges,173","mG,edges,172","mG,edges,171","mG,edges,170","mG,edges,169","mG,edges,168","mG,edges,167","mG,edges,166","mG,edges,165","mG,edges,164","mG,edges,163","mG,edges,162"],["mG,edges,104","mG,edges,105","mG,edges,106","mG,edges,107","mG,edges,108","mG,edges,109","mG,edges,110","mG,edges,111","mG,edges,112","mG,edges,113","mG,edges,114","mG,edges,115","mG,edges,116"],["mG,edges,43","mG,edges,42","mG,edges,41","mG,edges,40","mG,edges,39","mG,edges,38","mG,edges,37","mG,edges,36","mG,edges,35","mG,edges,34"],["mG,edges,53","mG,edges,54","mG,edges,55","mG,edges,56","mG,edges,57","mG,edges,58","mG,edges,59","mG,edges,60","mG,edges,61","mG,edges,62","mG,edges,63"],["mG,edges,73","mG,edges,72","mG,edges,71","mG,edges,70","mG,edges,69","mG,edges,68","mG,edges,74","mG,edges,75","mG,edges,76","mG,edges,77","mG,edges,78","mG,edges,79","mG,edges,80","mG,edges,81"],["mG,edges,52","mG,edges,51","mG,edges,50","mG,edges,49"],["mG,edges,86","mG,edges,85","mG,edges,84","mG,edges,83","mG,edges,82","mG,edges,87"],["mG,edges,151","mG,edges,150","mG,edges,149"],["mG,edges,156","mG,edges,157","mG,edges,158","mG,edges,159","mG,edges,160","mG,edges,161"],["mG,edges,152","mG,edges,153","mG,edges,154","mG,edges,155"],["mG,edges,144","mG,edges,143","mG,edges,142","mG,edges,141","mG,edges,140","mG,edges,139","mG,edges,138","mG,edges,137","mG,edges,145","mG,edges,146","mG,edges,147","mG,edges,148"]],"positionedStations":{"1":"gridG,vertices,21285","2":"gridG,vertices,22608","12":"gridG,vertices,20106","15":"gridG,vertices,16002","16":"gridG,vertices,11610","17":"gridG,vertices,25038","19":"gridG,vertices,11700","29":"gridG,vertices,10296","36":"gridG,vertices,14976","39":"gridG,vertices,18999","42":"gridG,vertices,22221","49":"gridG,vertices,24561","50":"gridG,vertices,8271","56":"gridG,vertices,9828","58":"gridG,vertices,14508","62":"gridG,vertices,13554","65":"gridG,vertices,17892","66":"gridG,vertices,18234","70":"gridG,vertices,21753","73":"gridG,vertices,24084","84":"gridG,vertices,10764","86":"gridG,vertices,7020","87":"gridG,vertices,21708","92":"gridG,vertices,22689","95":"gridG,vertices,22635","101":"gridG,vertices,19638","103":"gridG,vertices,23139","113":"gridG,vertices,13554","122":"gridG,vertices,22185","126":"gridG,vertices,8208","135":"gridG,vertices,15516","137":"gridG,vertices,23616","142":"gridG,vertices,18369","144":"gridG,vertices,17541","147":"gridG,vertices,21258","150":"gridG,vertices,22653","158":"gridG,vertices,11232","159":"gridG,vertices,16137","167":"gridG,vertices,21276","173":"gridG,vertices,23607"},"frozenEdges":{},"movedInputs":{"7":{"x":151.034897,"y":33.90951791883406},"34":{"x":151.21181690367666,"y":33.851371040292136},"42":{"x":151.18751820358747,"y":33.94184418295968},"78":{"x":151.076202,"y":33.91161991883406},"92":{"x":151.20068391748882,"y":33.93250406053814},"103":{"x":151.22167690191387,"y":33.89005845882646},"119":{"x":151.05093628609862,"y":33.909975960089646},"150":{"x":151.19418736779153,"y":33.872398},"165":{"x":151.065994,"y":33.91551791883406},"170":{"x":151.19815180911613,"y":33.858185732057436}}},"vp":{"x":150.7782345425224,"y":33.62938310812211,"w":0.4976055082056194,"h":0.4976055082056194},"loc":"sydney","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":false,"cbShowResult":false,"cbShowLineDrawing":true},"hle":[],"hlv":[],"hlCGV":false}',
        // 'montrealLong': '{"region":[15.00000000000003,51.00000000000004,677.0000000000001,613.9999999999999],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":2,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":2,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":2,"27":0,"28":2,"29":2,"30":0,"31":0,"32":0,"33":0,"34":0,"35":2,"36":0,"37":0,"38":0,"39":3,"40":0,"41":0,"42":0,"43":0,"44":3,"45":0,"46":0,"47":0,"48":0,"49":0,"50":2,"51":0,"52":0,"53":0,"54":2,"55":0,"56":0,"57":0,"58":0,"59":0,"60":0,"61":0,"62":0,"63":0,"64":2},"straightEdges":[],"positionedStations":{"7":"gridG,vertices,2637","14":"gridG,vertices,3717","35":"gridG,vertices,1467","39":"gridG,vertices,2862","50":"gridG,vertices,2547"},"frozenEdges":{},"movedInputs":{}},"vp":{"x":3399.364905981235,"y":1084.0991167719535,"w":2080.790313729326,"h":2080.790313729326},"loc":"montreal","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":false,"cbShowResult":false,"cbShowLineDrawing":true},"hle":[],"hlv":[],"hlCGV":false}',
        // 'washingtonStyle': '{"region":[16.000000000000004,243.99999999999994,673.9999999999999,118.00000000000006],"rs":{"disallowBends":false,"contractAllowed":{"0":2,"1":0,"2":3,"3":2,"4":0,"5":2,"6":0,"7":0,"8":2,"9":0,"10":0,"11":2,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":2,"23":0,"24":0,"25":3,"26":0,"27":0,"28":3,"29":0,"30":0,"31":2,"32":3,"33":0,"34":0,"35":2,"36":3,"37":0,"38":3,"39":0,"40":3,"41":0,"42":0,"43":0,"44":0,"45":2,"46":0,"47":0,"48":0,"49":2,"50":3,"51":3,"52":2,"53":0,"54":0,"55":0,"56":0,"57":0,"58":2,"59":3,"60":0,"61":0,"62":0,"63":0,"64":0,"65":2,"66":2,"67":0,"68":0,"69":0,"70":3,"71":0,"72":2,"73":0,"74":0,"75":0,"76":0,"77":3,"78":0,"79":0,"80":0,"81":2,"82":3,"83":2,"84":3,"85":2,"86":3,"87":0,"88":0,"89":0,"90":0,"91":0,"92":0,"93":0,"94":0,"95":0,"96":2,"97":2},"straightEdges":[],"positionedStations":{"0":"gridG,vertices,10638","2":"gridG,vertices,9225","3":"gridG,vertices,11025","5":"gridG,vertices,4509","8":"gridG,vertices,5607","22":"gridG,vertices,10287","25":"gridG,vertices,8829","27":"gridG,vertices,9918","28":"gridG,vertices,9198","31":"gridG,vertices,8487","32":"gridG,vertices,11718","35":"gridG,vertices,12798","36":"gridG,vertices,10989","38":"gridG,vertices,11709","40":"gridG,vertices,12429","45":"gridG,vertices,14598","49":"gridG,vertices,14607","50":"gridG,vertices,10656","51":"gridG,vertices,11016","52":"gridG,vertices,11376","58":"gridG,vertices,13176","59":"gridG,vertices,13545","65":"gridG,vertices,14976","66":"gridG,vertices,14985","70":"gridG,vertices,12114","72":"gridG,vertices,14274","82":"gridG,vertices,8874","83":"gridG,vertices,8514","84":"gridG,vertices,8865","85":"gridG,vertices,8505","86":"gridG,vertices,6318","96":"gridG,vertices,2718","97":"gridG,vertices,9567"},"frozenEdges":{},"movedInputs":{"5":{"x":449.55889171534335,"y":-360.58630910381453},"8":{"x":239.0401007531506,"y":-291.9691373980786},"31":{"x":546.4138931625471,"y":-328.5134770741515},"32":{"x":732.7543578235659,"y":-313.61621311342185},"35":{"x":717.7543578235659,"y":-379.8403411134218},"38":{"x":673.7543578235659,"y":-346.4846821134218},"45":{"x":819.6991440978243,"y":-483.8220657709522},"49":{"x":808.7543578235659,"y":-426.1075341134218},"81":{"x":489.88977305560877,"y":-265.43087416603566},"83":{"x":439.88977305560877,"y":-250.53448216603567},"85":{"x":471.88977305560877,"y":-208.82811916603566},"96":{"x":245.71677589918056,"y":-366.30841238847125}}},"vp":{"x":214.04082713206407,"y":-562.3839096544472,"w":609.2664759290968,"h":609.2664759290968},"loc":"washington","cb":{"cbShowMG":false,"cbShowGrid":false,"cbShowCG":false,"cbShowResult":true,"cbShowLineDrawing":true},"hle":[],"hlv":[],"hlCGV":false}',


      }; //viennaLong: 850s, 75I, 8F; wuContract: 200s, 25I, 0F; sydney: 1050s, 83I, 5F, montrealLong 80s, 8I, 0F, washingtonStyle: 1250s, 104I, 12F
      Canvas.grid.showGrid = false;
      let takeSnap = (i) => {
        let s = Object.keys(snaps)[i];
        let x = Util.deserializeVer(snaps[s], 0, true);
        MetroMap.GraphCreation.loadLocation({value: x.loc});
        setTimeout(() => {
          x = Util.deserializeVer(snaps[s], 0, true);
          console.log(x, Version.current)
          Version.current.routeSettings = x.rs;
          Canvas.viewport = x.vp;
          if(x.at){
            document.getElementById(Tool.currentToolID).checked = false;
            document.getElementById(x.at).checked = true;
            Tool.updateCurrentTool();
          }
          for(let cb in x.cb) document.getElementById(cb).checked = x.cb[cb];
          Util.updateObjectsShown();
          MetroMap.Routing.recalcAll(Version.current);
          if(x.hle) for(let e of x.hle) for(let o of Version.current.graphs.cG.edges[e].edgePath) o.ls.visual.highlightShown = true;
          if(x.hlv && x.hlCGV) for(let o of x.hlv) Version.current.graphs.cG.vertices[o].p.visual.highlightShown = true;
          else if(x.hlv) for(let o of x.hlv) Version.current.graphs.cG.vertices[o].gridNode.p.visual.highlightShown = true;
          Canvas.redraw();
          Writing.snapshot(s, ...x.region);
          if(x.hle) for(let e of x.hle) for(let o of Version.current.graphs.cG.edges[e].edgePath) o.ls.visual.highlightShown = false;
          if(x.hlv && x.hlCGV) for(let o of x.hlv) Version.current.graphs.cG.vertices[o].p.visual.highlightShown = false;
          else if(x.hlv) for(let o of x.hlv) Version.current.graphs.cG.vertices[o].gridNode.p.visual.highlightShown = false;
          Writing.hlImageE = x.hle;
          Writing.hlImageV = x.hlv;
          Writing.hlCGV = x.hlCGV;
          if(i < Object.keys(snaps).length-1) takeSnap(i+1);
        }, 300);
      }
      takeSnap(0);
    },
    snapshot: (name, x, y, w, h) => {
      if(!x){
        x=60.9999999999959;
        y=20.00000000001345;
        w=597.000000000001;
        h=668.9999999999874;
      }
      let dpr = window.devicePixelRatio || 1;
      let imgData = Canvas.ctx.getImageData(x*dpr, y*dpr, w*dpr, h*dpr);
      let c = document.createElement('canvas');
      c.width = w*dpr;
      c.height = h*dpr;
      c.getContext('2d').scale(dpr, dpr);
      c.getContext('2d').putImageData(imgData, 0, 0);
      let dataURL = c.toDataURL("image/png"); //image URL
      let link = document.createElement("a");
      link.download = name;
      link.href = dataURL;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

    },
    saveCanvasAsImg: (name) => {
      let dataURL = Canvas.elem.toDataURL("image/png");
      let link = document.createElement("a");
      link.download = name;
      link.href = dataURL;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    },
    gridImages: () => {
      Canvas.grid.showGrid = false;
      document.getElementById("cbShowCG").checked = false;
      Util.updateObjectsShown();
      Canvas.viewport = {"x":9.883546767981725,"y":-49.80791354611069,"w":0.08844160683279675,"h":0.08844160683279675}


      document.getElementById("GridResIn").innerText = 0.65;
      MetroMap.GraphCreation.rebuildGrid()
      MetroMap.Routing.recalcAll(Version.current);
      console.log("0.65: " + MetroMap.Post.recalcCost(Version.current));
      Canvas.redraw();
      Writing.saveCanvasAsImg("grid65");

      document.getElementById("GridResIn").innerText = 0.7;
      MetroMap.GraphCreation.rebuildGrid()
      MetroMap.Routing.recalcAll(Version.current);
      console.log("0.7: " + MetroMap.Post.recalcCost(Version.current));
      Canvas.redraw();
      Writing.saveCanvasAsImg("grid7");

      document.getElementById("GridResIn").innerText = 0.85;
      MetroMap.GraphCreation.rebuildGrid()
      MetroMap.Routing.recalcAll(Version.current);
      console.log("0.85: " + MetroMap.Post.recalcCost(Version.current));
      Canvas.redraw();
      Writing.saveCanvasAsImg("grid85");
    },
    costImages: () => {
      Canvas.grid.showGrid = false;
      Version.current.costs.c45 = 4;
      Version.current.costs.c135 = 4;
      MetroMap.Routing.recalcAll(Version.current);
      Canvas.redraw();
      Writing.saveCanvasAsImg("costRect");
      Version.current.costs.c45 = 3;
      Version.current.costs.c135 = 2;

      Version.current.costs.cm = 10;
      MetroMap.Routing.recalcAll(Version.current);
      Canvas.redraw();
      Writing.saveCanvasAsImg("costMove");
      Version.current.costs.cm = 0.5;
      
      Version.current.costs.ch = 3;
      Version.current.costs.candidateRadius = 10;
      MetroMap.Routing.recalcAll(Version.current);
      Canvas.redraw();
      Writing.saveCanvasAsImg("costShort");
      //Version.current.routeSettings.contractAllowed = {0: 2, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 2, 10: 2, 11: 2, 12: 0, 13: 0, 14: 2, 15: 0, 16: 0, 17: 0, 18: 0, 19: 0, 20: 0, 21: 0, 22: 2, 23: 0, 24: 0, 25: 0, 26: 0, 27: 2, 28: 0, 29: 0, 30: 0, 31: 0, 32: 0, 33: 2, 34: 0, 35: 0, 36: 0, 37: 0, 38: 0, 39: 0, 40: 0, 41: 0, 42: 0, 43: 0, 44: 0, 45: 0, 46: 2, 47: 2, 48: 2};    
    },
    diffOffenderImages: () => {
      Canvas.grid.showGrid = false;
      document.getElementById("cbShowCG").checked = false;
      Util.updateObjectsShown();
      Version.current.graphs.cG.edges[8].edgePath[1].ls.visual.highlightShown = true;
      Version.current.graphs.cG.edges[12].edgePath[1].ls.visual.highlightShown = true;
      Version.current.graphs.cG.edges[15].edgePath[1].ls.visual.highlightShown = true;
      Version.current.graphs.gridG.vertices[4491].p.visual.highlightShown = true;
      Version.current.graphs.gridG.vertices[4491].p.visual.highlightColor = Canvas.Colors.highlight2;
      Canvas.redraw();
      Writing.saveCanvasAsImg("diffOffenders");
      Version.current.graphs.cG.edges[8].edgePath[1].ls.visual.highlightShown = false;
      Version.current.graphs.cG.edges[12].edgePath[1].ls.visual.highlightShown = false;
      Version.current.graphs.cG.edges[15].edgePath[1].ls.visual.highlightShown = false;
      Version.current.graphs.gridG.vertices[4491].p.visual.highlightShown = false;
      Version.current.routeSettings.straightEdges.push([Version.current.graphs.mG.edges[8]])
      MetroMap.Routing.recalcAll(Version.current);
      Version.current.graphs.cG.edges[8].edgePath[1].ls.visual.highlightShown = true;
      Canvas.redraw();
      Writing.saveCanvasAsImg("diffStraightened");
      Version.current.graphs.cG.edges[8].edgePath[1].ls.visual.highlightShown = false;
      Version.current.routeSettings.straightEdges = [];
      Version.current.routeSettings.positionedStations[10] = Version.current.graphs.gridG.vertices[4482];
      MetroMap.Routing.recalcAll(Version.current);
      Version.current.graphs.gridG.vertices[4482].p.visual.highlightShown = true;
      Version.current.graphs.gridG.vertices[4482].p.visual.highlightColor = Canvas.Colors.highlight2;
      Canvas.redraw();
      Writing.saveCanvasAsImg("diffRepos");
      //Version.current.routeSettings.contractAllowed = {0: 2, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 2, 10: 2, 11: 2, 12: 0, 13: 0, 14: 2, 15: 0, 16: 0, 17: 0, 18: 0, 19: 0, 20: 0, 21: 0, 22: 2, 23: 0, 24: 0, 25: 0, 26: 0, 27: 2, 28: 0, 29: 0, 30: 0, 31: 0, 32: 0, 33: 2, 34: 0, 35: 0, 36: 0, 37: 0, 38: 0, 39: 0, 40: 0, 41: 0, 42: 0, 43: 0, 44: 0, 45: 0, 46: 2, 47: 2, 48: 2};    
    },
    checkboxImages: () => {
      Version.current.routeSettings.contractAllowed = {0: 2, 1: 3, 2: 3, 3: 3, 4: 3, 5: 3, 6: 3, 7: 3, 8: 3, 9: 2, 10: 2, 11: 2, 12: 3, 13: 3, 14: 2, 15: 3, 16: 3, 17: 3, 18: 3, 19: 3, 20: 3, 21: 3, 22: 2, 23: 0, 24: 0, 25: 0, 26: 0, 27: 2, 28: 0, 29: 0, 30: 0, 31: 0, 32: 0, 33: 2, 34: 3, 35: 0, 36: 0, 37: 3, 38: 0, 39: 0, 40: 0, 41: 0, 42: 0, 43: 0, 44: 0, 45: 0, 46: 2, 47: 2, 48: 2};
      // let ps = {15: 5661, 16: 6255, 17: 6849, 18: 6867, 19: 6570, 20: 5976, 21: 5679, 33: 5445};
      // for(let v in ps) Version.current.routeSettings.positionedStations[v] = Version.current.graphs.gridG.vertices[ps[v]];
      Version.current.routeSettings.movedInputs = 
        {0: {x: 9.892153797557041, y: -49.79716225731863},
        1: {x: 9.89776821252561, y: -49.79652627802374},
        2: {x: 9.903411338891031, y: -49.796527251648016},
        3: {x: 9.910882931666773, y: -49.79651654178085},
        4: {x: 9.915500831658347, y: -49.79657495923807},
        15: {x: 9.947906576205131, y: -49.80260017503686},
        16: {x: 9.951833771634648, y: -49.803427490706156},
        17: {x: 9.954662656365887, y: -49.803076884727275},
        18: {x: 9.954512718225747, y: -49.80024396553037},
        19: {x: 9.95261183740815, y: -49.799701150624166},
        20: {x: 9.948500284548548, y: -49.79961137471837},
        21: {x: 9.945558396897122, y: -49.799926648358266}};
      Canvas.grid.showGrid = false;
      MetroMap.Routing.recalcAll(Version.current);
      document.getElementById("cbShowMG").checked = true;
      document.getElementById("cbShowResult").checked = false;
      Util.updateObjectsShown();
      Canvas.redraw();
      Writing.saveCanvasAsImg("checkboxIn");
      document.getElementById("cbShowMG").checked = false;
      document.getElementById("cbShowCG").checked = false;
      document.getElementById("cbShowGrid").checked = true;
      document.getElementById("cbShowResult").checked = true;
      Util.updateObjectsShown();
      Canvas.redraw();
      Writing.saveCanvasAsImg("checkboxOut");
      document.getElementById("cbShowGrid").checked = false;
      document.getElementById("cbShowResult").checked = false;
      document.getElementById("cbShowLineDrawing").checked = true;
      Util.updateObjectsShown()
      Canvas.redraw();
      Writing.saveCanvasAsImg("checkboxLD");
    },
    runtimesSearch: () => {
      let csv = "";
      let lcs = "";
      let cd = "";
      let n = 10;
      for(let i = 0; i < n; i++){
        do{
          Version.current.routeSettings.straightEdges = [];
          Version.current.routeSettings.positionedStations = {};
          Writing.randomizeRouteSettings(0, 10, 0, 10, 3);
        }while(!MetroMap.Routing.recalcAll());
        let cOld = MetroMap.Post.recalcCost(Version.current);
        let cOrig = cOld;
        let lsc = 0;
        while(true){
          let sT = performance.now();
          MetroMap.Post.localSearchStep();
          // MetroMap.Post.localSearchStepAll();
          csv += "\n" + (performance.now()-sT);
          let c = MetroMap.Post.recalcCost(Version.current);
          lsc++;
          console.log(i,"/",n," c:",c, " down from ", cOld);
          //i++;
          if(cOld <= c) break;
          cOld = c;
        }
        lcs += "," + (lsc-1);
        cd += "," + ((cOrig-cOld)/cOrig);
        console.log(cd.substr(1)+"\n" +lcs.substr(1)+csv)
      }
    },
    runtimesVar: () => {
      Writing.measurePerformance = true;
      Writing.times = {s: -1, e: -1};
      let variCount = 10;
      let variPerSet = 200;
      let varCsv = "";
      for(let i = 0; i < variCount; i++){
        do{
          Version.current.routeSettings.straightEdges = [];
          Version.current.routeSettings.positionedStations = {};
          Writing.randomizeRouteSettings(0, 8, 0, 8, 3);
        }while(!MetroMap.Routing.recalcAll());
        let line = (i==0?"":"\n")+"se=" + Version.current.routeSettings.straightEdges.length + ";ps=" + Object.keys(Version.current.routeSettings.positionedStations).length;
        for(let j = 0; j < variPerSet; j++){
          line += "," + (Writing.times.e-Writing.times.s);
          if(j < variPerSet-1) MetroMap.Routing.recalcAll();
          if(j%30 ==29) console.log("inner: " + j + "/" + variPerSet);
        }
        console.log((i+1) + "/" + variCount);
        varCsv += line;
      }
      console.log(varCsv);
    },
    runtimesFail: () => {
      Writing.measurePerformance = true;
      Writing.times = {s: -1, e: -1, se: [], nse: [], ps: [[], [], []]};
      let testSE = true;
      let testC = 1000;
      let succCsv = "";
      let failCsv = "";
      let sT = Date.now();
      for(let k = 0; k < testC; k++){
        Version.current.routeSettings.straightEdges = [];
        Version.current.routeSettings.positionedStations = {};
        Writing.randomizeRouteSettings(0, 5, 0, 5, 3); //Sydney
        // Writing.randomizeRouteSettings(0, 10, 0, 10, 3); //Wrzburg
        if(MetroMap.Routing.recalcAll()) succCsv += "," + (Writing.times.e-Writing.times.s);
        else failCsv += "," + (Writing.times.e-Writing.times.s);
        if(k%30 == 29) console.log(k + "/" + testC);
      }
      console.log(succCsv.split(",").length)
      console.log(succCsv.substr(1)+ "\n" + failCsv.substr(1));
    },
    runtimesConstraint: () => {
      Writing.measurePerformance = true;
      Writing.times = {s: -1, e: -1, se: [], nse: [], ps: [[], [], []]};
      let testSE = !true;
      let varMax = 15;
      let perVar = 10;
      let perSet = 1;
      let csv = "se,ps,times (testing: "+(testSE?"SE)":"PS)");
      let sT = Date.now();
      // for(let i = varMax; i >= 0; i--){
      for(let i = 0; i <= varMax; i++){
        for(let k = 0; k < perVar; k++){
          do{
            Version.current.routeSettings.straightEdges = [];
            Version.current.routeSettings.positionedStations = {};
            if(testSE) Writing.randomizeRouteSettings(i, i, 0, varMax, 3);
            else Writing.randomizeRouteSettings(0, varMax, i, i, 3);
          }while(!MetroMap.Routing.recalcAll());
          let line = "\n" + Version.current.routeSettings.straightEdges.length + "," + Object.keys(Version.current.routeSettings.positionedStations).length;
          for(let j = 0; j < perSet; j++){
            line += "," + (Writing.times.e-Writing.times.s);
            if(j < perSet-1) MetroMap.Routing.recalcAll();
          }
          let prog = (i*perVar+k+i+1);
          console.log(prog + "/" + ((varMax+1)*(perVar+1)) + " (" + Math.round(((varMax+1)*(perVar+1)-prog)*(Date.now()-sT)/(prog*1000)) + "s)");
          csv += line;
          if(prog%30 == 29) console.log(csv);
        }
      }
      console.log(csv);
      // console.log(Writing.times.se, Writing.times.nse);
      // console.log(Writing.times.se.reduce((s, e) => s+e, 0)/Writing.times.se.length, Writing.times.nse.reduce((s, e) => s+e, 0)/Writing.times.nse.length);
      // console.log(Writing.times.ps.map(x => x.reduce((s, e) => s+e, 0)/x.length));
      for(let arr of [Writing.times.se, Writing.times.nse, Writing.times.ps[0], Writing.times.ps[1], Writing.times.ps[2]]){
        let mean = arr.reduce((s, e) => s+e, 0)/arr.length;
        console.log(mean, Math.sqrt(arr.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / arr.length));
      }
    },
    runtimesEdges: () => {
      Writing.measurePerformance2 = true;
      Writing.times = {s: -1, e: -1, se: [], nse: [], ps: [[], [], []]};
      let perVar = 100;
      let perSet = 1;
      let sT = Date.now();
      for(let k = 0; k < perVar; k++){
        do{
          Version.current.routeSettings.straightEdges = [];
          Version.current.routeSettings.positionedStations = {};
          Writing.randomizeRouteSettings(0, 10, 0, 10, 3);
        }while(!MetroMap.Routing.recalcAll());
        for(let j = 0; j < perSet; j++){
          if(j < perSet-1) MetroMap.Routing.recalcAll();
        }
        let prog = k;
        console.log(k + "/" + perVar);
      }
      // console.log(Writing.times.se, Writing.times.nse);
      // console.log(Writing.times.se.reduce((s, e) => s+e, 0)/Writing.times.se.length, Writing.times.nse.reduce((s, e) => s+e, 0)/Writing.times.nse.length);
      // console.log(Writing.times.ps.map(x => x.reduce((s, e) => s+e, 0)/x.length));
      let csv = "";
      for(let arr of [Writing.times.se, Writing.times.nse, Writing.times.ps[0], Writing.times.ps[1], Writing.times.ps[2]]){
        for(let i = 0; i < arr.length; i++){
          if(i>0) csv += ",";
          csv += "" + arr[i];
        }
        let mean = arr.reduce((s, e) => s+e, 0)/arr.length;
        console.log(arr.length, mean, Math.sqrt(arr.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / arr.length));
        csv += "\n";
      }
      console.log(csv);
    },
    runtimesEdgesLength: () => {
      Writing.measurePerformance3 = true;
      Writing.times = {s: -1, e: -1, es: [], estim: 0};
      let edgeC = 10000;
      let sT = Date.now();
      while(Writing.times.es.length < edgeC){
        do{
          if(Writing.times.es.length> 0 && !Writing.times.es[Writing.times.es.length-1][0]) Writing.times.es.pop();
          Version.current.routeSettings.straightEdges = [];
          Version.current.routeSettings.positionedStations = {};
          Writing.randomizeRouteSettings(0, 10, 0, 10, 3);
        }while(!MetroMap.Routing.recalcAll());
        console.log(Writing.times.es.length + "/" + edgeC);
      }
      // console.log(Writing.times.es);
      let csv = "gridD,geoD,estimD,t";
      for(let x of Writing.times.es){
        if(!x[0]) {console.log("oops");continue;}
        csv += "\n" + x[0] + "," + x[1]/Version.current.graphs.gridG.D + "," + x[2]+ "," + x[3];
      }
      console.log(csv);
    },
    evalStability: () => {
      let toolToTest = "strEdge"; //reposStation, strEdge
      let results = [];
      let csv = "moveStationCount,moveStationStrength,changeEdgeCount,changeEdgeStrength";
      let testCount = 500;
      for(let i = 0; i < testCount; i++){
        Version.current.routeSettings.straightEdges = [];
        Version.current.routeSettings.positionedStations = {};
        console.log("starting",i,"/",testCount)
        Writing.randomizeRouteSettings(0, 10, 0, 10, 3); //seMin, seMax, psMin, psMax
        if(!MetroMap.Routing.recalcAll()){
          i--;
          continue;
        };
        let a = Writing.saveStructureInfo();
        let b, is = [], ie = [];
        if(toolToTest == "reposStation"){
          let s = Writing.randomizeRouteSettings(0, 0, 1, 1, 3);
          is = ["" + s];
          ie = Version.current.graphs.mG.vertices[s].es.map(e => e.s.id + "$" + e.t.id);
          // let randS = Version.current.graphs.cG.vertices[Math.floor(Math.random()*Object.keys(Version.current.graphs.cG.vertices).length)].contractParent.id;

          // let gns = [];
          // for(let i = 0; i < Version.current.graphs.gridG.gridNodes.length; i++){
          //   for(let j = 0; j < Version.current.graphs.gridG.gridNodes[i].length; j++){
          //     let gn = Version.current.graphs.gridG.gridNodes[i][j];
          //     if(gn.settleable && Geometry.distanceBetween(gn.p, Version.current.graphs.mG.vertices[randS].p) < Version.current.graphs.gridG.D*psRange){
          //       let free = true;
          //       for(let ps in Version.current.routeSettings.positionedStations){
          //         if(gn == Version.current.routeSettings.positionedStations[ps]){
          //           free = false;
          //           break;
          //         }
          //       }
          //       if(free) gns.push(gn);
          //     }
          //   }
          // }
          // Version.current.routeSettings.positionedStations[randS] = gns[Math.floor(Math.random()*gns.length)];
          // console.log(randS)
          // if(MetroMap.Routing.routeVertices(Version.current, [Version.current.graphs.cG.vertices[randS]])) a = Writing.saveStructureInfo();
          // else a = "failed";
          // if(MetroMap.Routing.recalcAll()) b = Writing.saveStructureInfo();
          // else b = "failed";
        }else if(toolToTest == "strEdge"){
          let e = Writing.randomizeRouteSettings(1, 1, 0, 0, 3);
          is.push("" + Version.current.graphs.mG.edges[e].s.id);
          is.push("" + Version.current.graphs.mG.edges[e].t.id);
          ie = [is[0] + "$" + is[1]];
        }


        if(MetroMap.Routing.recalcAll()){
          let diff = Writing.calcStructureDiff(a, Writing.saveStructureInfo(), is, ie);
          csv += "\n" + diff;
          // if(["17", "20", "32"].includes(diff.split(",")[0]) || ["15", "28"].includes(diff.split(",")[2])){
          //   console.log(ie[0], diff)
          //   // console.log(is, ie)
          //   // break;
          // }
        }else i--;
        if(i%50==49) console.log(csv);
      }
      console.log(csv);
      // let msc = 0, mss = 0, cec = 0, ces = 0, fc = 0;
      // for(let ret of results){
      //   if(ret == -1) fc++;
      //   else{
      //     msc += ret.moveStationCount;
      //     mss += ret.moveStationStrength;
      //     cec += ret.changeEdgeCount;
      //     ces += ret.changeEdgeStrength;
      //   }
      // }
      // let rc = results.length-fc;
      // console.log(`On average, ${Math.round((msc/rc)*100)/100} stations moved by ${Math.round((mss/msc)*100)/100}, and ${Math.round((cec/rc)*100)/100} edges changed shape by ${Math.round((ces/cec)*100)/100}; ${fc} failed`)
    },
    saveStructureInfo: () => { //doesnt work with contractions
      let r = {stations: {}, edges: {}};
      for(let v in Version.current.graphs.mG.vertices){
        let v2 = Version.current.graphs.mG.vertices[v];
        if(v2.contract.v) r.stations[v] = {i: v2.contract.v.gridNode.gridCoords.i, j: v2.contract.v.gridNode.gridCoords.j};
      }
      for(let e in Version.current.graphs.cG.edges){
        let e2 = Version.current.graphs.cG.edges[e];
        let btps = [];
        for(let i = 1; i < e2.path.length-2; i += 2){
          let btp = e2.path[i].parent.ports.indexOf(e2.path[i]);
          if(btps.length == 0 || btps[btps.length-1] != btp) btps.push(btp);
        }
        r.edges[e2.chain[0].s.id + "$" + e2.chain[0].t.id] = btps;
      }
      return r;
    },
    calcStructureDiff: (a, b, ignoreStations, ignoreEdges) => {
      if(a == "failed" || b == "failed") return -1;
      let ret = {moveStationCount: 0, moveStationStrength: 0, changeEdgeCount: 0, changeEdgeStrength: 0};
      for(let s in a.stations){
        if(!ignoreStations.includes(s) && b.stations[s]) {
          let d = Math.max(Math.abs(a.stations[s].i-b.stations[s].i), Math.abs(a.stations[s].j-b.stations[s].j));
          ret.moveStationStrength += d;
          if(d > 0) ret.moveStationCount++;
        }
      }
      for(let e in a.edges){
        if(!ignoreEdges.includes(e) && b.edges[e]){
          let i = 0;
          let j = 0;
          let d = 0;
          while(true){
            if(a.edges[e][i] == b.edges[e][i]){
              i++;
              j++;
            }else{
              d += 1;
              if(a.edges[e].length-i == b.edges[e].length-j){
                i++;
                j++;
              }else if(a.edges[e].length-i > b.edges[e].length-j) i++;
              else j++;
            }
            if(i >= a.edges[e].length) break;
            if(j >= b.edges[e].length) break;
          }
          ret.changeEdgeStrength += d;
          if(d > 0) ret.changeEdgeCount++;
        }
      }
      // return ret;
      return "" + ret.moveStationCount + "," + ret.moveStationStrength + "," + ret.changeEdgeCount + "," + ret.changeEdgeStrength;
    },
    evalRestraintDifficulty: () => {
      let seMax = 10; //included
      let psMax = 10; //included
      let runsPerCell = 100;
      let resCsvProb = "Succses Rate; runs=" + runsPerCell;
      let resCsvCost = "Avg Cost of Succs; r=" + runsPerCell;
      let sT = Date.now();
      for(let j = 0; j <= psMax; j++){
        resCsvProb += ",c_p=" + j;
        resCsvCost += ",c_p=" + j;
      }
      for(let i = 0; i <= seMax; i++){
        let lineP = "\nc_s=" + i;
        let lineC = "\nc_s=" + i;
        for(let j = 0; j <= psMax; j++){
          let suc = [];
          for(let k = 0; k < runsPerCell; k++){
            Version.current.routeSettings.straightEdges = [];
            Version.current.routeSettings.positionedStations = {};
            Writing.randomizeRouteSettings(i, i, j, j, 3);
            if(MetroMap.Routing.recalcAll()) suc.push(MetroMap.Post.recalcCost(Version.current));
          }
          lineP += "," + Math.round(100*suc.length/runsPerCell)/100;
          lineC += "," + (suc.length == 0 ? 100000 : Math.round(100*suc.reduce((s, e) => s + e, 0)/suc.length)/100);
          let prog = (i*psMax+j+i+1);
          console.log(prog + "/" + ((psMax+1)*(seMax+1)) + " (" + Math.round(((psMax+1)*(seMax+1)-prog)*(Date.now()-sT)/(prog*1000)) + "s)", lineP, lineC);
        }
        resCsvProb += lineP;
        resCsvCost += lineC;
      }
      console.log(resCsvProb);
      console.log(resCsvCost);
    },
    randomizeRouteSettings: (seMin, seMax, psMin, psMax, psRange) => {
      let seCount = seMin+Math.floor(Math.random()*(seMax-seMin)); //min will happen, max wont
      let lastID;
      for(let j = 0; j < seCount; j++){
        let randE = Object.keys(Version.current.graphs.mG.edges)[Math.floor(Math.random()*Object.keys(Version.current.graphs.mG.edges).length)];
        if(Version.current.routeSettings.straightEdges.some(x => x[0].id == randE)) j--;
        else Version.current.routeSettings.straightEdges.push([Version.current.graphs.mG.edges[randE]]);
        lastID = randE;
      }
      let psCount = psMin+Math.floor(Math.random()*(psMax-psMin));
      for(let j = 0; j < psCount; j++){
        let randS = Version.current.graphs.cG.vertices[Math.floor(Math.random()*Object.keys(Version.current.graphs.cG.vertices).length)].contractParent.id;
        if(Version.current.routeSettings.positionedStations[randS]) j--;
        else{
          let gns = [];
          for(let i = 0; i < Version.current.graphs.gridG.gridNodes.length; i++){
            for(let j = 0; j < Version.current.graphs.gridG.gridNodes[i].length; j++){
              if(Geometry.distanceBetween(Version.current.graphs.gridG.gridNodes[i][j].p, Version.current.graphs.mG.vertices[randS].p) < Version.current.graphs.gridG.D*psRange){
                let free = true;
                for(let ps in Version.current.routeSettings.positionedStations){
                  if(Version.current.graphs.gridG.gridNodes[i][j] == Version.current.routeSettings.positionedStations[ps]){
                    free = false;
                    break;
                  }
                }
                if(free) gns.push(Version.current.graphs.gridG.gridNodes[i][j]);
              }
            }
          }
          Version.current.routeSettings.positionedStations[randS] = gns[Math.floor(Math.random()*gns.length)];
          lastID = randS;
        }
      }
      return lastID;
    },
    randomizeEdgeOrder: () => {
      let results = [];
      let testCount = 170;
      let priosToTest = [{posStation: 0, strEdge: 0}, {posStation: 1, strEdge: 1}, {posStation: 1, strEdge: 2}, {posStation: 2, strEdge: 1}];
      let resCsv = "Restrictions (SE+PS Count)";
      for(let ptt of priosToTest) resCsv +=  ",se: " + ptt.strEdge + " - ps: " + ptt.posStation;
      resCsv += ",Details (SEs/PSs@GC)\n";
      let resCsv2 = resCsv;
      let oneSuccessCount = 0;
      for(let i = 0; i < testCount; i++){
        if(i%30==0){
          console.log(resCsv)
          console.log("without complete fails (" + oneSuccessCount + "/" + testCount +"):")
          console.log(resCsv2)
        }
        let sT = Date.now();
        Writing.randomizeRouteSettings(0, 8, 0, 8, 3); //seMin, seMax, psMin, psMax, psRange
        let resCsvLine = "" + 1*(Version.current.routeSettings.straightEdges.length + Object.keys(Version.current.routeSettings.positionedStations).length);
        let oneSuccsess = false;
        for(let ptt of priosToTest){
          MetroMap.edgeOrderPrios = ptt;
          let newDijkstras = [];
          let ver = Version.current;
          MetroMap.Routing.recalcCG(ver);
          let success = true;
          let eO = MetroMap.Routing.recalcEdgeOrder(ver);
          ver.results.edgeOrder.sort((a, b) => eO[b.id] - eO[a.id]);
          // ver.results.edgeOrder =  Util.shuffle(ver.results.edgeOrder);
          for(let e of ver.results.edgeOrder){
            if(!success) break;
            // console.log(ver.routeSettings.positionedStations[e.s.contractParent.id], ver.routeSettings.positionedStations[e.t.contractParent.id])
            if(ver.routeSettings.straightEdges.some(se => se.length == e.chain.length && se.every(e2 => e.chain.includes(e2)))){
              let oldCosts = {};
              for(let ck of ["c135", "c90", "c45", "candidateRadius"]){
                oldCosts[ck] = Version.current.costs[ck];
                Version.current.costs[ck] = Number.MAX_SAFE_INTEGER;
              }
              Version.current.costs["candidateRadius"] = oldCosts["candidateRadius"]*2;
              newDijkstras.push(MetroMap.Routing.routeEdge(ver, e, ver.routeSettings.positionedStations[e.s.contractParent.id], ver.routeSettings.positionedStations[e.t.contractParent.id], ver.routeSettings.frozenEdges[e.id]));
              for(let ck of ["c135", "c90", "c45", "candidateRadius"]) Version.current.costs[ck] = oldCosts[ck];
            }else newDijkstras.push(MetroMap.Routing.routeEdge(ver, e, ver.routeSettings.positionedStations[e.s.contractParent.id], ver.routeSettings.positionedStations[e.t.contractParent.id], ver.routeSettings.frozenEdges[e.id]));
            if(!newDijkstras[newDijkstras.length-1]) success = false;
          }
          let c = success ? MetroMap.Post.recalcCost(ver) : 100000;
          if(Number.isNaN(c)) c = 100000//TODO why does this happen?
          if(c!=100000) oneSuccsess = true;
          resCsvLine += "," + c;
          results.push({t: Date.now()-sT, cost: c, seCount: Version.current.routeSettings.straightEdges.length, step: i});
          // if(success){MetroMap.Post.updateDijkstras(ver, newDijkstras);
            // Canvas.redraw();
            // Version.edited("wrStep "+i);}
          }
        console.log((i+1)+"/"+testCount + "done");
        resCsvLine += ",";
        for(let se of Version.current.routeSettings.straightEdges) resCsvLine += se[0].id + ";";
        resCsvLine += "/";
        for(let ps in Version.current.routeSettings.positionedStations) resCsvLine += ps + "@" + Version.current.routeSettings.positionedStations[ps].gridCoords.i + "_" + Version.current.routeSettings.positionedStations[ps].gridCoords.j + ";";
        resCsvLine += "\n";
        resCsv += resCsvLine;
        if(oneSuccsess){
          resCsv2 += resCsvLine;
          oneSuccessCount++;
        }

        Version.current.routeSettings.straightEdges = [];
        Version.current.routeSettings.positionedStations = {};
      }
      console.log(results)
      // let s = "";
      // for(let r in results) s += results[r].cost + ",";
      console.log(resCsv)
      console.log("without complete fails (" + oneSuccessCount + "/" + testCount +"):")
      console.log(resCsv2)
    },
    makeColoredTable: () => {
      let p = "Succses Rate; runs=100,c_p=0,c_p=1,c_p=2,c_p=3,c_p=4,c_p=5,c_p=6,c_p=7,c_p=8,c_p=9,c_p=10\nc_s=0,1,0.89,0.85,0.66,0.57,0.59,0.47,0.45,0.3,0.2,0.21\nc_s=1,1,0.91,0.8,0.71,0.6,0.54,0.42,0.41,0.36,0.24,0.17\nc_s=2,0.97,0.88,0.83,0.67,0.6,0.44,0.36,0.36,0.24,0.21,0.19\nc_s=3,0.96,0.86,0.78,0.64,0.6,0.45,0.37,0.33,0.23,0.23,0.24\nc_s=4,0.94,0.74,0.68,0.58,0.5,0.43,0.37,0.3,0.28,0.21,0.12\nc_s=5,0.85,0.76,0.65,0.49,0.41,0.53,0.37,0.23,0.21,0.14,0.19\nc_s=6,0.73,0.74,0.6,0.55,0.41,0.31,0.32,0.28,0.14,0.15,0.11\nc_s=7,0.7,0.66,0.54,0.45,0.38,0.27,0.22,0.22,0.11,0.11,0.08\nc_s=8,0.72,0.57,0.53,0.33,0.33,0.23,0.21,0.29,0.13,0.1,0.06\nc_s=9,0.57,0.49,0.47,0.36,0.2,0.3,0.13,0.11,0.12,0.09,0.09\nc_s=10,0.54,0.47,0.39,0.28,0.27,0.24,0.16,0.13,0.13,0.1,0.05";
      let c = "Avg Cost of Succs; r=100,c_p=0,c_p=1,c_p=2,c_p=3,c_p=4,c_p=5,c_p=6,c_p=7,c_p=8,c_p=9,c_p=10\nc_s=0,465.7,467.96,474.86,477.38,482.45,489.85,499.29,499.85,509.29,519.84,523.11\nc_s=1,461.21,464.37,475,474.25,484.29,490.6,493.79,502.63,509.07,516.4,530.49\nc_s=2,455.78,462.86,466.79,473.9,478.59,489.09,494,505.62,502.22,517.16,523.18\nc_s=3,455.19,461.38,467.18,476.8,481.14,487.53,493.91,497.45,512.75,520.21,525.53\nc_s=4,452.51,456.56,466.92,473.82,477.14,487.38,494.39,492.38,512.79,520.03,522.44\nc_s=5,452.14,457.58,467.83,470.45,480.16,489.38,487.09,495,512.94,517.15,520.04\nc_s=6,448.76,457.51,464.99,469.06,479.52,492.62,493.4,499.86,503.76,515.17,527.6\nc_s=7,449.07,458.55,465.07,470.2,477.75,489.91,492.6,499.8,511.44,522.41,527.36\nc_s=8,450.04,454.54,463.4,473.95,475,488,502.1,502.94,513.08,513.6,539.03\nc_s=9,450.9,455,460.81,470.31,477.01,491.88,492.25,498.85,513.72,510.87,538.75\nc_s=10,448.21,456.5,466.34,470.47,478.32,486.06,496.24,497.44,503.18,508.52,540.57";
      p = p.split("\n");
      c = c.split("\n");
      for(let i = 0; i < p.length; i++) p[i] = p[i].split(",");
      for(let i = 0; i < c.length; i++) c[i] = c[i].split(",");
      let s = "\\begin{table}\\resizebox{\\textwidth}{!}{\n\\begin{tabular}{c|";
      // let minC = c.reduce((s, e) => Math.min(s, e.reduce((s2, e2) => Number.isNaN(e2) ? 0 : Math.min(s2, 1*e2), 100000)), 100000);
      // console.log(c[3].reduce((s2, e2) => {console.log(e2, s2,  Number.isNaN(e2), Number.isNaN(e2) ? 0 : Math.min(1*s2, 1*e2)); return 4}, 100000))
      // let spanC = c.reduce((s, e) => Math.max(s, e.reduce((s2, e2) => Math.max(s2, e2), 0)), 0)-minC;
      let minC = 1000000;
      let maxC = 0;
      for(let i = 1; i < c.length; i++) for(let j = 1; j < c[i].length; j++){
        minC = Math.min(c[i][j], minC);
        maxC = Math.max(c[i][j], maxC);
      }
      let cToFloat = x => (x-minC)/(maxC-minC);
      for(let i = 1; i < p[0].length-1; i++) s += ">{\\centering}p{0.065\\textwidth}";
      s += ">{\\centering\\arraybackslash}p{0.065\\textwidth}}\n\\diagbox{$n_s$}{$n_p$}";
      for(let i = 1; i < p[0].length; i++) s += "& \\cellcolor[rgb]{1, " + (1-p.reduce((s, e, k) => k == 0 ? 0 : s + 1*e[i], 0)/(p.length-1)) + ", 1}" + (i-1);
      // for(let i = 1; i < p[0].length; i++) s += "& \\cellcolor[rgb]{1, " + cToFloat(c.reduce((s, e, k) => k == 0 ? 0 : s + 1*e[i], 0)/(p.length-1)) + ", 1}" + (i-1);
      s += "\\\\ \\hline\n";
      for(let i = 1; i < p.length; i++){
        s += " \\cellcolor[rgb]{1, " + (1-p[i].reduce((s, e, k) => k == 0 ? 0 : s + 1*e, 0)/(p[i].length-1)) + ", 1}" + (i-1);
        // s += " \\cellcolor[rgb]{1, " + cToFloat(c[i].reduce((s, e, k) => k == 0 ? 0 : s + 1*e, 0)/(p[i].length-1)) + ", 1}" + (i-1);
        for(let j = 1; j < p[i].length; j++){
          s += `& \\cellcolor[rgb]{1, ${1-p[i][j]}, 1} \\makecell{${Math.round(p[i][j]*100)}\\,\\%}`;
          // s += `& \\cellcolor[rgb]{1, ${cToFloat(c[i][j])}, 1} \\makecell{${Math.round(c[i][j])}}`;
        }
        s += "\\\\\n";
      }
      s += "\\end{tabular}}\n\\end{table}";
      console.log(s);
    }
  };

  var Version = {
    getDefault: () => {return {
      isCurrent: true,
      versionIndex: 0,
      graphs: {cG: null, mG: null, gridG: null},
      results: {edgeOrder: [], lineDrawing: null, vertexOrder: [], resultDijkstras: [], cost: 0, calcTime: 0},
      routeSettings: {disallowBends: false, contractAllowed: {}, straightEdges: [], positionedStations: {}, frozenEdges: {}, movedInputs: {}}, //disalloweBends only works when s2sd gets just one s-vtx, for contractAllowed 0 means psl contract, 1 contr bc straight edge, 2 dont bc degree, 3 pls dont
      currentToolID: "navigate",
      objectStore: {idCounter: 0, objects: {}},
      viewport: {x: 9.88, y: -49.81, w: 0.1, h: 0.1},
      costs: {"min": 0.00001, "gr": 0.75, "c180": 0, "c135": 0, "c90": 0, "c45": 0, "cs": 0, "ch": 0, "cm": 0, "cc": 0, "candidateRadius": 3, "livePreviewRange": 8},
      checkBoxes: {"cbShowMG": false, "cbShowGrid": false, "cbShowCG": true,  "cbShowResult": true,  "cbShowLineDrawing": false}
      //min is cost>0 for edges from s2s-start, grid res, bend costs, sink, hop, move penalty, spring compression
    };},
    current: null,
    history: [null],
    store: {},
    nextFreeIndex: 1,
    // cloneVersion: v => {
    //   let dictsToClone = ["costs", "viewport"];
    //   let w = {currentToolID: v.currentToolID, };
    //   for(let d of dictsToClone) w[d] = versionStore.cloneDict(v[d]);
    // },
    edited: (name) => {
      let st = Date.now();
      let act = document.getElementsByClassName("active");
      if(act.length > 0){
        act = act[0];
        act.classList.remove("active");
        let hi = -1;
        for(let i = 0; i < Version.history.length && hi == -1; i++) if(Version.history[i].includes(Version.store[act.id.substr(2)])) hi = i;
        if(hi < Version.history.length-1){
          Version.history.pop();
          while(Version.history.length > hi+1){
            console.log(Version.history[Version.history.length-1][0].versionIndex, document.getElementById("vL" + Version.history[Version.history.length-1][0].versionIndex))
            document.getElementById("versionList").removeChild(document.getElementById("vL" + Version.history.pop()[0].versionIndex));
          }
          Version.history.push([Version.current]);
          // for(let i = hi; i < Version.history.length; i++) ;
        }
      }
      Tool.handleEvent({type: "deselect"}); //TODO this doesnt seem to effect the current drawing...
      let cost = Math.round(Version.current.results.cost*100)/100;
      let hi = -1;
      for(let i = 0; i < Version.history.length && hi == -1; i++) if(Version.history[i].includes(Version.current)) hi = i;
      if(hi > 0){
        let costChange = Version.current.results.cost-Version.history[hi-1][0].results.cost;
        cost += " (<span style='color: " + (costChange>=0?"red'>+":"green'>") + Math.round(costChange*100)/100 + "</span>)";
      }
      let e = document.createElement("div");
      e.id = "vL" + Version.current.versionIndex;
      e.classList.add("versionLine");
      e.innerHTML = `<div id='vA${Version.current.versionIndex}' class='versionAlternative active' style='width: 100%; margin-right:0%;' ondblclick='Version.load(${Version.current.versionIndex})'><span class='vAText'><b>${name + "\n"}</b><br>Cost: ${cost + "\n"}<br>After: ${Version.current.results.calcTime}ms</span><span class='smallImgSpan'><img class='smallImg' src='${Canvas.elem.toDataURL("image/png")}' width='70' height='70'></span></div>`;
      document.getElementById("versionList").appendChild(e);

      let cv = Version.dupe(Version.current, Version.nextFreeIndex++);
      Version.current.isCurrent = false;
      Version.history.push([cv]);
      Version.store[cv.versionIndex] = cv;
      // console.log("clone done after " + (Date.now()-st) + "ms")
      Version.current = cv;
      // for(let v in Version.current.graphs.cG.vertices) MetroMap.Routing.unsettleVtx(Version.current.graphs.cG.vertices[v]) 
    },
    alternative: (ver, name, funcName) => {
      let myWorker = new Worker("workers.js");
      ver.funcName = funcName;
      // console.time("serialize")
      let ser = Util.serializeVer(ver);
      // console.timeEnd("serialize")
      ver.funcName = undefined;
      myWorker.postMessage(ser);
      myWorker.onmessage = function(e) {
        // console.log(e)
        // console.log('Message received from worker');
        // result.textContent = e.data;
        // console.time("deserialize")
        let av = Util.deserializeVer(e.data, Version.nextFreeIndex++);
        // console.timeEnd("deserialize")
        av.isCurrent = false;
        av.isAlternative = true;
        Version.store[av.versionIndex] = av;
        let hi = -1;
        for(let i = 0; i < Version.history.length && hi == -1; i++) if(Version.history[i].includes(ver)) hi = i;
        Version.history[hi].push(av);


        let cost = Math.round(av.results.cost*100)/100;
        if(hi > -1){
          let costChange = av.results.cost-Version.history[hi][0].results.cost;
          cost += " (<span style='color: " + (costChange>=0?"red'>+":"green'>") + Math.round(costChange*100)/100 + "</span>)";
          console.log(hi, Version.history[hi][0].versionIndex)
          let e = document.getElementById("vL" + Version.history[hi][0].versionIndex);
          e.innerHTML += `<div id='vA${av.versionIndex}' class='versionAlternative' style='width: 49%; margin-right: 0%;' ondblclick='Version.load(${av.versionIndex})'><span class='vAText'><b>${name + "\n"}</b><br>Cost: ${cost + "\n"}<br>After: ${av.results.calcTime}ms<br><button onclick='Version.propagate(${av.versionIndex})'>Propagate</button></span><span class='smallImgSpan'><img class='smallImg' src='${Canvas.imgSrcOfVer(av)}' width='70' height='70'></span></div>`;

          let width = (101-Version.history[hi].length)/Version.history[hi].length;
          for(let i = 0; i < Version.history[hi].length; i++){
            document.getElementById("vA"+Version.history[hi][i].versionIndex).style = `width: ${width}%; margin-right: ${i==Version.history[hi].length-1?"0":"1"}%;`;
          }
        }else console.log("Version for alternative not in history.");
      }
    },
    propagate: (aid) => {
      let eDiff = [];
      console.log(Version.store[aid].routeSettings.straightEdges)
      for(let se of Version.current.routeSettings.straightEdges){
        let fine = false;
        for(let se2 of Version.store[aid].routeSettings.straightEdges){
          if(se.every(e => se2.some(e2 => e2.id == e.id))) fine = true;
        }
        if(!fine) for(let e of se) eDiff.push(1*e.id);
      }
      console.log(eDiff);
      let groupS = [];
      let blocked = [];
      for(let e in Version.store[aid].graphs.cG.edges) if(Version.store[aid].graphs.cG.edges[e].chain.some(e2 => eDiff.includes(1*e2.id))){
        e = Version.store[aid].graphs.cG.edges[e];
        e.gssVisited = true;
        blocked.push(e);
        groupS.push(e.s);
        groupS.push(e.t);
      }
      console.log(groupS);
      let findGroup = v => {
        let es = [];
        for(let e2 of v.es){
          if(e2.gssVisited) continue;
          es.push(e2);
          e2.gssVisited = true;
          es = es.concat(findGroup(Util.Edge.v2(e2, v)));
        }
        return es;
      }
      let groupS2 = [];
      for(let v of groupS){
        let gr = findGroup(v);
        console.log(gr)
        let vs = [];
        groupS2.push(v);
        for(let e of gr){
          if(!vs.includes(e.s)) vs.push(e.s);
          if(!vs.includes(e.t)) vs.push(e.t);
        }
        let first = true;
        for(let v2 of vs){
          if(Version.current.routeSettings.positionedStations[v2.id]){
            // console.log(first, v2.id, Util.Edge.v2(e, v2))
            if(first) first = false;
            else for(let e of v2.es){
              blocked.push(e);
              groupS2.push(Util.Edge.v2(e, v2));
            }
          }
        }
      }
      for(let e in Version.store[aid].graphs.cG.edges) delete Version.store[aid].graphs.cG.edges[e].gssVisited;
      for(let e of blocked) e.gssVisited = true;
      console.log(groupS2);

      Version.current.routeSettings.frozenEdges = {};
      let gid = 0;
      for(let v of groupS2){
        let gr = findGroup(v);
        console.log(gr)
        if(gr.length > 0){
          for(let e of gr){
            let btps = [];
            for(let i = 1; i < e.path.length-2; i += 2){
              btps.push(e.path[i].parent.ports.indexOf(e.path[i]));
            }
            Version.current.routeSettings.frozenEdges[e.id] = {groupID: gid, bendToPortSeq: btps, iSTDiff: e.t.gridNode.gridCoords.i-e.s.gridNode.gridCoords.i,  jSTDiff: e.t.gridNode.gridCoords.j-e.s.gridNode.gridCoords.j};
          }
        }
        gid++;
      }
      for(let e in Version.store[aid].graphs.cG.edges) delete Version.store[aid].graphs.cG.edges[e].gssVisited;
      MetroMap.Routing.recalcAll(Version.current);
      Version.edited("Propagated");
      
    },
    dupe: (ver, dupeVerID) => {
      let cv = {
        isCurrent: true,
        versionIndex: dupeVerID,
        currentToolID: ver.currentToolID,
        viewport: Util.cloneDict(null, ver.viewport),
        costs: Util.cloneDict(null, ver.costs),
        checkBoxes: Util.cloneDict(null, ver.checkBoxes),
        objectStore: {idCounter: 0, objects: {}} //gets overwritten
      };
      for(let o in ver.objectStore.objects){
        if(ver.objectStore.objects[o].objType == "Point") Geometry.objTypes.Point.dupe(ver.objectStore.objects[o], cv);
      }
      for(let o in ver.objectStore.objects){
        if(ver.objectStore.objects[o].objType == "LineSegment") Geometry.objTypes.LineSegment.dupe(ver.objectStore.objects[o], cv);
      }
      // cv.objectStore = {idCounter: ver.objectStore.idCounter, objects: objects}; 
      cv.graphs = Util.cloneDict(cv, ver.graphs, [], true);
      if(ver.graphs.gridG.s2sDijkstraIDSortedVtcs){
        cv.graphs.gridG.s2sDijkstraIDSortedVtcs = [];
        for(let v of ver.graphs.gridG.s2sDijkstraIDSortedVtcs) cv.graphs.gridG.s2sDijkstraIDSortedVtcs.push(cv.graphs.gridG.vertices[v.id]);
      }
      for(let e in ver.graphs.gridG.edges){
        if(ver.graphs.gridG.edges[e].origEdge) cv.graphs.gridG.edges[e].origEdge = cv.graphs.cG.edges[ver.graphs.gridG.edges[e].origEdge.id];
        if(ver.graphs.gridG.edges[e].blockedDiagonals){
          cv.graphs.gridG.edges[e].blockedDiagonals = [];
          for(let bd of ver.graphs.gridG.edges[e].blockedDiagonals) cv.graphs.gridG.edges[e].blockedDiagonals.push(cv.graphs.gridG.edges[bd.id]);
        }
      }
      for(let e in ver.graphs.cG.edges){
        if(ver.graphs.cG.edges[e].path){
          cv.graphs.cG.edges[e].path = [];
          for(let v of ver.graphs.cG.edges[e].path) cv.graphs.cG.edges[e].path.push(cv.graphs.gridG.vertices[v.id]);
        }
        if(ver.graphs.cG.edges[e].edgePath){
          cv.graphs.cG.edges[e].edgePath = [];
          for(let e2 of ver.graphs.cG.edges[e].edgePath) cv.graphs.cG.edges[e].edgePath.push(cv.graphs.gridG.edges[e2.id]);
        }
        if(ver.graphs.cG.edges[e].chain){
          cv.graphs.cG.edges[e].chain = [];
          for(let e2 of ver.graphs.cG.edges[e].chain) cv.graphs.cG.edges[e].chain.push(cv.graphs.mG.edges[e2.id]);
        }
      }
      // if(ver.graphs.deg2G) for(let e in ver.graphs.deg2G.edges){ idk why that was here
      //   if(ver.graphs.currG.edges[e].edgePath){
      //     cv.graphs.currG.edges[e].edgePath = [];
      //     for(let e2 of ver.graphs.currG.edges[e].edgePath) cv.graphs.currG.edges[e].edgePath.push(cv.graphs.gridG.edges[e2.id]);
      //   }
      // }
      for(let v in ver.graphs.gridG.vertices){
        if(ver.graphs.gridG.vertices[v].origStation) cv.graphs.gridG.vertices[v].origStation = cv.graphs.cG.vertices[ver.graphs.gridG.vertices[v].origStation.id];
      }
      for(let v in ver.graphs.mG.vertices){
        if(ver.graphs.mG.vertices[v].contract){
          cv.graphs.mG.vertices[v].contract = {visited: ver.graphs.mG.vertices[v].contract.visited};
          if(ver.graphs.mG.vertices[v].contract.v) cv.graphs.mG.vertices[v].contract.v = cv.graphs.cG.vertices[ver.graphs.mG.vertices[v].contract.v.id];
        }
      }
      for(let v in ver.graphs.cG.vertices){
        if(ver.graphs.cG.vertices[v].gridNode) cv.graphs.cG.vertices[v].gridNode = cv.graphs.gridG.vertices[ver.graphs.cG.vertices[v].gridNode.id];
        if(ver.graphs.cG.vertices[v].contractParent) cv.graphs.cG.vertices[v].contractParent = cv.graphs.mG.vertices[ver.graphs.cG.vertices[v].contractParent.id];
      }
      for(let o in ver.objectStore.objects){
        if(ver.objectStore.objects[o].objType == "LineBundle" || ver.objectStore.objects[o].objType == "Station"){
          Geometry.objTypes[ver.objectStore.objects[o].objType].dupe(ver.objectStore.objects[o], cv);
          if(ver.objectStore.objects[o].objType == "LineBundle") cv.objectStore.objects[o].e.lb = cv.objectStore.objects[o];
          else if(!cv.objectStore.objects[o].expandedStation) cv.objectStore.objects[o].v.station = cv.objectStore.objects[o];
        }
      }
      for(let o in ver.objectStore.objects){
        if(ver.objectStore.objects[o].objType == "LineBundle" && ver.objectStore.objects[o].expandedStations){
          cv.objectStore.objects[o].expandedStations = [];
          for(let s of ver.objectStore.objects[o].expandedStations) cv.objectStore.objects[o].expandedStations.push(cv.objectStore.objects[s.id]);
        }
      }
      cv.objectStore.idCounter = ver.objectStore.idCounter;
      // for(let o in ver.objectStore.objects){
      //   if(ver.objectStore.objects[o].v){
      //     // cv.objectStore.objects[o].v = ver.objectStore.objects[o].dupe(cv);
      //   }
      // }
      let edgeOrder = [];
      let stations = [];
      let lineBundles = [];
      let vertexOrder = [];
      let resultDijkstras = [];
      for(let e of ver.results.edgeOrder) edgeOrder.push(cv.graphs.cG.edges[e.id]);
      for(let s of ver.results.lineDrawing[0]) stations.push(cv.objectStore.objects[s.id]);
      for(let lb of ver.results.lineDrawing[1]) lineBundles.push(cv.objectStore.objects[lb.id]);
      // for(let v of ver.results.vertexOrder) vertexOrder.push(cv.graphs.cG.vertices[v.id]); //TODO remove?
      for(let d of ver.results.resultDijkstras){
        let path = [];
        let edgePath = [];
        for(let v of d[2]) path.push(cv.graphs.gridG.vertices[v.id]);
        for(let e of d[3]) edgePath.push(cv.graphs.gridG.edges[e.id]);
        resultDijkstras.push([d[0], d[1], path, edgePath, cv.graphs.cG.edges[d[4].id]]);
      }
      cv.results = {edgeOrder: edgeOrder, lineDrawing: [stations, lineBundles], vertexOrder: vertexOrder, resultDijkstras: resultDijkstras, cost: 0, calcTime: 0};
      let contractAllowed = {};
      for(let v in ver.routeSettings.contractAllowed) contractAllowed[v] = ver.routeSettings.contractAllowed[v];
      let straightEdges = [];
      for(let se of ver.routeSettings.straightEdges) straightEdges.push(se.map(e => cv.graphs.mG.edges[e.id]));
      let positionedStations = {};
      for(let v in ver.routeSettings.positionedStations) positionedStations[v] = cv.graphs.gridG.vertices[ver.routeSettings.positionedStations[v].id];
      let frozenEdges = {};
      for(let e in ver.routeSettings.frozenEdges) frozenEdges[e] = {groupID: ver.routeSettings.frozenEdges[e].groupID, bendToPortSeq: ver.routeSettings.frozenEdges[e].bendToPortSeq.map(p => p), iSTDiff: ver.routeSettings.frozenEdges[e].iSTDiff, jSTDiff: ver.routeSettings.frozenEdges[e].jSTDiff};
      let movedInputs = {};
      for(let v in ver.routeSettings.movedInputs) movedInputs[v] = {x: ver.routeSettings.movedInputs[v].x, y: ver.routeSettings.movedInputs[v].y};
      cv.routeSettings = {disallowBends: ver.routeSettings.disallowBends, contractAllowed: contractAllowed, straightEdges: straightEdges, positionedStations: positionedStations, frozenEdges: frozenEdges, movedInputs: movedInputs};
      return cv;
    },
    load: (verID) => {
      let ver = Version.store[verID];
      if(document.getElementsByClassName("active").length > 0) document.getElementsByClassName("active")[0].classList.remove("active");
      document.getElementById("vA"+verID).classList.add("active");
      document.getElementById("timeOut").innerText = "Loaded Version " + verID;
      let cv = Version.dupe(ver, Version.nextFreeIndex++);
      Version.current.isCurrent = false;
      Version.store[cv.versionIndex] = cv;
      Version.current = cv;
      Version.current.isCurrent = true;
      Canvas.redraw();
      for(let c of [["GridResIn", "gr"], ["45CostIn", "c45"], ["90CostIn", "c90"], ["135CostIn", "c135"], ["180CostIn", "c180"], ["MoveCostIn", "cm"], ["SinkCostIn", "cs"], ["HopCostIn", "ch"], ["CompressionCostIn", "cc"], ["CandidateRadiusIn", "candidateRadius"], ["LivePreviewRangeIn", "livePreviewRange"]]) 
        document.getElementById(c[0]).innerText = ver.costs[c[1]];
      for(let cb in ver.checkBoxes) document.getElementById(cb).checked = ver.checkBoxes[cb];
      for(let e of document.getElementById("toolBox").children) e.firstChild.checked = e.firstChild.id == ver.currentToolID;
      Tool.updateCurrentTool(true);
      Util.updateCosts();
    },
    setup: () => {
      Version.current = Version.getDefault();
      Version.history = [[Version.current]];
      Version.store[0] = Version.current;
    },
    getSelVer: () => {
      return Version.store[document.getElementsByClassName("versionAlternative active")[0].id.substring(2)];
    }
  };

  var Tool = {
    currentToolID: "navigate",
    defaultBehavior: {
      "click": event => {},
      "mousemove": event => {},
      "mousedown": event => {},
      "mouseup": event => {},
      "select": event => {},
      "deselect": event => {},
      "keydown": event => {
        if(event.code == "Backspace"){
          
        }else if(event.code == "KeyY"){
          // undo();
        }else if(event.code == "KeyR"){
          // redo();
        }
      },
      "keyup": event => {},
      "wheel": event => {
        event.preventDefault();
        Canvas.viewport.x += Canvas.viewport.w*event.deltaX/Canvas.bounds.w;
        Canvas.viewport.y += Canvas.viewport.h*event.deltaY/Canvas.bounds.h;
        // Canvas.viewPortDetails();
        Canvas.redraw();
      },
      "mouseleave": event => {
        if("clicking" in Tool.allTools[Tool.currentToolID].attributes && Tool.allTools[Tool.currentToolID].attributes.clicking){
          let parentPosition = Util.getPosition(event.currentTarget);
          let ev = {
            currentTarget: event.currentTarget,
            clientX: Math.min(Math.max(0, event.clientX-parentPosition.x), 700)+parentPosition.x,
            clientY: Math.min(Math.max(0, event.clientY-parentPosition.y), 700)+parentPosition.y,
            type: "mouseup"
          };
          Tool.handleEvent(ev);
        }
      },
      "mouseenter": event => {
        if("clicking" in Tool.allTools[Tool.currentToolID].attributes && event.buttons == 1){
          let parentPosition = Util.getPosition(event.currentTarget);
          let ev = {
            currentTarget: event.currentTarget,
            clientX: Math.min(Math.max(0, event.clientX-parentPosition.x), 700)+parentPosition.x,
            clientY: Math.min(Math.max(0, event.clientY-parentPosition.y), 700)+parentPosition.y,
            type: "mousedown"
          };
          Tool.handleEvent(ev);
        }
      }
    },
    selectionModes: {
      "none": {"initState": () => {return {}}},
      "vertexConnected": {
        "initState": () => {return {draggingSel: false, hl: [], sel: [], dragStart: null, lastMouseEvent: null, keys: {}, wStart: null}},
        "recalcHl": (event, gType, selState) => {
          let g = Version.current.graphs[gType];
          for(let v of selState.hl){
            v.p.visual.highlightShown = false;
            v.p.visual.highlightColor = Canvas.Colors.highlight;
          }
          if(selState.draggingSel){
            selState.hl = [];
            for(let v of selState.sel){
              v.p.visual.highlightShown = true;
              selState.hl.push(v);
            }
            let mc = Canvas.mouseCoords(event);
            let dd = {x: mc.x-1*selState.dragStart.x, y: mc.y-1*selState.dragStart.y};
            selState.dragStart = mc;
            return {consume: false, selInfo: {dragDiff: dd, selection: selState.sel}, selState: selState};
          }else if(selState.wStart && selState.sel.length == 0){
            let nt = Util.nearestTokens(Version.current, event, g.vertices, v => v.p, v => v != selState.wStart).tokens[0];
            if(Canvas.pixelDistPToMouse(nt.p, event) < 25){
              selState.hl = Util.bfsPath(selState.wStart, nt);
            }else selState.hl = [selState.wStart];
            selState.wStart.p.visual.highlightColor = Canvas.Colors.wSel1;
          }else{
            if(selState.keys["q"]){
              let nt = Util.nearestTokens(Version.current, event, g.vertices, v => v.p).tokens[0];
              if(Canvas.pixelDistPToMouse(nt.p, event) < 25){
                selState.hl = Util.getSmallestSubgraph(nt);
              }
            }else if(selState.keys["w"]){
              let nt = Util.nearestTokens(Version.current, event, g.vertices, v => v.p).tokens[0];
              if(Canvas.pixelDistPToMouse(nt.p, event) < 25){
                nt.p.visual.highlightColor = Canvas.Colors.wSel1;
                selState.hl = [nt];
              }
            }else if(selState.keys["e"]){
              selState.hl = [];
              for(let v of selState.sel){
                selState.hl.push(v);
              }
              if(selState.sel.length == 0){
                let nt = Util.nearestTokens(Version.current, event, g.vertices, v => v.p).tokens[0];
                if(Canvas.pixelDistPToMouse(nt.p, event) < 25){
                  selState.hl = [nt];
                }
              }else{
                let selWithFringe = {};
                for(let v of selState.sel){
                  selWithFringe[v.id] = v;
                  if(v.gType == "gridG") for(let e of v.origStation.es) selWithFringe[Util.Edge.v2(e, v.origStation).gridNode.id] = Util.Edge.v2(e, v.origStation).gridNode;
                  else for(let e of v.es) selWithFringe[Util.Edge.v2(e, v).id] = Util.Edge.v2(e, v);
                }
                let nt = Util.nearestTokens(Version.current, event, selWithFringe, v => v.p, v => true, false).tokens[0];
                // let nt = Util.nearestTokens(Version.current, event, g.vertices, v => v.p, v => selState.sel.some(v2 => v == v2 || v2.es.some(e => v == Util.Edge.v2(e, v2)))).tokens[0];
                if(Canvas.pixelDistPToMouse(nt.p, event) < 25){
                  if(selState.sel.includes(nt)){
                    nt.p.visual.highlightColor = Canvas.Colors.eSel2;
                  }else{
                    nt.p.visual.highlightColor = Canvas.Colors.eSel1;
                    selState.hl.push(nt);
                  }
                }
              }
            }else{
              if(selState.sel.length == 0){
                let nt = Util.nearestTokens(Version.current, event, g.vertices, v => v.p).tokens[0];
                if(Canvas.pixelDistPToMouse(nt.p, event) < 25){
                  selState.hl = [nt];
                }else{
                  selState.hl = [];
                }
              }else{
                selState.hl = [];
                for(let v of selState.sel){
                  selState.hl.push(v);
                }
              }
            }
          }
          if(gType == "gridG"){
            let gids = [];
            for(let v of selState.hl){
              for(let e of v.origStation.es) if(Version.current.routeSettings.frozenEdges[e.id] && !gids.includes(Version.current.routeSettings.frozenEdges[e.id].groupID)) gids.push(Version.current.routeSettings.frozenEdges[e.id].groupID); 
            }
            for(let e in Version.current.routeSettings.frozenEdges){
              if(gids.includes(Version.current.routeSettings.frozenEdges[e].groupID)){
                if(!selState.hl.includes(Version.current.graphs.cG.edges[e].s.gridNode)) selState.hl.push(Version.current.graphs.cG.edges[e].s.gridNode);
                if(!selState.hl.includes(Version.current.graphs.cG.edges[e].t.gridNode)) selState.hl.push(Version.current.graphs.cG.edges[e].t.gridNode);
              }
            }
          }
          for(let v of selState.hl){
            v.p.visual.highlightShown = true;
          }
          return {consume: true, selInfo: null, selState: selState};
        },
        "mousemove": (event, gType, selState) => {
          selState.lastMouseEvent = event;
          return Tool.selectionModes.vertexConnected.recalcHl(event, gType, selState);
        },
        "mousedown": (event, gType, selState) => {
          let g = Version.current.graphs[gType];
          if(selState.wStart && selState.sel.length == 0){
            let nt = Util.nearestTokens(Version.current, event, g.vertices, v => v.p, v => v != selState.wStart).tokens[0];
            if(Canvas.pixelDistPToMouse(nt.p, event) < 25){
              selState.sel = Util.bfsPath(selState.wStart, nt);
            }
          }else{
            let nt = Util.nearestTokens(Version.current, event, g.vertices, v => v.p).tokens[0];
            let closeEnough = Canvas.pixelDistPToMouse(nt.p, event) < 25;
            if(!selState.keys["q"] && !selState.keys["w"] && !selState.keys["e"]){
              if(selState.sel.length <= 1){
                selState.sel = [nt];
              }
              selState.draggingSel = true;
              selState.dragStart = Canvas.mouseCoords(event);
            }else{
              if(selState.keys["q"] && closeEnough){
                selState.sel = Util.getSmallestSubgraph(nt);
              }else if(selState.keys["w"] && closeEnough){
                if(selState.wStart && selState.sel.length > 0){
                  selState.sel = [];
                  selState.wStart = nt;
                }else{
                  selState.wStart = nt;
                }
              }else if(selState.keys["e"] && closeEnough){ //TODO prevent removal of vtcs that break connectivity
                if(selState.sel.length == 0){
                  selState.sel = [nt];
                  console.log("added to sel")
                }else{
                  let selWithFringe = {};
                  for(let v of selState.sel){
                    selWithFringe[v.id] = v;
                    if(v.gType == "gridG") for(let e of v.origStation.es) selWithFringe[Util.Edge.v2(e, v.origStation).gridNode.id] = Util.Edge.v2(e, v.origStation).gridNode;
                    else for(let e of v.es) selWithFringe[Util.Edge.v2(e, v).id] = Util.Edge.v2(e, v);
                  }
                  nt = Util.nearestTokens(Version.current, event, selWithFringe, v => v.p, v => true, false).tokens[0];
                  if(Canvas.pixelDistPToMouse(nt.p, event) < 25){
                    if(selState.sel.includes(nt)) selState.sel.splice(selState.sel.indexOf(nt), 1);
                    else selState.sel.push(nt);
                  }
                }
              }
              selState.wEnd = null;
            }
          }
          if(gType == "gridG"){
            let gids = [];
            for(let v of selState.sel){
              for(let e of v.origStation.es) if(Version.current.routeSettings.frozenEdges[e.id] && !gids.includes(Version.current.routeSettings.frozenEdges[e.id].groupID)) gids.push(Version.current.routeSettings.frozenEdges[e.id].groupID); 
            }
            for(let e in Version.current.routeSettings.frozenEdges){
              if(gids.includes(Version.current.routeSettings.frozenEdges[e].groupID)){
                if(!selState.sel.includes(Version.current.graphs.cG.edges[e].s.gridNode)) selState.sel.push(Version.current.graphs.cG.edges[e].s.gridNode);
                if(!selState.sel.includes(Version.current.graphs.cG.edges[e].t.gridNode)) selState.sel.push(Version.current.graphs.cG.edges[e].t.gridNode);
              }
            }
          }
          selState.lastMouseEvent = event;
          return Tool.selectionModes.vertexConnected.recalcHl(event, gType, selState);
        },
        "mouseup": (event, gType, selState) => {
          let ret = Tool.selectionModes.vertexConnected.recalcHl(event, gType, selState);
          selState.draggingSel = false;
          if(selState.sel.length == 1 && !selState.keys["e"]) selState.sel = [];
          selState.lastMouseEvent = event;
          return ret;
        },
        "keydown": (event, gType, selState) => { //TODO selInfo if not consumed, recalcHl on reset
          if(!("qwer".includes(event.key)) || event.repeat) return {consume: false, selInfo: null, selState: selState};
          if(event.key == "r" || (selState.sel.length > 0 && event.key != "e")) {
            for(let v of selState.hl){
              v.p.visual.highlightColor = Canvas.Colors.highlight;
              v.p.visual.highlightShown = false;
            }
            selState = Tool.selectionModes.vertexConnected.initState();
          }
          if(event.key != "r") selState.keys[event.key] = true;
          if(selState.lastMouseEvent) return Tool.selectionModes.vertexConnected.recalcHl(selState.lastMouseEvent, gType, selState);
          return {consume: true, selInfo: null, selState: selState};
        },
        "keyup": (event, gType, selState) => {
          if(!("qwe".includes(event.key)) || event.repeat) return {consume: false, selInfo: null, selState: selState};
          selState.keys[event.key] = false;
          if(selState.lastMouseEvent) return Tool.selectionModes.vertexConnected.recalcHl(selState.lastMouseEvent, gType, selState);
          return {consume: true, selInfo: null, selState: selState};
        },
        "deselect": (event, gType, selState) => {
          for(let v of selState.hl){
            v.p.visual.highlightColor = Canvas.Colors.highlight;
            v.p.visual.highlightShown = false;
          }
          selState = Tool.selectionModes.vertexConnected.initState();
          return {consume: false, selInfo: null, selState: selState};
        },
        "changeSelection": (newSel, gType, selState) => {
          selState.sel = newSel;
          return Tool.selectionModes.vertexConnected.recalcHl(selState.lastMouseEvent, gType, selState);
        }
      },
      "edgeConnected": {
        "initState": () => {return {hl: [], sel: [], lastMouseEvent: null, keys: {}, wStart: null}},
        "recalcHl": (event, gType, selState) => {
          let g = Version.current.graphs[gType];
          for(let ls of selState.hl){
            ls.visual.highlightShown = false;
            ls.visual.highlightColor = Canvas.Colors.highlight;
          }
          if(selState.wStart && selState.sel.length == 0){
            let nt = Util.nearestTokens(Version.current, event, g.edges, e => e.ls, e => e != selState.wStart).tokens[0];
            if(Canvas.pixelDistEToMouse(nt, event, gType == "gridG") < 25){
              selState.hl = Util.bfsPath(selState.wStart, nt);
            }else selState.hl = [selState.wStart];
            if(gType == "gridG") for(let e of selState.wStart.edgePath) e.ls.visual.highlightColor = Canvas.Colors.wSel1;
            else selState.wStart.ls.visual.highlightColor = Canvas.Colors.wSel1;
          }else{
            if(selState.keys["q"]){
              let nt = Util.nearestTokens(Version.current, event, g.edges, e => e.ls).tokens[0];
              if(Canvas.pixelDistEToMouse(nt, event, gType == "gridG") < 25){
                selState.hl = Util.getSmallestSubgraph(nt);
              }else selState.hl = [];
            }else if(selState.keys["w"]){
              let nt = Util.nearestTokens(Version.current, event, g.edges, e => e.ls).tokens[0];
              if(Canvas.pixelDistEToMouse(nt, event, gType == "gridG") < 25){
                if(gType == "gridG") for(let e of nt.edgePath) e.ls.visual.highlightColor = Canvas.Colors.wSel1;
                else nt.ls.visual.highlightColor = Canvas.Colors.wSel1;
                selState.hl = [nt];
              }else selState.hl = [];
            }else if(selState.keys["e"]){
              selState.hl = [];
              for(let e of selState.sel){
                selState.hl.push(e);
              }
              if(selState.sel.length == 0){
                let nt = Util.nearestTokens(Version.current, event, g.edges, e => e.ls).tokens[0];
                if(Canvas.pixelDistEToMouse(nt, event, gType == "gridG") < 25){
                  selState.hl = [nt];
                }
              }else{
                if(gType == "gridG"){
                  let selWithFringe = {};
                  for(let e of selState.sel){
                    for(let e2 of e.s.es) for(let e3 of e2.edgePath) selWithFringe[e3.id] = e3;
                    for(let e2 of e.t.es) for(let e3 of e2.edgePath) selWithFringe[e3.id] = e3;
                  }
                  let nt = Util.nearestTokens(Version.current, event, selWithFringe, e => e.ls, () => true, false).tokens[0];
                  if(Canvas.pixelDistEToMouse(nt.origEdge, event, true) < 25){
                    if(selState.sel.includes(nt.origEdge)){
                      for(let e of nt.origEdge.edgePath) e.ls.visual.highlightColor = Canvas.Colors.eSel2;
                    }else{
                      for(let e of nt.origEdge.edgePath) e.ls.visual.highlightColor = Canvas.Colors.eSel1;
                      selState.hl.push(nt.origEdge);
                    }
                  }
                }else{
                  let selWithFringe = {};
                  for(let e of selState.sel){
                    for(let e2 of e.s.es) selWithFringe[e2.id] = e2;
                    for(let e2 of e.t.es) selWithFringe[e2.id] = e2;
                  }
                  let nt = Util.nearestTokens(Version.current, event, selWithFringe, e => e.ls).tokens[0];
                  if(Canvas.pixelDistEToMouse(nt, event, false) < 25){
                    if(selState.sel.includes(nt)){
                      nt.ls.visual.highlightColor = Canvas.Colors.eSel2;
                    }else{
                      nt.ls.visual.highlightColor = Canvas.Colors.eSel1;
                      selState.hl.push(nt);
                    }
                  }
                }
              }
            }else{
              if(selState.sel.length == 0){
                let nt = Util.nearestTokens(Version.current, event, g.edges, e => e.ls).tokens[0];
                if(Canvas.pixelDistEToMouse(nt, event, gType == "gridG") < 25){
                  selState.hl = [nt];
                }else{
                  selState.hl = [];
                }
              }else{
                selState.hl = [];
                for(let e of selState.sel){
                  selState.hl.push(e);
                }
              }
            }
          }
          let hl = [];
          for(let e of selState.hl){
            if(gType == "gridG"){
              if(Version.current.routeSettings.frozenEdges[e.id]) continue;
              for(let e2 of e.edgePath){
                hl.push(e2.ls);
                e2.ls.visual.highlightShown = true;
              }
            }else{
              hl.push(e.ls);
              e.ls.visual.highlightShown = true;
            }
          }
          selState.hl = hl;
          return {consume: true, selInfo: null, selState: selState};
        },
        "mousemove": (event, gType, selState) => {
          selState.lastMouseEvent = event;
          return Tool.selectionModes.edgeConnected.recalcHl(event, gType, selState);
        },
        "mousedown": (event, gType, selState) => {
          let g = Version.current.graphs[gType];
          if(selState.wStart && selState.sel.length == 0){
            let nt = Util.nearestTokens(Version.current, event, g.edges, e => e.ls, e => e != selState.wStart).tokens[0];
            if(Canvas.pixelDistEToMouse(nt, event, gType == "gridG") < 25){
              selState.sel = Util.bfsPath(selState.wStart, nt);
              selState.wStart = null;
            }
          }else{
            let nt = Util.nearestTokens(Version.current, event, g.edges, e => e.ls).tokens[0];
            let closeEnough = Canvas.pixelDistEToMouse(nt, event, gType == "gridG") < 25;
            if(!selState.keys["q"] && !selState.keys["w"] && !selState.keys["e"]){
              if(selState.sel.length <= 1){
                selState.sel = [nt];
              }
            }else{
              if(selState.keys["q"] && closeEnough){
                selState.sel = Util.getSmallestSubgraph(nt);
              }else if(selState.keys["w"] && closeEnough){
                if(selState.wStart && selState.sel.length > 0){
                  selState.sel = [];
                  selState.wStart = nt;
                }else{
                  selState.wStart = nt;
                }
              }else if(selState.keys["e"] && closeEnough){ //TODO prevent removal of edges that break connectivity
                if(selState.sel.length == 0){
                  selState.sel = [nt];
                  console.log("added to sel")
                }else{
                  if(gType == "gridG"){
                    let selWithFringe = {};
                    for(let e of selState.sel){
                      for(let e2 of e.s.es) for(let e3 of e2.edgePath) selWithFringe[e3.id] = e3;
                      for(let e2 of e.t.es) for(let e3 of e2.edgePath) selWithFringe[e3.id] = e3;
                    }
                    nt = Util.nearestTokens(Version.current, event, selWithFringe, e => e.ls, () => true, false).tokens[0];
                    if(Canvas.pixelDistEToMouse(nt.origEdge, event, true) < 25){
                      if(selState.sel.includes(nt.origEdge)) selState.sel.splice(selState.sel.indexOf(nt.origEdge), 1);
                      else selState.sel.push(nt.origEdge);
                    }
                  }else{
                    let selWithFringe = {};
                    for(let e of selState.sel){
                      for(let e2 of e.s.es) selWithFringe[e2.id] = e2;
                      for(let e2 of e.t.es) selWithFringe[e2.id] = e2;
                    }
                    nt = Util.nearestTokens(Version.current, event, selWithFringe, e => e.ls).tokens[0];
                    if(Canvas.pixelDistEToMouse(nt, event, false) < 25){
                      if(selState.sel.includes(nt)) selState.sel.splice(selState.sel.indexOf(nt), 1);
                      else selState.sel.push(nt);
                    }
                  }
                }
              }
              selState.wEnd = null;
            }
          }
          for(let e of selState.sel) if(Version.current.routeSettings.frozenEdges[e.id]) selState.sel.splice(selState.sel.indexOf(e), 1);
          selState.lastMouseEvent = event;
          return Tool.selectionModes.edgeConnected.recalcHl(event, gType, selState);
        },
        "mouseup": (event, gType, selState) => {
          // if(selState.sel.length == 1 && !selState.keys["e"]) selState.sel = [];
          selState.lastMouseEvent = event;
          return Tool.selectionModes.edgeConnected.recalcHl(event, gType, selState);
        },
        "keydown": (event, gType, selState) => { //TODO selInfo if not consumed, recalcHl on reset
          if(event.key == "Enter" && !event.repeat) return {consume: false, selInfo: {selection: selState.sel}, selState: selState};
          if(!("qwer".includes(event.key)) || event.repeat) return {consume: false, selInfo: null, selState: selState};
          if(event.key == "r" || (selState.sel.length > 0 && event.key != "e")) {
            for(let ls of selState.hl){
              ls.visual.highlightColor = Canvas.Colors.highlight;
              ls.visual.highlightShown = false;
            }
            selState = Tool.selectionModes.edgeConnected.initState();
          }
          if(event.key != "r") selState.keys[event.key] = true;
          if(selState.lastMouseEvent) return Tool.selectionModes.edgeConnected.recalcHl(selState.lastMouseEvent, gType, selState);
          return {consume: true, selInfo: null, selState: selState};
        },
        "keyup": (event, gType, selState) => {
          if(!("qwe".includes(event.key)) || event.repeat) return {consume: false, selInfo: null, selState: selState};
          selState.keys[event.key] = false;
          if(selState.lastMouseEvent) return Tool.selectionModes.edgeConnected.recalcHl(selState.lastMouseEvent, gType, selState);
          return {consume: true, selInfo: null, selState: selState};
        },
        "deselect": (event, gType, selState) => {
          for(let ls of selState.hl){
            ls.visual.highlightColor = Canvas.Colors.highlight;
            ls.visual.highlightShown = false;
          }
          selState = Tool.selectionModes.edgeConnected.initState();
          return {consume: false, selInfo: null, selState: selState};
        },
        "changeSelection": (newSel, gType, selState) => {
          selState.sel = newSel;
          if(selState.lastMouseEvent) return Tool.selectionModes.edgeConnected.recalcHl(selState.lastMouseEvent, gType, selState);
        }
      }
    },
    allTools: {
      /*"inspect": {id: "inspect", label: "Inspect Object", sm: {mode: "none", gType: "", selState: null}, suggCBs: {}, attributes: {minOs: []}, events: {
        "deselect": (event, attributes, selInfo) => {
          for(let o of attributes.minOs) o.visual.highlightShown = false;
          Canvas.redraw();
        }, 
        "mousemove": (event, attributes, selInfo) => {
          for(let o of attributes.minOs) o.visual.highlightShown = false;
          attributes.minOs = Util.nearestTokens(Version.current, event, Version.current.objectStore.objects, o => o, o => o.visual.objectShown && !o.simpleVisLine).tokens;
          for(let o of attributes.minOs) o.visual.highlightShown = true;
          Canvas.redraw();
        }, 
        "click": (event, attributes, selInfo) => {
          for(let o of attributes.minOs) console.log(o);
        }
      }},*/
      "navigate": {id: "navigate", label: "Navigate", sm: {mode: "none", gType: "", selState: null}, suggCBs: {}, attributes: {clicking: false}, events: {
        "wheel": (event, attributes, selInfo) => {
          let parentPosition = Util.getPosition(event.currentTarget);
          event.preventDefault();
          Canvas.zoomView(event.deltaY, event.deltaY, event.clientX-parentPosition.x, event.clientY-parentPosition.y);
          // Canvas.viewPortDetails();
          Canvas.redraw();
        }, 
        "mousemove": (event, attributes, selInfo) => {
          if(attributes.clicking){
            Canvas.viewport.x -= Canvas.viewport.w*event.movementX/Canvas.bounds.w;
            Canvas.viewport.y -= Canvas.viewport.h*event.movementY/Canvas.bounds.h;
            // Canvas.viewPortDetails();
            Canvas.redraw();
          }
        }, 
        "mousedown": (event, attributes, selInfo) => {
          attributes.clicking = true;
        }, 
        "mouseup": (event, attributes, selInfo) => {
          attributes.clicking = false;
        }
      }},
      "dragVtx": {id: "dragVtx", label: "Move Input", sm: {mode: "vertexConnected", gType: "cG", selState: null}, suggCBs: {"cbShowMG": false, "cbShowCG": true}, attributes: {}, events: {
        "mousemove": (event, attributes, selInfo) => {
          let sT = Date.now();
          for(let v of selInfo.selection){
            v.p.x += 1*selInfo.dragDiff.x;
            v.p.y += 1*selInfo.dragDiff.y;
            // if(v.contract && v.contract.v){
            //   v.contract.v.p.x += selInfo.dragDiff.x;
            //   v.contract.v.p.y += selInfo.dragDiff.y;
            // }
            // r += v.es.reduce((acc, e) => acc+(Geometry.distanceBetween(e.s.p, e.t.p)/Version.current.graphs.gridG.D), 0);
          }
          // if(Version.current.costs.livePreviewRange > MetroMap.Routing.estimateRouteVerticesDistance(Version.current, selInfo.selection.filter(v => v.contract && v.contract.v).map(v => v.contract.v)))
          if(Version.current.costs.livePreviewRange > MetroMap.Routing.estimateRouteVerticesDistance(Version.current, selInfo.selection)){
            MetroMap.Routing.routeVertices(Version.current, selInfo.selection);
            MetroMap.Post.updateTimeOut(Version.current, true, Date.now()-sT); 
          }
            // Tool.allTools[Tool.currentToolID].events["mouseup"](event, attributes, selInfo);
        },
        "mouseup": (event, attributes, selInfo) => {
          let sT = Date.now();
          for(let v of selInfo.selection) Version.current.routeSettings.movedInputs[v.contractParent.id] = {x: v.p.x, y: v.p.y};
          MetroMap.Routing.recalcAll();
          MetroMap.Post.updateTimeOut(Version.current, true, Date.now()-sT);
          Version.edited("Moved " + selInfo.selection.length + " Input Nodes");
          // MetroMap.Routing.routeVertices(Version.current, selInfo.selection.filter(v => v.contract && v.contract.v).map(v => v.contract.v));
          // console.log(selInfo.selection)
          // MetroMap.Routing.routeVertices(Version.current, selInfo.selection);
          // MetroMap.Post.updateTimeOut(Version.current, true, Date.now()-sT);
          //Version.edited("Moved Input " + vid);
        }
      }},
      "changeGridPos": {id: "changeGridPos", label: "Reposition Station", sm: {mode: "vertexConnected", gType: "gridG", selState: null}, suggCBs: {"cbShowGrid": true, "cbShowResult": true}, attributes: {dragStart: null, gns: [], gnPrevShown: {}}, events: {
        "select": (event, attributes, selInfo) => {
          if(!Version.current.results.resultDijkstras || Version.current.results.resultDijkstras.length == 0) MetroMap.Routing.recalcAll(Version.current);
        },
        "mousemove": (event, attributes, selInfo) => {
          let g = Version.current.graphs.cG;
          let coords = Canvas.mouseCoords(event);
          let cellDiff = {x: Math.round((coords.x-attributes.dragStart.x)/Version.current.graphs.gridG.D), y: Math.round((coords.y-attributes.dragStart.y)/Version.current.graphs.gridG.D)};
          let bounds = {t: Version.current.graphs.gridG.gridNodes[0].length-1, r: 0, b: 0, l: Version.current.graphs.gridG.gridNodes.length-1};
          for(let v of selInfo.selection) {
            bounds.t = Math.min(bounds.t, v.gridCoords.j);
            bounds.r = Math.max(bounds.r, v.gridCoords.i);
            bounds.b = Math.max(bounds.b, v.gridCoords.j);
            bounds.l = Math.min(bounds.l, v.gridCoords.i);
          }
          if(cellDiff.x < 0) cellDiff.x = -1*Math.min(-1*cellDiff.x, bounds.l);
          else cellDiff.x = Math.min(cellDiff.x, Version.current.graphs.gridG.gridNodes.length-1-bounds.r);
          if(cellDiff.y < 0) cellDiff.y = -1*Math.min(-1*cellDiff.y, bounds.t);
          else cellDiff.y = Math.min(cellDiff.y, Version.current.graphs.gridG.gridNodes[0].length-1-bounds.b);
          for(let v in attributes.prevGnsShown){
            Version.current.graphs.gridG.vertices[v].p.visual.objectShown = attributes.prevGnsShown[v];
          }
          attributes.prevGnsShown = {};
          attributes.gns = [];
          for(let v of selInfo.selection) {
            let v2 = Version.current.graphs.gridG.gridNodes[v.gridCoords.i+cellDiff.x][v.gridCoords.j+cellDiff.y];
            attributes.prevGnsShown[v2.id] = v2.p.visual.objectShown;
            v2.p.visual.objectShown = true;
            attributes.gns.push(v2);
          }
          let ps = {};
          let stations = [];
          for(let i = 0; i < attributes.gns.length; i++){
            ps[selInfo.selection[i].origStation.id] = attributes.gns[i];
            stations.push(selInfo.selection[i].origStation);
          }
          if((cellDiff.x != 0 || cellDiff.y != 0) && Tool.allTools.changeGridPos.events.isUnoccupied(attributes, selInfo) && Version.current.costs.livePreviewRange > MetroMap.Routing.estimateRouteVerticesDistance(Version.current, stations, {positionedStations: ps})){
            Tool.allTools[Tool.currentToolID].events["mouseup"](event, attributes, selInfo);
            attributes.dragStart.x += cellDiff.x*Version.current.graphs.gridG.D; 
            attributes.dragStart.y += cellDiff.y*Version.current.graphs.gridG.D;
          }
        },
        "mousedown": (event, attributes, selInfo) => {
          attributes.dragStart = Canvas.mouseCoords(event);
        },
        "mouseup": (event, attributes, selInfo) => {
          let sT = Date.now();
          if(event.type == "mousemove" || Tool.allTools.changeGridPos.events.isUnoccupied(attributes, selInfo)){
            let stations = [];
            for(let i = 0; i < attributes.gns.length; i++){
              let v = selInfo.selection[i].origStation;
              stations.push(v);
              Version.current.routeSettings.positionedStations[v.contractParent.id] = attributes.gns[i];
            }
            MetroMap.Routing.routeVertices(Version.current, stations);
            MetroMap.Post.updateTimeOut(Version.current, true, Date.now()-sT);
            for(let v of selInfo.selection) v.p.visual.highlightShown = false;
            for(let gn of attributes.gns) gn.p.visual.highlightShown = false;
            Tool.selectionModes[Tool.allTools[Tool.currentToolID].sm.mode].changeSelection(attributes.gns, Tool.allTools[Tool.currentToolID].sm.gType, Tool.allTools[Tool.currentToolID].sm.selState);

            if(event.type == "mouseup"){
              attributes.dragStart = null;
              attributes.gns = [];
              attributes.prevGnsShown = {};
              // Tool.updateCurrentTool();
              MetroMap.Routing.recalcAll(Version.current);
              MetroMap.Post.updateTimeOut(Version.current, true, Date.now()-sT);
              Version.edited("Repositioned " + selInfo.selection.length + " Station(s)");
            }
          }else{
            console.log("didn't route because a requested location is occupied");
            for(let v in attributes.prevGnsShown){
              Version.current.graphs.gridG.vertices[v].p.visual.objectShown = attributes.prevGnsShown[v];
            }
            attributes.dragStart = null;
            attributes.gns = [];
            attributes.prevGnsShown = {};
          }
        },
        "isUnoccupied": (attributes, selInfo) => {
          let oldOccupied = {};
          for(let v of selInfo.selection) for(let e of v.origStation.es) for(let pv of e.path) if(pv.parent) oldOccupied[pv.parent.id] = (!pv.parent.origStation || selInfo.selection.includes(pv.parent));
          for(let gn of attributes.gns) if(!gn.settleable && !oldOccupied[gn.id]) return false;
          return true;
        }
      }},
      "freeStation": {id: "freeStation", label: "Free Station", sm: {mode: "none", gType: "", selState: null}, suggCBs: {"cbShowResult": true}, attributes: {highlightedV: null}, events: {
        "select": (event, attributes, selInfo) => {
          for(let v in Version.current.routeSettings.positionedStations){
            let p = Version.current.routeSettings.positionedStations[v].p;
            p.visual.highlightShown = true;
            p.visual.highlightColor = Canvas.Colors.highlight2;
          }
        },
        "deselect": (event, attributes, selInfo) => {
          for(let v in Version.current.routeSettings.positionedStations){
            let p = Version.current.routeSettings.positionedStations[v].p;
            p.visual.highlightShown = false;
            p.visual.highlightColor = Canvas.Colors.highlight;
          }
        },
        "mousemove": (event, attributes, selInfo) => {
          if(attributes.highlightedV){
            if(Version.current.routeSettings.positionedStations[attributes.highlightedV.origStation.contractParent.id]){
              attributes.highlightedV.p.visual.highlightShown = true;
              attributes.highlightedV.p.visual.highlightColor = Canvas.Colors.highlight2;
            }else{
              attributes.highlightedV.p.visual.highlightShown = false;
              attributes.highlightedV.p.visual.highlightColor = Canvas.Colors.highlight;
            }
          }
          attributes.highlightedV = Util.nearestTokens(Version.current, event, Version.current.routeSettings.positionedStations, v => v.p, () => true, false).tokens[0];
          if(attributes.highlightedV && Canvas.pixelDistPToMouse(attributes.highlightedV.p, event) < 25){
            attributes.highlightedV.p.visual.highlightShown = true;
            attributes.highlightedV.p.visual.highlightColor = Canvas.Colors.highlight;
          }
        },
        "click": (event, attributes, selInfo) => {
          if(attributes.highlightedV){
            let sT = Date.now();
            delete Version.current.routeSettings.positionedStations[attributes.highlightedV.origStation.contractParent.id]; //TODO sometimes youi cant remove the last one - maybe do sth with contractParent in unsettle?
            attributes.highlightedV.p.visual.highlightShown = false;
            attributes.highlightedV.p.visual.highlightColor = Canvas.Colors.highlight;
            MetroMap.Routing.recalcAll();
            MetroMap.Post.updateTimeOut(Version.current, true, Date.now()-sT);
            Version.edited("Freed Station");
            attributes.highlightedV = null;
          }
        }
      }},
      "straightenEdgeGC": {id: "straightenEdgeGC", label: "Straighten Edge", sm: {mode: "edgeConnected", gType: "gridG", selState: null}, suggCBs: {"cbShowCG": true, "cbShowResult": true}, attributes: {}, events: {
        "select": (event, attributes, selInfo) => {
          if(!Version.current.results.resultDijkstras || Version.current.results.resultDijkstras.length == 0) MetroMap.Routing.recalcAll(Version.current);
        },
        "keydown": (event, attributes, selInfo) => {
          if(event.key == "Enter" && selInfo.selection.length > 0){
            let sT = Date.now();
            // let prevC = MetroMap.Post.recalcCost(Version.current);
            if(selInfo.selection.length == 1){
              Version.current.routeSettings.straightEdges.push(selInfo.selection[0].chain);
            }else{
              let vColl = {};
              let eArr = [];
              let endPoints = [];
              for(let e of selInfo.selection){
                if(selInfo.selection.every(e2 => e2 == e || (e2.s != e.s && e2.t != e.s))) endPoints.push(e.s);
                if(selInfo.selection.every(e2 => e2 == e || (e2.s != e.t && e2.t != e.t))) endPoints.push(e.t);
                for(let e2 of e.chain){
                  vColl[e2.s.id] = e2.s;
                  vColl[e2.t.id] = e2.t;
                  eArr.push(e2);
                }
              }
              delete vColl[endPoints[0].contractParent.id];
              delete vColl[endPoints[1].contractParent.id];
              let vUpdate = [];
              for(let v in vColl){
                v = vColl[v];
                let ca = Version.current.routeSettings.contractAllowed[v.id]; 
                if(ca == 2){
                  console.log("didn't straighten that because you included non-contractable stations");
                  return;
                }else if(ca == 3){
                  vUpdate.push(v.id);
                }
              }
              
              for(let v of vUpdate) Version.current.routeSettings.contractAllowed[v] = 1;
              if(!vUpdate.length > 0) console.log("Overwrote some decisions about contracting stations");
              // MetroMap.Routing.recalcCG(Version.current);
              Version.current.routeSettings.straightEdges.push(eArr);
            }
            MetroMap.Routing.recalcAll();
            MetroMap.Post.updateTimeOut(Version.current, true, Date.now()-sT);
            Version.edited("Straightened " + Version.current.routeSettings.straightEdges[Version.current.routeSettings.straightEdges.length-1].length + "-Edge Sequence");

            Tool.selectionModes[Tool.allTools[Tool.currentToolID].sm.mode].changeSelection([], Tool.allTools[Tool.currentToolID].sm.gType, Tool.allTools[Tool.currentToolID].sm.selState);

            // let newC = MetroMap.Post.recalcCost(Version.current);
            // MetroMap.Post.updateTimeOut(Version.current, success, Date.now()-sT, newC, newC-prevC);
            // Version.edited("GC Straigtened " + selInfo.selection.length + " Edge(s)");
          }
        }
      }},
      "dontStraighten": {id: "dontStraighten", label: "Unstraighten", sm: {mode: "none", gType: "", selState: null}, suggCBs: {"cbShowMG": false, "cbShowCG": false, "cbShowResult": true}, attributes: {highlightedE: null}, events: {
        "select": (event, attributes, selInfo) => {
          for(let e in Version.current.graphs.cG.edges){
            e = Version.current.graphs.cG.edges[e];
            if(Version.current.routeSettings.straightEdges.some(se => se.length == e.chain.length && se.every(e2 => e.chain.includes(e2)))){
              for(let e2 of e.edgePath){
                e2.ls.visual.highlightShown = true;
                e2.ls.visual.highlightColor = Canvas.Colors.highlight2;
              }
            }
          }
        },
        "deselect": (event, attributes, selInfo) => {
          for(let e in Version.current.graphs.cG.edges){
            for(let e2 of Version.current.graphs.cG.edges[e].edgePath){
              e2.ls.visual.highlightShown = false;
              e2.ls.visual.highlightColor = Canvas.Colors.highlight;
            }
          }
        },
        "mousemove": (event, attributes, selInfo) => {
          if(attributes.highlightedE){
            if(Version.current.routeSettings.straightEdges.some(se => se.length == attributes.highlightedE.chain.length && se.every(e2 => attributes.highlightedE.chain.includes(e2)))){
              for(let e2 of attributes.highlightedE.edgePath) e2.ls.visual.highlightColor = Canvas.Colors.highlight2;
            }else{
              for(let e2 of attributes.highlightedE.edgePath){
                e2.ls.visual.highlightShown = false;
                e2.ls.visual.highlightColor = Canvas.Colors.highlight;
              }
            }
          }
          attributes.highlightedE = Util.nearestTokens(Version.current, event, Version.current.graphs.gridG.edges, e => e.ls, e => Version.current.routeSettings.straightEdges.some(se => se.length == e.chain.length && se.every(e2 => e.chain.includes(e2)))).tokens[0];
          if(attributes.highlightedE && Canvas.pixelDistEToMouse(attributes.highlightedE, event, true) < 25){
            for(let e2 of attributes.highlightedE.edgePath){
              e2.ls.visual.highlightShown = true;
              e2.ls.visual.highlightColor = Canvas.Colors.highlight;
            }
          }
        },
        "click": (event, attributes, selInfo) => {
          if(attributes.highlightedE){
            let i = Version.current.routeSettings.straightEdges.findIndex(se => se.length == attributes.highlightedE.chain.length && se.every(e2 => attributes.highlightedE.chain.includes(e2)));
            let x = Version.current.routeSettings.straightEdges.splice(i, 1)[0];
            for(let v of x) Version.current.routeSettings.contractAllowed[v.id] = 3;
            for(let e2 of attributes.highlightedE.edgePath){
              e2.ls.visual.highlightShown = false;
              e2.ls.visual.highlightColor = Canvas.Colors.highlight;
            }
            MetroMap.Routing.recalcAll();
            MetroMap.Post.updateTimeOut(Version.current, true, Date.now()-sT);
            Version.edited("Unstraightened Edge");
            attributes.highlightedE = null;
          }
        }
      }},
      "freeze": {id: "freeze", label: "Freeze Edges", sm: {mode: "edgeConnected", gType: "gridG", selState: null}, suggCBs: {"cbShowCG": true, "cbShowResult": true}, attributes: {}, events: {
        "select": (event, attributes, selInfo) => {
          if(!Version.current.results.resultDijkstras || Version.current.results.resultDijkstras.length == 0) MetroMap.Routing.recalcAll(Version.current);
        },
        "keydown": (event, attributes, selInfo) => { //prohibit contraction/straighten if frozen
          if(event.key == "Enter" && selInfo.selection.length > 0){
            let sT = Date.now();
            let gid = 0;
            for(let e of selInfo.selection) if(Version.current.routeSettings.frozenEdges[e.id]){
              console.log("Didn't do that because you included already frozen edges") //you could just append to that
              return;
            }
            for(let e in Version.current.routeSettings.frozenEdges) gid = Math.max(gid, Version.current.routeSettings.frozenEdges[e].groupID);
            gid++;
            for(let e of selInfo.selection){
              let btps = [];
              for(let i = 1; i < e.path.length-2; i += 2){
                btps.push(e.path[i].parent.ports.indexOf(e.path[i]));
              }
              Version.current.routeSettings.frozenEdges[e.id] = {groupID: gid, bendToPortSeq: btps, iSTDiff: e.t.gridNode.gridCoords.i-e.s.gridNode.gridCoords.i,  jSTDiff: e.t.gridNode.gridCoords.j-e.s.gridNode.gridCoords.j};
            }
            MetroMap.Routing.recalcAll();//TODO remove
            MetroMap.Post.updateTimeOut(Version.current, true, Date.now()-sT);
            Version.edited("Froze " + selInfo.selection.length + " Edges");
            Tool.selectionModes[Tool.allTools[Tool.currentToolID].sm.mode].changeSelection([], Tool.allTools[Tool.currentToolID].sm.gType, Tool.allTools[Tool.currentToolID].sm.selState);
          }
        }
      }},
      "unfreeze": {id: "unfreeze", label: "Unfreeze", sm: {mode: "none", gType: "", selState: null}, suggCBs: {"cbShowMG": false, "cbShowCG": false, "cbShowResult": true}, attributes: {highlightedEs: []}, events: {
        "select": (event, attributes, selInfo) => {
          for(let e in Version.current.graphs.cG.edges){
            if(Version.current.routeSettings.frozenEdges[e]){
              for(let e2 of Version.current.graphs.cG.edges[e].edgePath){
                e2.ls.visual.highlightShown = true;
                e2.ls.visual.highlightColor = Canvas.Colors.highlight2;
              }
            }
          }
        },
        "deselect": (event, attributes, selInfo) => {
          for(let e of attributes.highlightedEs){
            for(let e2 of e.edgePath){
              e2.ls.visual.highlightShown = false;
              e2.ls.visual.highlightColor = Canvas.Colors.highlight;
            }
          }
        },
        "mousemove": (event, attributes, selInfo) => {
          for(let e of attributes.highlightedEs){
            for(let e2 of e.edgePath){
              e2.ls.visual.highlightColor = Canvas.Colors.highlight2;
            }
          }
          attributes.highlightedEs = [];
          let nt = Util.nearestTokens(Version.current, event, Version.current.graphs.gridG.edges, e => e.ls, e => Version.current.routeSettings.frozenEdges[e.id]).tokens[0];
          if(nt && Canvas.pixelDistEToMouse(nt, event, true) < 25){
            let gid = Version.current.routeSettings.frozenEdges[nt.id].groupID;
            for(let e in Version.current.routeSettings.frozenEdges){
              if(Version.current.routeSettings.frozenEdges[e].groupID == gid){
                attributes.highlightedEs.push(Version.current.graphs.cG.edges[e]);
                for(let e2 of Version.current.graphs.cG.edges[e].edgePath){
                  e2.ls.visual.highlightColor = Canvas.Colors.highlight;
                }
              }
            }
          }
        },
        "click": (event, attributes, selInfo) => {
          if(attributes.highlightedEs.length > 0){
            for(let e of attributes.highlightedEs){
              delete Version.current.routeSettings.frozenEdges[e];
              for(let e2 of e.edgePath){
                e2.ls.visual.highlightShown = false;
                e2.ls.visual.highlightColor = Canvas.Colors.highlight;
              }
            }
            MetroMap.Routing.recalcAll();
            MetroMap.Post.updateTimeOut(Version.current, true, Date.now()-sT);
            Version.edited("Unfroze " + attributes.highlightedEs.length + " Edges");
            attributes.highlightedEs = [];
          }
        }
      }},
      "dontContract": {id: "dontContract", label: "Don't Contract", sm: {mode: "none", gType: "", selState: null}, suggCBs: {"cbShowMG": true, "cbShowCG": true, "cbShowResult": false}, attributes: {highlightedV: null, changed: false}, events: {
        "select": (event, attributes, selInfo) => {
          for(let v in Version.current.graphs.mG.vertices){
            let p = Version.current.graphs.mG.vertices[v].p;
            let ca = Version.current.routeSettings.contractAllowed[v];
            if(ca > 0){
              p.visual.highlightShown = true;
              p.visual.highlightColor = [Canvas.Colors.dcHl1, Canvas.Colors.dcHl2, Canvas.Colors.dcHl3][ca-1];
            }
          }
        },
        "deselect": (event, attributes, selInfo) => {
          if(attributes.highlightedV) attributes.highlightedV.p.visual.highlightShown = false;
          for(let v in Version.current.graphs.mG.vertices){
            let p = Version.current.graphs.mG.vertices[v].p;
            p.visual.highlightShown = false;
            p.visual.highlightColor = Canvas.Colors.highlight;
          }
          if(attributes.changed){
            attributes.changed = false;
            MetroMap.Routing.recalcAll();
            MetroMap.Post.updateTimeOut(Version.current, true, Date.now()-sT);
            Version.edited("Changed Contractable Stations");
          }
        },
        "mousemove": (event, attributes, selInfo) => { //TODO you could allow removal of ca == 2, and change the edge to allow bends
          if(attributes.highlightedV){
            if(Version.current.routeSettings.contractAllowed[attributes.highlightedV.id] == 0){
              attributes.highlightedV.p.visual.highlightShown = false;
              attributes.highlightedV.p.visual.highlightColor = Canvas.Colors.highlight;
            }else{
              attributes.highlightedV.p.visual.highlightShown = true;
              attributes.highlightedV.p.visual.highlightColor = Canvas.Colors.dcHl3;
            }
          }
          attributes.highlightedV = Util.nearestTokens(Version.current, event, Version.current.graphs.mG.vertices, v => v.p, v => [0, 3].includes(Version.current.routeSettings.contractAllowed[v.id])).tokens[0];
          if(attributes.highlightedV && Canvas.pixelDistPToMouse(attributes.highlightedV.p, event) < 25){
            attributes.highlightedV.p.visual.highlightShown = true;
            attributes.highlightedV.p.visual.highlightColor = Canvas.Colors.highlight;
          }
        },
        "click": (event, attributes, selInfo) => {
          attributes.changed = true;
          if(attributes.highlightedV){
            if(Version.current.routeSettings.contractAllowed[attributes.highlightedV.id] == 0){
              Version.current.routeSettings.contractAllowed[attributes.highlightedV.id] = 3;
            }else{
              Version.current.routeSettings.contractAllowed[attributes.highlightedV.id] = 0;
            }
          }
        },
        "keydown": (event, attributes, selInfo) => {
          if(event.key == "Enter" && attributes.changed){
            attributes.changed = false;
            MetroMap.Routing.recalcAll();
            MetroMap.Post.updateTimeOut(Version.current, true, Date.now()-sT);
            Version.edited("Changed Contractable Stations");

          }
        }
      }},
      "straightenEdge": {id: "straightenEdge", label: "Straighten Edge 2 (unsupported)", sm: {mode: "none", gType: "", selState: null}, suggCBs: {}, attributes: {selE: null}, events: {
        "select": (event, attributes, selInfo) => {
          if(!Version.current.results.resultDijkstras || Version.current.results.resultDijkstras.length == 0) MetroMap.Routing.recalcAll(Version.current);
        },
        "deselect": (event, attributes, selInfo) => {
          if(attributes.selE) for(let e of attributes.selE.edgePath) e.ls.visual.highlightShown = false;
          Canvas.redraw();
        },
        "mousemove": (event, attributes, selInfo) => {
          if(attributes.selE) for(let e of attributes.selE.edgePath) e.ls.visual.highlightShown = false;
          let g = Version.current.graphs.gridG;
          // let minE = Util.nearestTokens(Version.current, event, g.edges, e => Util.nearestTokens(Version.current, event, e.edgePath, e2 => e2.ls).tokens[0].ls).tokens[0];
          let minE = Util.nearestTokens(Version.current, event, Version.current.graphs.gridG.edges, e => e.ls).tokens[0];
          for(let e of minE.edgePath) e.ls.visual.highlightShown = true;
          attributes.selE = minE;
          Canvas.redraw();
        },
        "click": (event, attributes, selInfo) => {
          if(!attributes.selE) Tool.allTools[Tool.currentToolID].events["mousemove"](event, attributes, selInfo);
          sT = Date.now();
          let maxOffset = 2;
          let prevC = MetroMap.Post.recalcCost(Version.current);
          let e = attributes.selE;
          for(let e2 of e.edgePath) e2.ls.visual.highlightShown = false;
          let origSID = e.s.gridNode.id;
          let origTID = e.t.gridNode.id;
          MetroMap.Routing.unsettleVtx(e.s);
          MetroMap.Routing.unsettleVtx(e.t);
          let s0 = MetroMap.Routing.findClosestGridNode(Version.current, e.s);
          s0.settleable = false;
          let t0 = MetroMap.Routing.findClosestGridNode(Version.current, e.t);
          s0.settleable = true;
          let sDim = {t: Math.max(s0.gridCoords.j-maxOffset, 0), r: Math.min(s0.gridCoords.i+maxOffset, Version.current.graphs.gridG.gridNodes.length-1), b: Math.min(s0.gridCoords.j+maxOffset, Version.current.graphs.gridG.gridNodes[0].length-1), l: Math.max(s0.gridCoords.i-maxOffset, 0)};
          let tDim = {t: Math.max(t0.gridCoords.j-maxOffset, 0), r: Math.min(t0.gridCoords.i+maxOffset, Version.current.graphs.gridG.gridNodes.length-1), b: Math.min(t0.gridCoords.j+maxOffset, Version.current.graphs.gridG.gridNodes[0].length-1), l: Math.max(t0.gridCoords.i-maxOffset, 0)};
          let isec = {};
          let S = [];
          let T = [];
          if(sDim.r >= tDim.r && sDim.l <= tDim.r) isec.iRange = [Math.max(sDim.l, tDim.l), tDim.r];
          else if(sDim.r >= tDim.l && sDim.l <= tDim.l) isec.iRange = [tDim.l, Math.min(sDim.r, tDim.r)];
          if(sDim.b >= tDim.b && sDim.t <= tDim.b) isec.jRange = [Math.max(sDim.t, tDim.t), tDim.b];
          else if(sDim.b >= tDim.t && sDim.t <= tDim.t) isec.jRange = [tDim.t, Math.min(sDim.b, tDim.b)];
          if(sDim.b+sDim.r >= tDim.b+tDim.r && sDim.t+sDim.l <= tDim.b+tDim.r) isec.kRange = [Math.max(sDim.t+sDim.l, tDim.t+tDim.l), tDim.b+tDim.r];
          else if(sDim.b+sDim.r >= tDim.t+tDim.l && sDim.t+sDim.l <= tDim.t+tDim.l) isec.kRange = [tDim.t+tDim.l, Math.min(sDim.b+sDim.r, tDim.b+tDim.r)];
          if(sDim.b-sDim.l >= tDim.b-tDim.l && sDim.t-sDim.r <= tDim.b-tDim.l) isec.lRange = [Math.max(sDim.t-sDim.r, tDim.t-tDim.r), tDim.b-tDim.l];
          else if(sDim.b-sDim.l >= tDim.t-tDim.r && sDim.t-sDim.r <= tDim.t-tDim.r) isec.lRange = [tDim.t-tDim.r, Math.min(sDim.b-sDim.l, tDim.b-tDim.l)];
          for(let i = sDim.l; i <= sDim.r; i++){
            for(let j = sDim.t; j <= sDim.b; j++){
              if(Version.current.graphs.gridG.gridNodes[i][j].settleable && Geometry.distanceBetween(Version.current.graphs.gridG.gridNodes[i][j].p, s0.p) < Geometry.distanceBetween(Version.current.graphs.gridG.gridNodes[i][j].p, t0.p) &&
                (isec.iRange && i >= isec.iRange[0] && i <= isec.iRange[1] ||
                isec.jRange && j >= isec.jRange[0] && j <= isec.jRange[1] ||
                isec.kRange && i+j >= isec.kRange[0] && i+j <= isec.kRange[1] ||
                isec.lRange && j-i >= isec.lRange[0] && j-i <= isec.lRange[1])){
                // Version.current.graphs.gridG.gridNodes[i][j].p.visual.objectShown = true;
                // Version.current.graphs.gridG.gridNodes[i][j].p.visual.objectColor = "lime";
                S.push(Version.current.graphs.gridG.gridNodes[i][j]);
                for(let e2 of Version.current.graphs.gridG.gridNodes[i][j].es) e2.costKeys = ["cs", {a: Version.current.graphs.gridG.gridNodes[i][j].p, b: s0.p}];
              }
            }
          }
          for(let i = tDim.l; i <= tDim.r; i++){
            for(let j = tDim.t; j <= tDim.b; j++){
              if(Version.current.graphs.gridG.gridNodes[i][j].settleable && Geometry.distanceBetween(Version.current.graphs.gridG.gridNodes[i][j].p, s0.p) >= Geometry.distanceBetween(Version.current.graphs.gridG.gridNodes[i][j].p, t0.p) &&
                (isec.iRange && i >= isec.iRange[0] && i <= isec.iRange[1] ||
                isec.jRange && j >= isec.jRange[0] && j <= isec.jRange[1] ||
                isec.kRange && i+j >= isec.kRange[0] && i+j <= isec.kRange[1] ||
                isec.lRange && j-i >= isec.lRange[0] && j-i <= isec.lRange[1])){
                // Version.current.graphs.gridG.gridNodes[i][j].p.visual.objectShown = true;
                // Version.current.graphs.gridG.gridNodes[i][j].p.visual.objectColor = "pink";
                T.push(Version.current.graphs.gridG.gridNodes[i][j]);
                for(let e2 of Version.current.graphs.gridG.gridNodes[i][j].es) e2.costKeys = ["cs", {a: Version.current.graphs.gridG.gridNodes[i][j].p, b: t0.p}];
              }
            }
          }
          let m1, m2;
          if(S.length > T.length){
            m1 = T;
            m2 = S;
          }else{
            m1 = S;
            m2 = T;
          }
          let minC = Number.MAX_SAFE_INTEGER;
          let minConf;
          // m1 = S;
          // m2 = T;
          outer: for(let v of m1){
            MetroMap.Routing.unsettleVtx(e.s);
            MetroMap.Routing.unsettleVtx(e.t);
            let m3 = m2.filter(v2 => v2.gridCoords.i == v.gridCoords.i || v2.gridCoords.j == v.gridCoords.j || v2.gridCoords.i+v2.gridCoords.j == v.gridCoords.i+v.gridCoords.j || v2.gridCoords.j-v2.gridCoords.i == v.gridCoords.j-v.gridCoords.i);          
            Version.current.routeSettings.disallowBends = true;
            let dijkstra = MetroMap.Routing.routeEdgeCleanup(Version.current, MetroMap.Routing.s2sDijkstra(Version.current, [v], m3, Version.current.graphs.gridG), e, [v], m3, false, false, [], [], document.getElementById("cbShowResult").checked);
            if(!dijkstra[0]) continue;
            let p = dijkstra[2][0].ports.indexOf(dijkstra[2][1]);
            for(let i = 3; i < dijkstra[2].length-1; i += 2){
              if(p != dijkstra[2][i].parent.ports.indexOf(dijkstra[2][i])) continue outer;
            }
            Version.current.routeSettings.disallowBends = false;
            for(let e2 of e.s.es){
              if(e2.id == e.id) continue;
              dijkstra = MetroMap.Routing.routeEdge(Version.current, e2);
              if(!dijkstra[0]) continue outer;
            }
            for(let e2 of e.t.es){
              if(e2.id == e.id) continue;
              dijkstra = MetroMap.Routing.routeEdge(Version.current, e2);
              if(!dijkstra[0]) continue outer;
            }
            let newC = MetroMap.Post.recalcCost(Version.current);
            if(newC < minC){
              minC = newC;
              minConf = {s: v, T: m3};
            }
          }
          // m2 = S;
          // m1 = T;
          // outer: for(let v of m1){
          //   MetroMap.Routing.unsettleVtx(e.s);
          //   MetroMap.Routing.unsettleVtx(e.t);
          //   let m3 = m2.filter(v2 => v2.gridCoords.i == v.gridCoords.i || v2.gridCoords.j == v.gridCoords.j || v2.gridCoords.i+v2.gridCoords.j == v.gridCoords.i+v.gridCoords.j || v2.gridCoords.j-v2.gridCoords.i == v.gridCoords.j-v.gridCoords.i);
            
          //   if(v.id == origSID) for(let v2 of m3) v2.p.visual.highlightShown = true
          //   let dijkstra = MetroMap.Routing.routeEdgeCleanup(MetroMap.Routing.s2sDijkstra([v], m3, Version.current.graphs.gridG), e, [v], m3, Version.current.graphs.gridG, false, false, [], [], document.getElementById("cbShowResult").checked);
          //   if(!dijkstra[0]) continue;
          //   let p = dijkstra[2][0].ports.indexOf(dijkstra[2][1]);
          //   for(let i = 3; i < dijkstra[2].length-1; i += 2){
          //     if(p != dijkstra[2][i].parent.ports.indexOf(dijkstra[2][i])) continue outer;
          //   }
          //   for(let e2 of e.s.es){
          //     if(e2.id == e.id) continue;
          //     dijkstra = routeEdge(e2, Version.current.graphs.cG, Version.current.graphs.gridG);
          //     if(!dijkstra[0]) continue outer;
          //   }
          //   for(let e2 of e.t.es){
          //     if(e2.id == e.id) continue;
          //     dijkstra = routeEdge(e2, Version.current.graphs.cG, Version.current.graphs.gridG);
          //     if(!dijkstra[0]) continue outer;
          //   }
          //   let newC = MetroMap.Post.recalcCost(Version.current);
          //   console.log(newC)
          //   if(newC < minC){
          //     minC = newC;
          //     minConf = {s: v, T: m3};
          //   }
          // }
          MetroMap.Routing.unsettleVtx(e.s);
          MetroMap.Routing.unsettleVtx(e.t);
          let success = minC < Number.MAX_SAFE_INTEGER;
          let newDijkstras = [];
          if(success){
            Version.current.routeSettings.disallowBends = true;
            newDijkstras.push(MetroMap.Routing.routeEdgeCleanup(Version.current, MetroMap.Routing.s2sDijkstra(Version.current, [minConf.s], minConf.T, Version.current.graphs.gridG), e, [minConf.s], minConf.T, false, false, [], [], document.getElementById("cbShowResult").checked));
          }
          Version.current.routeSettings.disallowBends = false;
          for(let e2 of e.s.es){
            if(success && e2.id == e.id) continue;
            newDijkstras.push(MetroMap.Routing.routeEdge(Version.current, e2));
          }
          for(let e2 of e.t.es){
            if(e2.id == e.id) continue;
            newDijkstras.push(MetroMap.Routing.routeEdge(Version.current, e2));
          }
          MetroMap.Post.updateDijkstras(Version.current, newDijkstras);
          attributes.selE = null;
          // for(let v of S) v.p.visual.objectShown = true
          // for(let v of T) v.p.visual.objectShown = true
          Canvas.redraw();
          if(!success) minC = MetroMap.Post.recalcCost(Version.current);
          // document.getElementById("timeOut").innerText = (success?"Finished in ":"Failed in ") + (Date.now()-sT) + "ms with cost " + minC + " (worse by " + (Math.round((minC-prevC)*100)/100) + ")";
          MetroMap.Post.updateTimeOut(Version.current, success, Date.now()-sT, minC, minC-prevC);
          Version.edited("Straigtened Edge " + e.id);
        }
      }},
      "adjustOrder": {id: "adjustOrder", label: "Adjust Order (unsupported)", sm: {mode: "none", gType: "", selState: null}, suggCBs: {}, attributes: {highlightedE: null}, events: {
        "select": (event, attributes, selInfo) => {
          Version.current.results.edgeOrder = MetroMap.Routing.getEdgeOrder(Version.current.graphs.cG)[0];
          let s = "";
          for(let e of Version.current.results.edgeOrder){
            s += "<div class='eoEdge' id='eo" + e.id + "'> Edge " + e.id + "</div>";
          }
          document.getElementById("edgeOrder").innerHTML = s;
          for(let e of Array.from(document.getElementsByClassName("eoEdge"))){
            e.onmouseover = event => {
              let g = Version.current.graphs.cG;
              if(attributes.highlightedE){
                attributes.highlightedE.ls.visual.highlightShown = false;
                document.getElementById("eo" + attributes.highlightedE.id).style.backgroundColor = "";
              }
              attributes.highlightedE = g.edges[event.srcElement.id.substr(2)];
              attributes.highlightedE.ls.visual.highlightShown = true;
              event.srcElement.style.backgroundColor = attributes.highlightedE.ls.visual.highlightColor;
              Canvas.redraw();
            };
          }
        },
        "deselect": (event, attributes, selInfo) => {
          document.getElementById("edgeOrder").innerHTML = "";
          if(attributes.highlightedE) attributes.highlightedE.ls.visual.highlightShown = false;
        },
        "mousemove": (event, attributes, selInfo) => {
          let g = Version.current.graphs.cG;
          let minE = Util.nearestTokens(Version.current, event, g.edges, e => e.ls).tokens[0];
          if(attributes.highlightedE){
            attributes.highlightedE.ls.visual.highlightShown = false;
            document.getElementById("eo" + attributes.highlightedE.id).style.backgroundColor = "";
          }
          attributes.highlightedE = minE;
          minE.ls.visual.highlightShown = true;
          document.getElementById("eo" + minE.id).style.backgroundColor = minE.ls.visual.highlightColor;
          Canvas.redraw();
        },
        "keydown": (event, attributes, selInfo) => {
          event.preventDefault();
          let g = Version.current.graphs.cG;
          if(!attributes.highlightedE || event.keyCode < 37 || event.keyCode > 40) return;
          let oldI = Version.current.results.edgeOrder.indexOf(attributes.highlightedE);
          Version.current.results.edgeOrder.splice(oldI, 1);
          if(event.key == "ArrowUp"){
            Version.current.results.edgeOrder.unshift(attributes.highlightedE);
          }else if(event.key == "ArrowDown"){
            Version.current.results.edgeOrder.push(attributes.highlightedE);
          }else if(event.key == "ArrowLeft"){
            Version.current.results.edgeOrder.splice(Math.max(0, oldI-1), 0, attributes.highlightedE);
          }else if(event.key == "ArrowRight"){
            Version.current.results.edgeOrder.splice(Math.min(Version.current.results.edgeOrder.length, oldI+1), 0, attributes.highlightedE);
          }
          let s = "";
          for(let e of Version.current.results.edgeOrder){
            s += "<div class='eoEdge' id='eo" + e.id + "' " + (e.id == attributes.highlightedE.id ? ("style='background-color: " + attributes.highlightedE.ls.visual.highlightColor + ";'") : "") + "> Edge " + e.id + "</div>";
          }
          document.getElementById("edgeOrder").innerHTML = s;
          for(let e of Array.from(document.getElementsByClassName("eoEdge"))){
            e.onmouseover = event => {
              if(attributes.highlightedE){
                attributes.highlightedE.ls.visual.highlightShown = false;
                document.getElementById("eo" + attributes.highlightedE.id).style.backgroundColor = "";
              }
              attributes.highlightedE = g.edges[event.srcElement.id.substr(2)];
              attributes.highlightedE.ls.visual.highlightShown = true;
              event.srcElement.style.backgroundColor = attributes.highlightedE.ls.visual.highlightColor;
              Canvas.redraw();
            };
          }
          console.log(Version.current.results.edgeOrder);
        }
      }},
      /*"selctStart": {id: "selctStart", label: "Select Start Vtx", sm: {mode: "none", gType: "", selState: null}, suggCBs: {}, attributes: {startVtx: null}, events: {
        "deselect": (event, attributes, selInfo) => {
          if(attributes.startVtx) attributes.startVtx.p.visual.highlightShown = false;
          Canvas.redraw();
        },
        "mousemove": (event, attributes, selInfo) => {
          if(attributes.startVtx) attributes.startVtx.p.visual.highlightShown = false;
          let g = Version.current.graphs.cG;
          attributes.startVtx = Util.nearestTokens(Version.current, event, Version.current.graphs.cG.vertices, v => v.p).tokens[0];
          attributes.startVtx.p.visual.highlightShown = true;
          Canvas.redraw();
        },
        "click": (event, attributes, selInfo) => {
          Tool.allTools[Tool.currentToolID].events["mousemove"](event, attributes, selInfo);
          [Version.current.results.edgeOrder, Version.current.results.vertexOrder] = MetroMap.Routing.getEdgeOrder(Version.current.graphs.mG, attributes.startVtx);
          MetroMap.Routing.recalcAll(Version.current);
          Version.edited("Changed Start Position");
        }
      }}*/
      // "snap": {id: "snap", label: "Snapshot", sm: {mode: "none", gType: "", selState: null}, suggCBs: {}, attributes: {clicking: false, ls: []}, events: {
      //   "select": (event, attributes, selInfo) => {
      //     for(let i = 0; i < 4; i++){
      //       attributes.ls.push(Geometry.objTypes.LineSegment.constr(Version.current, 0, 0, 0, 0));
      //       attributes.ls[i].visual.objectColor = "grey";
      //     }
      //   },
      //   "deselect": (event, attributes, selInfo) => {
      //     for(let i = 0; i < 4; i++) Geometry.removeGeoObject(Version.current, attributes.ls[i]);
      //     attributes.ls = [];
      //   },
      //   "mousemove": (event, attributes, selInfo) => {
      //     let ls = attributes.ls;
      //     if(attributes.clicking){
      //       let c = Canvas.mouseCoords(event);
      //       ls[2].s.x = c.x;
      //       ls[2].s.y = c.y;
      //       ls[1].t.x = c.x;
      //       ls[1].t.y = c.y;
      //       ls[2].t.y = c.y;
      //       ls[3].s.y = c.y;
      //       ls[0].t.x = c.x;
      //       ls[1].s.x = c.x;
      //       Canvas.redraw();
      //     }
      //   }, 
      //   "mousedown": (event, attributes, selInfo) => {
      //     let ls = attributes.ls;
      //     attributes.clicking = true;
      //     let c = Canvas.mouseCoords(event);
      //     ls[0].s.x = c.x;
      //     ls[0].s.y = c.y;
      //     ls[3].t.x = c.x;
      //     ls[3].t.y = c.y;
      //     ls[0].t.y = c.y;
      //     ls[1].s.y = c.y;
      //     ls[2].t.x = c.x;
      //     ls[3].s.x = c.x;
      //   }, 
      //   "mouseup": (event, attributes, selInfo) => {
      //     attributes.clicking = false;
      //     let ls = attributes.ls;
      //     let tl = Canvas.coordsToPixel(Math.min(ls[0].s.x, ls[1].s.x), Math.min(ls[0].s.y, ls[3].s.y));
      //     let br = Canvas.coordsToPixel(Math.max(ls[0].s.x, ls[1].s.x), Math.max(ls[0].s.y, ls[3].s.y));
      //     let r = [tl.x, tl.y, br.x-tl.x, br.y-tl.y];
      //     console.log("'test': '" + Util.serializeVer({region: r, rs: Version.current.routeSettings, vp: Canvas.viewport, loc: MetroMap.location, cb: Version.current.checkBoxes, hle: Writing.hlImageE, hlv: Writing.hlImageV, hlCGV: Writing.hlCGV}, true) + "',\n\t\t\t\t")
      //   }
      // }},
      // "highlight": {id: "highlight", label: "Highlight Edge", sm: {mode: "none", gType: "", selState: null}, suggCBs: {}, attributes: {minOs: []}, events: {
      //   "select": (event, attributes, selInfo) => {
      //     for(let o of Writing.hlImageE) for(let e2 of Version.current.graphs.cG.edges[o].edgePath) e2.ls.visual.highlightShown = true;
      //     Canvas.redraw();
      //   }, 
      //   "deselect": (event, attributes, selInfo) => {
      //     for(let o of attributes.minOs) for(let e2 of o.edgePath) e2.ls.visual.highlightShown = false;
      //     for(let o of Writing.hlImageE) for(let e2 of Version.current.graphs.cG.edges[o].edgePath) e2.ls.visual.highlightShown = false;
      //     Canvas.redraw();
      //   }, 
      //   "mousemove": (event, attributes, selInfo) => {
      //     let nt = Util.nearestTokens(Version.current, event, Version.current.graphs.gridG.edges, e => e.ls, e => e.ls.visual.objectShown).tokens[0];
      //     for(let o of attributes.minOs) for(let e2 of o.edgePath) e2.ls.visual.highlightShown = false;
      //     for(let o of Writing.hlImageE) for(let e2 of Version.current.graphs.cG.edges[o].edgePath) e2.ls.visual.highlightShown = true;
      //     if(nt.edgePath) for(let e2 of nt.edgePath) e2.ls.visual.highlightShown = true;
      //     attributes.minOs = [nt];
      //     Canvas.redraw();
      //   }, 
      //   "click": (event, attributes, selInfo) => {
      //     for(let o of attributes.minOs){
      //       console.log(o)
      //       o = o.id;
      //       if(!Writing.hlImageE.includes(o)) Writing.hlImageE.push(o);
      //       else Writing.hlImageE.splice(Writing.hlImageE.indexOf(o), 1);
      //     }
      //   }
      // }},
      // "highlight2": {id: "highlight2", label: "Highlight Vertex", sm: {mode: "none", gType: "", selState: null}, suggCBs: {}, attributes: {minOs: []}, events: {
      //   "select": (event, attributes, selInfo) => {
      //     if(Writing.hlCGV) for(let o of Writing.hlImageV) Version.current.graphs.cG.vertices[o].p.visual.highlightShown = true;
      //     else for(let o of Writing.hlImageV) Version.current.graphs.cG.vertices[o].gridNode.p.visual.highlightShown = true;
      //     Canvas.redraw();
      //   }, 
      //   "deselect": (event, attributes, selInfo) => {
      //     for(let o of attributes.minOs) o.p.visual.highlightShown = false;
      //     if(Writing.hlCGV) for(let o of Writing.hlImageV) Version.current.graphs.cG.vertices[o].p.visual.highlightShown = false;
      //     else for(let o of Writing.hlImageV) Version.current.graphs.cG.vertices[o].gridNode.p.visual.highlightShown = false;
      //     Canvas.redraw();
      //   }, 
      //   "mousemove": (event, attributes, selInfo) => {
      //     for(let o of attributes.minOs) o.p.visual.highlightShown = false;
      //     if(Writing.hlCGV) for(let o of Writing.hlImageV) Version.current.graphs.cG.vertices[o].p.visual.highlightShown = true;
      //     else for(let o of Writing.hlImageV) Version.current.graphs.cG.vertices[o].gridNode.p.visual.highlightShown = true;
      //     let nt = Util.nearestTokens(Version.current, event, Version.current.graphs.gridG.vertices, v => v.p, v => v.p.visual.objectShown).tokens[0];
      //     if(!nt){
      //       nt = Util.nearestTokens(Version.current, event, Version.current.graphs.cG.vertices, v => v.p, v => v.p.visual.objectShown).tokens[0];
      //       Writing.hlCGV = true;
      //     }
      //     nt.p.visual.highlightShown = true;
      //     attributes.minOs = [nt];
      //     Canvas.redraw();
      //   }, 
      //   "click": (event, attributes, selInfo) => {
      //     for(let o of attributes.minOs){
      //       if(Writing.hlCGV) o = o.id;
      //       else o = o.origStation.id;
      //       if(!Writing.hlImageV.includes(o)) Writing.hlImageV.push(o);
      //       else Writing.hlImageV.splice(Writing.hlImageV.indexOf(o), 1);
      //     }
      //   }
      // }},
    },
    updateCurrentTool: (loaded = false) => {
      let radios = document.getElementsByName('toolBox');
      let toolID = "";
      for(let i = 0, length = radios.length; i < length; i++){
        if (radios[i].checked) {
          toolID = radios[i].id;
          break;
        }
      }
      if(loaded){

      }
      Tool.handleEvent({type: "deselect"});
      Tool.allTools[Tool.currentToolID].sm.selState = null;
      Tool.currentToolID = toolID;
      let ct = Tool.allTools[Tool.currentToolID];
      ct.sm.selState = Tool.selectionModes[ct.sm.mode].initState();
      for(let cb in ct.suggCBs){
        Version.current.checkBoxes[cb] = ct.suggCBs[cb];
        document.getElementById(cb).checked = ct.suggCBs[cb];
      }
      Util.updateObjectsShown();
      Tool.handleEvent({type: "select"});
      document.getElementById("canvas").focus();
      Version.current.currentToolID = toolID;
    },
    handleEvent: (event) => {
      try{
        let ct = Tool.allTools[Tool.currentToolID];
        if(Tool.selectionModes[ct.sm.mode][event.type]){
          let sel = Tool.selectionModes[ct.sm.mode][event.type](event, ct.sm.gType, ct.sm.selState);
          ct.sm.selState = sel.selState;
          if(!sel.consume && ct.events[event.type]) ct.events[event.type](event, Tool.allTools[Tool.currentToolID].attributes, sel.selInfo);
        }else if(ct.events[event.type]) ct.events[event.type](event, Tool.allTools[Tool.currentToolID].attributes, null);
        else Tool.defaultBehavior[event.type](event);
        Canvas.redraw();
      }catch(error){
        Tool.allTools[Tool.currentToolID].sm.selState = Tool.selectionModes[Tool.allTools[Tool.currentToolID].sm.mode].initState();
      }
    },
    setup: () => {
      document.getElementById("canvas").addEventListener("click", Tool.handleEvent);
      document.getElementById("canvas").addEventListener("mousedown", Tool.handleEvent);
      document.getElementById("canvas").addEventListener("mousemove", Tool.handleEvent);
      document.getElementById("canvas").addEventListener("mouseup", Tool.handleEvent);
      document.getElementById("canvas").addEventListener("keydown", Tool.handleEvent);
      document.getElementById("canvas").addEventListener("keyup", Tool.handleEvent);
      document.getElementById("canvas").addEventListener("wheel", Tool.handleEvent);
      document.getElementById("canvas").addEventListener("mouseleave", Tool.handleEvent);
      document.getElementById("canvas").addEventListener("mouseenter", Tool.handleEvent);
      document.onresize = event => {
        document.documentElement.style.setProperty('--smallImg-left', (Canvas.elem.getBoundingClientRect().left-718) + "px");
      }
      document.documentElement.style.setProperty('--smallImg-left', (Canvas.elem.getBoundingClientRect().left-718) + "px");
      
      let tB = document.getElementById("toolBox");
      tB.innerHTML = "";
      for(let t in Tool.allTools){
        t = Tool.allTools[t];
        tB.innerHTML += '<div class="toolBoxElem' + (["straightenEdge", "adjustOrder"].includes(t.id) ? " legacyTool" : "") + '"><input type="radio" id="' + t.id + '" name="toolBox" checked=false><label for="' + t.id + '">' + t.label + '</label><br></div>';
      }
      // tB.innerHTML += '<div><button onclick="MetroMap.Routing.recalcAll(null)">Recalc All</button><button onclick="MetroMap.Post.localSearchStep()">Search Step</button><button onclick="MetroMap.Post.localSearchStepAll()">Search Step All</button><button onclick="Version.alternative(Version.history[0][0], 'Alt', 'localSearchAll')">Test</button><button onclick="Writing.makeColoredTable()">Writing</button></div>'';
      tB.innerHTML += '';
      document.getElementById(Tool.currentToolID).checked = true;
      Tool.updateCurrentTool();
    }
  };

  var Util = {
    Graph: {
      constr: (ver, type) => {
        return {verID: ver.versionIndex, type: type, objType: "Graph", vertices: {}, edges: {}, vIDCounter: 0, eIDCounter: 0};
      },
      addVertex: (g, id) => {
        if(id) g.vIDCounter = id;
        let v = Util.Vertex.constr(Version.store[g.verID], g.type, g.vIDCounter);
        g.vertices[g.vIDCounter] = v;
        g.vIDCounter++;
        return v;
      },
      removeVertex: (g, v) => {
        delete g.vertices[v.id];
        while(v.es.length > 0){
          Util.Graph.removeEdge(g, v.es[0]);
        }
        if(v.p){
          v.p.visual.objectShown = false;
          v.p.visual.highlightShown = false;
          // Geometry.removeGeoObject(Version.store[g.verID], v.p);
        }
      },
      addEdge(g, sID, tID, cost){
        if(!g.vertices[sID] || !g.vertices[tID]) console.error("Vtx ID " + sID + " or " + tID + "doesn't exist!");
        let e = Util.Edge.constr(Version.store[g.verID], g.eIDCounter, g.vertices[sID], g.vertices[tID], g.type);
        if(cost) console.error("no more costs")
        g.edges[g.eIDCounter] = e;
        g.eIDCounter++;
        return e;
      },
      removeEdge: (g, e) => {
        delete g.edges[e.id];
        let ind = e.s.es.indexOf(e);
        if (ind > -1) e.s.es.splice(ind, 1);
        ind = e.t.es.indexOf(e);
        if (ind > -1) e.t.es.splice(ind, 1);
        if(e.ls){
          e.ls.visual.objectShown = false;
          e.ls.visual.highlightShown = false;
          // Geometry.removeGeoObject(Version.store[g.verID], e.ls);
        }
      },
      removeAll: (g) => {
        for(let v in g.vertices){
          Util.Graph.removeVertex(g, g.vertices[v]);
        }
      },
      dupe: (g, ver) => {
        let g2 = Util.Graph.constr(ver, g.type);
        for(let v in g.vertices){
          g2.vertices[v] = Util.Vertex.dupe(g.vertices[v], ver);
        }
        for(let e in g.edges){
          let e2 = Util.Edge.constr(ver, e, g2.vertices[g.edges[e].s.id], g2.vertices[g.edges[e].t.id], g.type);
          g2.edges[e] = e2;
          if(g.edges[e].ls) e2.ls = ver.objectStore.objects[g.edges[e].ls.id];
          if(g.edges[e].costKeys){
            e2.costKeys = [];
            for(let ck of g.edges[e].costKeys){
              if(ck.a){
                e2.costKeys.push({a: ver.objectStore.objects[ck.a.id], b: ver.objectStore.objects[ck.b.id], l: ck.l});
              }else e2.costKeys.push(ck);
            }
          }
          if(g.edges[e].lines){
            e2.lines = [];
            for(let l of g.edges[e].lines) e2.lines.push(l);
          }
          let others = Util.cloneDict(ver, g.edges[e], ["verID", "id", "s", "t", "ls", "lb", "costKeys", "origEdge", "lines", "edgePath", "path", "blockedDiagonals", "chain"]);
          for(let x in others) e2[x] = others[x];
        }
        for(let v in g.vertices){
          if(g.vertices[v].ports){
            g2.vertices[v].ports = [];
            for(let p of g.vertices[v].ports) g2.vertices[v].ports.push(g2.vertices[p.id]);
          }
          if(g.vertices[v].dijkstra){
            g2.vertices[v].dijkstra = {};
            if(g.vertices[v].dijkstra.p) g2.vertices[v].dijkstra.p = g2.vertices[g.vertices[v].dijkstra.p.id];
            if(g.vertices[v].dijkstra.pe) g2.vertices[v].dijkstra.pe = g2.edges[g.vertices[v].dijkstra.pe.id];
            let others = Util.cloneDict(ver, g.vertices[v].dijkstra, ["p", "pe"]);
            for(let x in others) g.vertices[v].dijkstra[x] = others[x];
          }
          if(g.vertices[v].parent){
            g2.vertices[v].parent = g2.vertices[g.vertices[v].parent.id];
          }
        }
        if(g.gridNodes){
          g2.gridNodes = [];
          for(let i = 0; i < g.gridNodes.length; i++){
            g2.gridNodes.push([]);
            for(let j = 0; j < g.gridNodes[i].length; j++){
              g2.gridNodes[i].push(g2.vertices[g.gridNodes[i][j].id]);
            }
          }
          g2.simpleVis = [];
          for(let ls of g.simpleVis) g2.simpleVis.push(ver.objectStore.objects[ls.id]);
        }
        let others = Util.cloneDict(ver, g, ["verID", "vertices", "edges", "gridNodes", "simpleVis", "s2sDijkstraIDSortedVtcs"]);
        for(let x in others) g2[x] = others[x];
        return g2;
      }
    },
    Vertex: {
      constr: (ver, gType, id) => {
        return {verID: ver.versionIndex, objType: "Vertex", gType: gType, id: id, es: []};
      },
      addEdge: (v, e) => {
        v.es.push(e);
      },
      dupe: (v, ver) => {
        let v2 = Util.Vertex.constr(ver, v.gType, v.id);
        if(v.p) v2.p = ver.objectStore.objects[v.p.id];
        let others = Util.cloneDict(ver, v, ["verID", "gType", "id", "es", "p", "ports", "parent", "origStation", "station", "dijkstra", "gridNode", "contract", "contractParent"]);
        for(let x in others) v2[x] = others[x];
        return v2;
      }
    },
    Edge: {
      constr: (ver, id, s, t, gType) => {
        let e = {verID: ver.versionIndex, objType: "Edge", id: id, s: s, t: t, gType: gType, occupiedStatus: 0, occupiedStatusDict: {}};
        //occupiedStatus -1 is temp open, 0 is use cost, 1 is sink/bend closed, 2 is actually in use (or diag), 3 sink temp closed to preserve embedding
        Util.Vertex.addEdge(s, e);
        Util.Vertex.addEdge(t, e);
        return e;
      },
      v2: (e, v) => {
        if(v.id == e.s.id) return e.t;
        if(v.id == e.t.id) return e.s;
        console.error("tried to get edge partner of a vtx not on the edge")
        return false;
      },
      calcCost: (e) => {
        let ver = Version.store[e.verID];
        let c = 0;
        for(let ck of e.costKeys){
          if(!ck) console.error("unknown cost key", ck, e)
          if(ck.a && ck.b) c += Geometry.distanceBetween(ck.a, ck.b)*(ver.costs.ch+ver.costs.cm)/ver.graphs.gridG.D;
          else if(ver.costs[ck]) c += ver.costs[ck];
          else console.error("unknown cost key", ck, e)
        }
        return c;
      }
    },
    export: () => {
      window.prompt("Copy this string:", Util.serializeVer({rs: Version.current.routeSettings, loc: MetroMap.location, cb: Version.current.checkBoxes, costs: Version.current.costs}, true));
    },
    import: () => {
      let s = window.prompt("Enter the exported string");
      let x = Util.deserializeVer(s, 0, true);
      MetroMap.GraphCreation.loadLocation({value: x.loc});
        setTimeout(() => {
          x = Util.deserializeVer(s, 0, true);
          Version.current.routeSettings = x.rs;
          for(let c of [["GridResIn", "gr"], ["45CostIn", "c45"], ["90CostIn", "c90"], ["135CostIn", "c135"], ["180CostIn", "c180"], ["MoveCostIn", "cm"], ["SinkCostIn", "cs"], ["HopCostIn", "ch"], ["CompressionCostIn", "cc"], ["CandidateRadiusIn", "candidateRadius"], ["LivePreviewRangeIn", "livePreviewRange"]]) 
            document.getElementById(c[0]).innerText = x.costs[c[1]];
          for(let cb in x.cb) document.getElementById(cb).checked = x.cb[cb];
          Util.updateObjectsShown();
          MetroMap.Routing.recalcAll(Version.current);
          Canvas.redraw();
        }, 500);
    },
    updateCosts: () => {
      let costs = Version.current.costs;
      let vals = [["GridResIn", "gr"], ["45CostIn", "c45"], ["90CostIn", "c90"], ["135CostIn", "c135"], ["180CostIn", "c180"], ["MoveCostIn", "cm"], ["SinkCostIn", "cs"], ["HopCostIn", "ch"], ["CompressionCostIn", "cc"], ["CandidateRadiusIn", "candidateRadius"], ["LivePreviewRangeIn", "livePreviewRange"]];
      for(let val of vals){
        let x = document.getElementById(val[0]).innerText;
        if(x == "" || isNaN(x) || x < 0) document.getElementById(val[0]).style.color = "red";
        else{
          document.getElementById(val[0]).style.color = "black";
          if(val != "gr") costs[val[1]] = x - 0;
        }
      }
      if(2*costs.c135 < costs.c90){
        document.getElementById("90CostIn").style.color = "orange";
        document.getElementById("135CostIn").style.color = "orange";
      }
      if(costs.c180+costs.c135 < costs.c45){
        document.getElementById("45CostIn").style.color = "orange";
        document.getElementById("135CostIn").style.color = "orange";
        document.getElementById("180CostIn").style.color = "orange";
      }
      if(costs.c180 > costs.c135){
        document.getElementById("180CostIn").style.color = "orange";
        document.getElementById("135CostIn").style.color = "orange";
      }
      if(costs.c135 > costs.c90){
        document.getElementById("135CostIn").style.color = "orange";
        document.getElementById("90CostIn").style.color = "orange";
      }
      if(costs.c90 > costs.c45){
        document.getElementById("90CostIn").style.color = "orange";
        document.getElementById("45CostIn").style.color = "orange";
      }
      for(let c of ["45", "90", "135", "180"]){
        if(2*costs.cs <= costs["c"+c]){
          document.getElementById(c+"CostIn").style.color = "orange";
          document.getElementById("SinkCostIn").style.color = "orange";
        }
      }
      // costs.c45 = document.getElementById("45CostIn").innerText - 0;
      // costs.c90 = document.getElementById("90CostIn").innerText - 0;
      // costs.c135 = document.getElementById("135CostIn").innerText - 0;
      // costs.c180 = document.getElementById("180CostIn").innerText - 0;
      // costs.cm = document.getElementById("MoveCostIn").innerText - 0;
      // costs.cs = document.getElementById("SinkCostIn").innerText - 0;
      // costs.ch = document.getElementById("HopCostIn").innerText - 0;
      // costs.candidateRadius = document.getElementById("CandidateRadiusIn").innerText - 0;
      // costs.livePreviewRange = document.getElementById("LivePreviewRangeIn").innerText - 0;
    },
    updateObjectsShown: () => {
      let ver = Version.current;
      for(let cb in ver.checkBoxes) ver.checkBoxes[cb] = document.getElementById(cb).checked;
      if(ver.graphs.mG){
        for(let v in ver.graphs.mG.vertices){
          ver.graphs.mG.vertices[v].p.visual.objectShown = document.getElementById("cbShowMG").checked;
          if(!document.getElementById("cbShowMG").checked) ver.graphs.mG.vertices[v].p.visual.highlightShown = false;
          //if(ver.graphs.mG.vertices[v].ver.graphs.mGToGridConnectors) ver.graphs.mG.vertices[v].ver.graphs.mGToGridConnectors.visual.objectShown = document.getElementById("cbShowMG").checked && (document.getElementById("cbShowResult").checked || document.getElementById("cbShowLineDrawing").checked);
        }
        for(let e in ver.graphs.mG.edges){
          ver.graphs.mG.edges[e].ls.visual.objectShown = document.getElementById("cbShowMG").checked;
          if(!document.getElementById("cbShowMG").checked) ver.graphs.mG.edges[e].ls.visual.highlightShown = false;
        }
      }else if(document.getElementById("cbShowMG").checked) console.log("no mg available");
      if(ver.graphs.gridG){
        for(let ls of ver.graphs.gridG.simpleVis){
          ls.visual.objectShown = document.getElementById("cbShowGrid").checked;
        }
      }else if(document.getElementById("cbShowGrid").checked) console.log("no grid available");
      if(ver.graphs.cG){
        for(let v in ver.graphs.cG.vertices) ver.graphs.cG.vertices[v].p.visual.objectShown = document.getElementById("cbShowCG").checked;
        for(let e in ver.graphs.cG.edges) ver.graphs.cG.edges[e].ls.visual.objectShown = document.getElementById("cbShowCG").checked;
      }else if(document.getElementById("cbShowCG").checked) console.log("no contraction available");
      if(ver.results.resultDijkstras){
        for(let d of ver.results.resultDijkstras){
          //for(let v of d[2]) v.p.visual.objectShown = document.getElementById("cbShowResult").checked;
          // d[3][0].s.p.visual.objectShown = document.getElementById("cbShowResult").checked;
          // d[3][0].t.p.visual.objectShown = document.getElementById("cbShowResult").checked;
          // d[3][d[3].length-1].s.p.visual.objectShown = document.getElementById("cbShowResult").checked;
          // d[3][d[3].length-1].t.p.visual.objectShown = document.getElementById("cbShowResult").checked;
          // d[2][0].origStation.p.visual.objectShown = document.getElementById("cbShowResult").checked;
          // d[2][d[2].length-1].origStation.p.visual.objectShown = document.getElementById("cbShowResult").checked;
          d[4].s.gridNode.p.visual.objectShown = document.getElementById("cbShowResult").checked;
          if(!document.getElementById("cbShowResult").checked) d[4].s.gridNode.p.visual.highlightShown = false;
          d[4].t.gridNode.p.visual.objectShown = document.getElementById("cbShowResult").checked;
          if(!document.getElementById("cbShowResult").checked) d[4].t.gridNode.p.visual.highlightShown = false;
          for(let e of d[3]){
            e.ls.visual.objectShown = document.getElementById("cbShowResult").checked;
            if(!document.getElementById("cbShowResult").checked) e.ls.visual.highlightShown = false;
          }
        }
      }else if(document.getElementById("cbShowResult").checked) console.log("no result available");
      if(ver.results.lineDrawing){
        for(let s of ver.results.lineDrawing[0]) s.visual.objectShown = document.getElementById("cbShowLineDrawing").checked;
        for(let lb of ver.results.lineDrawing[1]){
          lb.visual.objectShown = document.getElementById("cbShowLineDrawing").checked;
          if(lb.expandedStations) for(let s of lb.expandedStations) s.visual.objectShown = document.getElementById("cbShowLineDrawing").checked;
        }
      }else if(document.getElementById("cbShowLineDrawing").checked) console.log("no line drawing available");
      Canvas.redraw();
    },
    serializeVer: (ver, useCurrAsVer = false) => {
      let v2 = ver;
      if(useCurrAsVer) ver = Version.current;
      return JSON.stringify(v2, function(k, v){
        if(typeof v === "object" && v !== null && v.objType){
          if(["Point", "LineSegment", "Station", "LineBundle"].includes(v.objType)){
            if(this == ver.objectStore.objects) return v;
            else return "object,"+v.id;
          }else if(v.objType == "Vertex" && (isNaN(k) || (!ver.graphs.mG || this != ver.graphs.mG.vertices) && (!ver.graphs.cG || this != ver.graphs.cG.vertices) && (!ver.graphs.gridG || this != ver.graphs.gridG.vertices)))
            return v.gType+",vertices,"+v.id;
          else if(v.objType == "Edge" && (isNaN(k) || (!ver.graphs.mG || this != ver.graphs.mG.edges) && (!ver.graphs.cG || this != ver.graphs.cG.edges) && (!ver.graphs.gridG || this != ver.graphs.gridG.edges)))
            return v.gType+",edges,"+v.id;
          else return v;
        }else return v;
      });
    },
    deserializeVer: (s, verID, useCurrAsVer = false) => {
      let reinsertObjs = (ver, k, v, p, verID) => {
        if(verID && k == "verID") p[k] = verID;
        if(typeof v === "string"){
          let csv = v.split(",");
          if(csv.length == 2 && csv[0] == "object") p[k] = ver.objectStore.objects[csv[1]];
          else if(csv.length == 3 && ["mG", "cG", "gridG"].includes(csv[0])){
            p[k] = ver.graphs[csv[0]][csv[1]][csv[2]];
            // if(csv[0] == "mG" && csv[1] == "vertices") console.log(v, p[k], ver.graphs[csv[0]])
          }else if(csv.length > 1) console.log(v)
        }else if(typeof v === "object" && v !== null) for(let k2 in v) reinsertObjs(ver, k2, v[k2], v, verID);
      };
      let ver = JSON.parse(s);
      if(useCurrAsVer) reinsertObjs(Version.current, "", ver, null, verID);
      else reinsertObjs(ver, "", ver, null, verID);
      ver.versionIndex = verID;
      return ver;
    },
    cloneDict: (ver, d, exceptions = [], dupeAllowed = false) => {
      let e = {};
      for(let k in d){
        if(exceptions.includes(k)) continue;
        let v = d[k];
        if(typeof v === "object" && v !== null){
          if(v instanceof Array) console.warn("trying to copy array to dict", d, k, v, exceptions);
          else if(dupeAllowed){
            if(v.objType && Util[v.objType] && v.objType != "Edge") v = Util[v.objType].dupe(v, ver);
            else if(v.objType && Geometry.objTypes[v.objType]) Geometry.objTypes[v.objType].dupe(v, ver);
            else if(v.objType != "Edge") console.warn("uhnknown objType...", v.objType, d, k, v);
          }
          // else if(k == "occupiedStatusDict") console.log(v);
          else if(["gridCoords", "occupiedStatusDict", "visual", "objectDimensions", "arrowDimensions", "contract"].includes(k)) v = Util.cloneDict(ver, v);
          else console.warn("cloning Dict with non dupeable object in ", d, k, v);
        }
        e[k] = v;
      }
      return e;
    },
    binarySearch: (x, arr, comp, start, end, verbose = false) => { //returns [boolean: found, number: (potential) index]
      start = Math.max(0, Math.min(start, arr.length-1));
      end = Math.max(0, Math.min(end, arr.length-1));
      if(arr.length == 0) return [false, 0];
      if(start >= end){return [comp(x, arr[start]) == 0, comp(x, arr[start]) > 0 ? start+1 : start];}
      else{
        let mInd = start+Math.floor((end-start)/2);
        let mElem = arr[mInd];
        if(verbose)console.log(start + " (" + arr[start] + "), " + mInd + " (" + arr[mInd] + "), " +  end + " (" + arr[end] + "), " + x + " comp: " +comp(x, mElem))
        if(comp(x, mElem) == 0) return [true, mInd];
        else if(comp(x, mElem) > 0) return Util.binarySearch(x, arr, comp, mInd+1, end, verbose);
        else return Util.binarySearch(x, arr, comp, start, mInd, verbose);
      }
    },
    nearestTokens: (ver, event, collection, getLocation, eligibilityCheck = () => true, secialTreatmentForGrid = true) => {
      let coords = Canvas.mouseCoords(event);
      let p = Geometry.objTypes.Point.constr(ver, coords.x, coords.y, true);
      let minD = Number.MAX_SAFE_INTEGER;
      let X = [];
      if(secialTreatmentForGrid && collection[0] && collection[0].gType == "gridG"){
        let col2 = {};
        if(collection[0].objType == "Vertex"){
          for(let v in Version.current.graphs.cG.vertices){
            v = Version.current.graphs.cG.vertices[v].gridNode;
            if(eligibilityCheck(v)) col2[v.id] = v;
          }
          return Util.nearestTokens(ver, event, col2, v => v.p, () => true, false);
        }else if(collection[0].objType == "Edge"){
          return Util.nearestTokens(ver, event, ver.graphs.cG.edges, e => Util.nearestTokens(ver, event, e.edgePath, e2 => e2.ls, () => true, false).tokens[0].ls, eligibilityCheck, false);
          // for(let d of Version.current.results.resultDijkstras){
          //   if(eligibilityCheck(d[3])) col2[d[4].id] = d[3];
          // }
          // return Util.nearestTokens(ver, event, col2, ep => Util.nearestTokens(ver, event, ep, e => e.ls, () => true, false).tokens[0].ls, () => true, false);
        }else console.warn("diff obj type than expected", collection[0].objType);
      }else{
        for(let x in collection){
          x = collection[x];
          if(!eligibilityCheck(x)) continue;
          let d = Geometry.distanceBetween(p, getLocation(x));
          if(d < minD){
            minD = d;
            X = [x];
          }else if (d == minD) X.push(x); 
        }
      }
      return {tokens: X, d: minD};
    },
    getSmallestSubgraph: (v) => {
      let useEdges = v.objType == "Edge";
      if(v.objType == "Edge"){
        if(v.gType == "gridG") console.warn("use of getSmallestSubgraph on grid not intended");
        let cutEdges = (v2, e) => {
          let es = [];
          for(let e2 of v2.es){
            if(e == e2 || e2.gssVisited) continue;
            es.push(e2);
            e2.gssVisited = true;
            es = es.concat(cutEdges(Util.Edge.v2(e2, v2), e));
          }
          return es;
        }
        let sC = cutEdges(v.s, v);
        for(let e of sC) delete e.gssVisited;
        let tC = cutEdges(v.t, v);
        for(let e of tC) delete e.gssVisited;
        sC.push(v);
        tC.push(v);
        return sC.length < tC.length ? sC : tC;
      }
      if(v.gType == "gridG") return Util.getSmallestSubgraph(v.origStation).map(v2 => v2.gridNode);
      if(!useEdges && v.es.length == 1) return [v];
      let vsViewed = [v];
      vsViewed[0].gSt = -1;
      let dfs = (v2, stId, makeList) => {
        if(makeList){
          if(v2.gSt == -1) return [];
          v2.gSt = -1;
        }else{
          if('gSt' in v2) return 0;
          vsViewed.push(v2);
          v2.gSt = stId;
        }
        let ret = makeList ? [v2] : 1;
        for(let e of v2.es){
          let c2 = dfs(Util.Edge.v2(e, v2), stId, makeList);
          if(makeList) ret = ret.concat(c2); 
          else ret += c2;
        }
        return ret;
      }
      let minC = Number.MAX_SAFE_INTEGER;
      let minId = -1;
      for(let i = 0; i < v.es.length; i++){
        let c = dfs(Util.Edge.v2(v.es[i], v), i+1, false);
        if(c > 0 && c < minC){
          minC = c;
          minId = i;
        }
      }
      let st = dfs(Util.Edge.v2(v.es[minId], v), -1, true);
      st.push(v);
      for(let v of vsViewed) delete v.gSt;
      return st;
    },
    bfsPath: (v, v2) => {
      let useEdges = v.objType == "Edge";
      if(v.gType == "gridG"){
        if(useEdges) console.warn("use of bfsPath on grid not intended")
        else return Util.bfsPath(v.origStation, v2.origStation).map(v3 => v3.gridNode);
      }
      let vsViewed = [];
      let q = useEdges ? [v.s] : [v];
      outer: while(q.length > 0){
        let v3 = q.shift();
        for(let e of v3.es){
          let v4 = Util.Edge.v2(e, v3);
          if(!v4.bfsPrev){
            vsViewed.push(v4);
            v4.bfsPrev = [v3, e];
            if((useEdges && e == v2) || v4 == v2) break outer;
            q.push(v4);
          }
        }
      }
      let p = [v2];
      if(useEdges) {
        let lastV = (p[p.length-1].s.bfsPrev && p[p.length-1].s.bfsPrev[1] == p[p.length-1]) ? p[p.length-1].s.bfsPrev[0] : p[p.length-1].t.bfsPrev[0];
        while(lastV != v.s){
          p.push(lastV.bfsPrev[1]);
          lastV = lastV.bfsPrev[0];
        }
        if(p[p.length-1] != v) p.push(v);
      }else while(p[p.length-1] != v) p.push(p[p.length-1].bfsPrev[0]);
      for(let v of vsViewed) delete v.bfsPrev;
      return p;
    },
    shuffle: a => { //src: https://stackoverflow.com/a/6274381
      let j, x, i;
      for (i = a.length - 1; i > 0; i--) {
          j = Math.floor(Math.random() * (i + 1));
          x = a[i];
          a[i] = a[j];
          a[j] = x;
      }
      return a;
    },
    getPosition: (el) => {//src: https://www.kirupa.com/html5/getting_mouse_click_position.htm
      let xPosition = 0;
      let yPosition = 0;
    
      while (el) {
        if (el.tagName == "BODY") {
          // deal with browser quirks with body/window/document and page scroll
          let xScrollPos = el.scrollLeft || document.documentElement.scrollLeft;
          let yScrollPos = el.scrollTop || document.documentElement.scrollTop;
    
          xPosition += (el.offsetLeft - xScrollPos + el.clientLeft);
          yPosition += (el.offsetTop - yScrollPos + el.clientTop);
        } else {
          xPosition += (el.offsetLeft - el.scrollLeft + el.clientLeft);
          yPosition += (el.offsetTop - el.scrollTop + el.clientTop);
        }
    
        el = el.offsetParent;
      }
      return {
        x: xPosition,
        y: yPosition
      };
    }
  };

  var Geometry = {
    addGeoObject: (ver, o) => {
      o.id = ver.objectStore.idCounter++;
      ver.objectStore.objects[o.id] = o;
      // console.log("added")
      // console.log(o.asString())
      // console.log(o)
      //document.getElementById("objectList").innerHTML += "<div id='objectInList" + o.id + "'contentEditable='true' onkeydown='objectStore.objectInListEdited(event);'>"/* + o.constructor.name + ": " */ + o.asString() + "</div>";
    },
    removeGeoObject: (ver, o) => {
      delete ver.objectStore.objects[o.id];
      // if(typeof o == Geometry.objTypes.LineSegment) console.log("removed " + o)
    },
    objTypes: {
      GeoObject: {
        constr: (ver) => {
          return {verID: ver.versionIndex, visual: {
            objectShown: true,
            objectColor: Canvas.Colors.origEdge,
            highlightShown: false,
            highlightColor: Canvas.Colors.highlight,
            highlightSize: 7,
            labelShown: false,
            labelText: "",
            labelColor: "black",
            labelPosition: "top",
            labelSize: 12
          }};
        }
      },
      Station: {
        constr: (ver, v) => {
          let s = Geometry.objTypes.GeoObject.constr(ver);
          s.objType = "Station";
          s.v = v;
          s.expandedStation = v.expandedStation; 
          s.w = 6;
          s.h = 6;
          s.r = 3;
          s.tilted = false;
          if(s.expandedStation){
            dim1 = (v.lineCount-1)*(v.lineGap+v.lineSize);
            if(v.direction%2 == 1) s.tilted = true;
            if(v.direction == 0 || v.direction == 3) s.w += dim1;
            else if(v.direction == 1 || v.direction == 2) s.h += dim1;
          }else{
            let alignE, dim1;
            let dim2 = 1;
            let portOfEdge = e => v.ports.indexOf(e.path[0] == v ? e.path[1] : e.path[e.path.length-2]);
            if(v.origStation.es.length == 1 && v.origStation.es[0].lines.length > 1){
              alignE = v.origStation.es[0];
            }else if(v.origStation.es.length > 1){
              let lineBuckets = {};
              for(let e of v.origStation.es){
                let l = e.lines.length;
                if(!lineBuckets[l]) lineBuckets[l] = [];
                lineBuckets[l].push({e: e, p: portOfEdge(e), l: l});
              }
              lineNrs = Object.keys(lineBuckets);
              lineNrs.sort((a, b) => b-a); //decreasing
              if(lineBuckets[lineNrs[0]].length == 1){
                alignE = lineBuckets[lineNrs[0]][0];
              }else if(lineBuckets[lineNrs[0]].length == 2 && [-6, -2, 2, 6].includes(lineBuckets[lineNrs[0]][0].p - lineBuckets[lineNrs[0]][1].p)){
                let ed1 = lineBuckets[lineNrs[0]][0];
                let ed2 = lineBuckets[lineNrs[0]][1];
                dim1 = (ed1.e.lines.length-1)*(ed1.e.lb.lineGap+ed1.e.lb.lineSize);
                if(ed1.p%2 == 0) s.tilted = true;
                let p = Math.min(ed1.p, ed2.p) + (Math.max(ed1.p, ed2.p) - Math.min(ed1.p, ed2.p) == 6 ? 1 : -1); //might be false... tries to calc the port of the virtual alignE, between the edges
                lbLoop: for(let b in lineBuckets) for(let ed of lineBuckets[b]){
                  let ang = Math.max(p, ed.p) - Math.min(p, ed.p);
                  if(ang == 2 || ang == 6){
                    dim2 = ed.l;
                    break lbLoop;
                  }
                }
                dim2 = (dim2-1)*(ed1.e.lb.lineGap+ed1.e.lb.lineSize);
                if(p%4 == 0 || p%4 == 3){
                  s.w += dim1;
                  s.h += dim2;
                }else if(p%4 == 1 || p%4 == 2){
                  s.h += dim1; 
                  s.w += dim2;
                }
              }else{
                prioLoop: for(let ps of [[2, 6], [0, 4], [1, 5], [3, 7]]){
                  for(let ed of lineBuckets[lineNrs[0]]) if(ps.includes(ed.p)){
                    alignE = ed;
                    break prioLoop;
                  }
                }
              }
              if(alignE){
                lbLoop: for(let b in lineBuckets) for(let ed of lineBuckets[b]){
                  let ang = Math.max(alignE.p, ed.p) - Math.min(alignE.p, ed.p);
                  if(ang == 2 || ang == 6){
                    dim2 = ed.l;
                    break lbLoop;
                  }
                }
                alignE = alignE.e;
              }
            }

            if(alignE){
              let p = portOfEdge(alignE);
              if(!dim1) dim1 = alignE.lines.length
              dim1 = (dim1-1)*(alignE.lb.lineGap+alignE.lb.lineSize);
              dim2 = (dim2-1)*(alignE.lb.lineGap+alignE.lb.lineSize);
              if(p%2 == 1) s.tilted = true;
              if(p%4 == 0 || p%4 == 3){
                s.w += dim1;
                s.h += dim2;
              }else if(p%4 == 1 || p%4 == 2){
                s.h += dim1; 
                s.w += dim2;
              }
            }
          }
          Geometry.addGeoObject(ver, s);
          return s;
        },
        draw: (s, ctx) => {
          if(s.visual.objectShown){
            ctx.fillStyle = "white";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1;
            ctx.beginPath();
            if(s.tilted){
              let p = Canvas.coordsToPixel(s.v.p.x, s.v.p.y);
              let big = (s.w+s.h)/(Math.SQRT2*2);
              let small = big-s.h/Math.SQRT2;
              let rd = s.r*Math.SQRT2/2;
              ctx.moveTo(p.x + small - rd, p.y - big + rd);
              ctx.arc(p.x + small, p.y - big + 2*rd, s.r, -0.75*Math.PI, -0.25*Math.PI);
              ctx.lineTo(p.x + big - rd, p.y - small - rd);
              ctx.arc(p.x + big - 2*rd, p.y - small, s.r, -0.25*Math.PI, 0.25*Math.PI);
              ctx.lineTo(p.x - small + rd, p.y + big - rd);
              ctx.arc(p.x - small, p.y + big - 2*rd, s.r, 0.25*Math.PI, 0.75*Math.PI);
              ctx.lineTo(p.x - big + rd, p.y + small + rd);
              ctx.arc(p.x - big + 2*rd, p.y + small, s.r, 0.75*Math.PI, 1.25*Math.PI);
              ctx.lineTo(p.x + small - rd, p.y - big + rd);
            }else{
              let p = Canvas.coordsToPixel(s.v.p.x, s.v.p.y);
              let x = p.x-s.w/2;
              let y = p.y-s.h/2;
              ctx.moveTo(x + s.r, y);
              ctx.lineTo(x + s.w - s.r, y);
              ctx.arc(x + s.w - s.r, y + s.r, s.r, -0.5*Math.PI, 0);
              ctx.lineTo(x + s.w, y + s.h - s.r);
              ctx.arc(x + s.w - s.r, y + s.h - s.r, s.r, 0, 0.5*Math.PI);
              ctx.lineTo(x + s.r, y + s.h);
              ctx.arc(x + s.r, y + s.h - s.r, s.r, 0.5*Math.PI, 1*Math.PI);
              ctx.lineTo(x, y + s.r);
              ctx.arc(x + s.r, y + s.r, s.r, 1*Math.PI, 1.5*Math.PI);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
          }
        },
        dupe: (s, ver) => {
          let v;
          if(s.expandedStation){
            v = Util.cloneDict(ver, s.v, ["p"]);
            v.p = {x: s.v.p.x, y: s.v.p.y}
          }else v = ver.graphs.gridG.vertices[s.v.id];
          ver.objectStore.idCounter = s.id;
          let s2 = Geometry.objTypes.Station.constr(ver, v);
          let others = Util.cloneDict(ver, s, ["verID", "v", "draw", "dupe", "asString"]);
          for(let x in others) s2[x] = others[x];
          return s2;
        }
      },
      LineBundle: {
        constr: (ver, e, sOrient, tOrient, lineCols) => {
          let lb = Geometry.objTypes.GeoObject.constr(ver);
          lb.objType = "LineBundle";
          Geometry.addGeoObject(ver, lb);
          lb.e = e;
          lb.sOrient = sOrient;
          lb.tOrient = tOrient;
          lb.lineCols = lineCols;
          lb.lineSize = 2;
          lb.lineGap = 1;
          lb.ps = [];
          lb.visual.objectStroke = "line";
          for(let i = 0; i < e.path.length; i += 2){
            let v1 = e.path[i];
            let v2 = e.path[i+1];
            let pids;
            if(i == 0) pids = [sOrient, v1.ports.indexOf(v2)];
            else if(i == e.path.length-2) pids = [v2.ports.indexOf(v1), tOrient];
            else pids = [v1.parent.ports.indexOf(v1), v2.parent.ports.indexOf(v2)];
            let pid = Math.max(...pids);
            let pid2 = Math.min(...pids);
            let bendAng = pid-pid2;
            let xOffset, yOffset;
            if(bendAng == 4 && i != 0 && i != e.path.length-2) continue;
            if(bendAng == 7){
              xOffset = -0.2425;
              yOffset = -0.9701;
              /*
              7: -0.25, -1
              */
            }else if(bendAng == 6){
              xOffset = [0, -0.7071][7-pid];
              yOffset = [-1, -0.7071][7-pid];
              /*
              7: 0, -1
              6: -1, -1
              */
            }else if(bendAng == 5){
              xOffset = [0.2425, -0.2425, -0.9701][7-pid];
              yOffset = [-0.9701, -0.9701, -0.2425][7-pid];
              /*
              7: 0.25, -1
              6: -0.25, -1
              5: -1, -0.25
              */
            }else if(bendAng == 4){
              xOffset = [0.7071, 0, -0.7071, -1][7-pid];
              yOffset = [-0.7071, -1, -0.7071, 0][7-pid];
              /*
              7: 1, -1
              6: 0, -1
              5: -1, -1
              4: -1, 0
              */
            }else if(bendAng == 3){
              xOffset = [0.9701, 0.2425, -0.2425, -0.9701, -0.9701][7-pid];
              yOffset = [-0.2425, -0.9701, -0.9701, -0.2425, 0.2425][7-pid];
              /*
              7: 1, -0.25
              6: 0.25, -1
              5: -0.25, -1
              4: -1, -0.25
              3: -1, 0.25
              */
            }else if(bendAng == 2){
              xOffset = [1, 0.7071, 0, -0.7071, -1, -0.7071][7-pid];
              yOffset = [0, -0.7071, -1, -0.7071, 0, 0.7071][7-pid];
              /*
              7: 1, 0
              6: 1, -1
              5: 0, -1
              4: -1, -1
              3: -1, 0
              2: -1, 1
              */
            }else if(bendAng == 1){
              xOffset = [0.9701, 0.9701, 0.2425, -0.2425, -0.9701, -0.9701, -0.2425][7-pid];
              yOffset = [0.2425, -0.2425, -0.9701, -0.9701, -0.2425, 0.2425, 0.9701][7-pid];
              /*
              7: 1, 0.25
              6: 1, -0.25
              5: 0.25, -1
              4: -0.25, -1
              3: -1, -0.25
              2: -1, 0.25
              1: -0.25, 1
              */
            }
            if(i == 0) lb.ps.push([v1.p, {x: xOffset, y: yOffset}]);
            else if(i == e.path.length-2) lb.ps.push([v2.p, {x: xOffset, y: yOffset}]);
            else lb.ps.push([v1.parent.p, {x: xOffset, y: yOffset}]);
          }


          if(e.chain && e.chain.length > 1){
            lb.expandedStations = [];
            let segLengths = [];
            let pathLength = 0;
            let p = lb.ps[0][0];
            for(let i = 1; i < lb.ps.length; i++){
              let d = Geometry.distanceBetween(p, lb.ps[i][0]);
              segLengths.push(d);
              pathLength += d;
              p = lb.ps[i][0];
            }
            let sd = pathLength/e.chain.length;
            let dToGo = sd;
            let segC = 0;
            let segLeft = segLengths[0];
            for(let i = 0; i < e.chain.length-1; i++){
              while(segLeft <= dToGo){
                dToGo -= segLeft;
                segC++;
                segLeft = segLengths[segC];
              }
              segLeft -= dToGo;
              let d = segLengths[segC]-segLeft;
              let ux = (lb.ps[segC+1][0].x - lb.ps[segC][0].x)/segLengths[segC];
              let uy = (lb.ps[segC+1][0].y - lb.ps[segC][0].y)/segLengths[segC];
              let dir;
              if(lb.ps[segC+1][0].x == lb.ps[segC][0].x) dir = 0;
              else if(lb.ps[segC+1][0].y == lb.ps[segC][0].y) dir = 2;
              else if(lb.ps[segC+1][0].y > lb.ps[segC][0].y && lb.ps[segC+1][0].x > lb.ps[segC][0].x || lb.ps[segC+1][0].y < lb.ps[segC][0].y && lb.ps[segC+1][0].x < lb.ps[segC][0].x) dir = 3;
              else dir = 1;
              // console.log("placing station " + i  + " on segment " + segC + ", " + ((d/segLengths[segC])*100) +  "% in")
              lb.expandedStations.push(Geometry.objTypes.Station.constr(ver, {expandedStation: true, p: {x: lb.ps[segC][0].x + d*ux, y: lb.ps[segC][0].y + d*uy}, lineCount: lb.lineCols.length, direction: dir, lineSize: lb.lineSize, lineGap: lb.lineGap}));
              dToGo = sd;
            }
          }
          return lb;
        }, 
        draw: (lb, ctx) => {
          if(lb.visual.objectShown){
            ctx.lineWidth = lb.lineSize;
            if(lb.visual.objectStroke = "line") ctx.setLineDash = ([]);
            for(let l = 0; l < lb.lineCols.length; l++){
              let r = ((lb.lineCols.length-1)/2 - l) * (lb.lineSize + lb.lineGap);
              ctx.strokeStyle = lb.lineCols[l];
              ctx.beginPath();
              let p = Canvas.coordsToPixel(lb.ps[0][0].x, lb.ps[0][0].y);
              ctx.moveTo(p.x+r*lb.ps[0][1].x, p.y+r*lb.ps[0][1].y);
              for(let i = 1; i < lb.ps.length; i++){
                p = Canvas.coordsToPixel(lb.ps[i][0].x, lb.ps[i][0].y);
                ctx.lineTo(p.x+r*lb.ps[i][1].x, p.y+r*lb.ps[i][1].y);
                ctx.moveTo(p.x+r*lb.ps[i][1].x, p.y+r*lb.ps[i][1].y);
                ctx.closePath();
                ctx.stroke();
              }
            }
          }
          if(lb.visual.highlightShown){
            ctx.lineWidth = lb.lineCols.length*lb.visual.objectDimensions + (lb.lineCols.length-1)*lb.visual.gapSize;
            ctx.setLineDash = ([]);
            ctx.strokeStyle = lb.visual.highlightColor;
            ctx.beginPath();
            let p = lb.ps[0];
            ctx.moveTo(p[0].x, p[0].y);
            for(let i = 1; i < lb.ps.length; i++){
              p = lb.ps[i];
              ctx.lineTo(p[0].x, p[0].y);
              ctx.closePath();
              ctx.stroke();
            }
          }
          if(lb.visual.labelShown){
            ctx.font = lb.visual.labelSize + "px Arial";
            ctx.fillStyle = lb.visual.labelColor;
            if(lb.visual.labelPosition == "top") p.y -= 10;
            ctx.fillText(lb.visual.labelText, p.x, p.y);
          }
        },
        dupe: (lb, ver) => {
          let ps = [];
          for(let p of lb.ps) ps.push([ver.objectStore.objects[p[0].id], {x: p[1].x, y: p[1].y}])
          let lineCols = [];
          for(let c of lb.lineCols) lineCols.push(c);
          ver.objectStore.idCounter = lb.id;
          let lb2 = Geometry.objTypes.LineBundle.constr(ver, ver.graphs.cG.edges[lb.e.id], lb.sOrient, lb.tOrient, lineCols);
          lb2.ps = ps;
          let others = Util.cloneDict(ver, lb, ["verID", "e", "s", "sOrient", "tOrient", "lineCols", "ps", "expandedStations", "draw", "dupe", "asString"]);
          for(let x in others) lb2[x] = others[x];
          return lb2;
        }
      },
      Point: {
        constr: (ver, x, y, isHelpPoint = false) => {
          let p = Geometry.objTypes.GeoObject.constr(ver);
          p.objType = "Point";
          p.x = 1*x;
          p.y = 1*y;
          p.visual.objectShape = "rectangle";
          p.visual.objectDimensions = {w: 5, h: 5};
          p.visual.highlightSize = 7;
          p.isHelpPoint = isHelpPoint;
          if(!isHelpPoint) Geometry.addGeoObject(ver, p);
          return p;
        },
        draw: (p, ctx) => {
          let w = p.visual.objectDimensions.w;
          let h = p.visual.objectDimensions.h;
          let l = p.visual.highlightSize;
          if(p.visual.highlightShown){
            ctx.fillStyle = p.visual.highlightColor;
            let p2 = Canvas.coordsToPixel(p.x, p.y);
            if(p.visual.objectShape == "rectangle") ctx.fillRect(p2.x-(w+l)/2, p2.y-(h+l)/2, w+l, h+l);
          }
          if(p.visual.objectShown){
            ctx.fillStyle = p.visual.objectColor;
            let p2 = Canvas.coordsToPixel(p.x, p.y);
            if(p.visual.objectShape == "rectangle") ctx.fillRect(p2.x-w/2, p2.y-h/2, w, h);
          }
          if(p.visual.labelShown){
            ctx.font = p.visual.labelSize + "px Arial";
            ctx.fillStyle = p.visual.labelColor;
            let p2 = Canvas.coordsToPixel(p.x, p.y);
            if(p.visual.labelPosition == "top") p2.y -= 10;
            ctx.fillText(p.visual.labelText, p2.x, p2.y);
          }
        },
        dupe: (p, ver) => {
          ver.objectStore.idCounter = p.id;
          let p2 = Geometry.objTypes.Point.constr(ver, p.x, p.y, p.isHelpPoint);
          let others = Util.cloneDict(ver, p, ["verID", "v", "x", "y", "isHelpPoint", "draw", "dupe", "asString"]);
          for(let x in others) p2[x] = others[x];
          return p2;
        }
      },
      LineSegment: {
        constr: (ver, s, t, x2, y2) => {
          let ls = Geometry.objTypes.GeoObject.constr(ver);
          ls.objType = "LineSegment";
          if(s.objType && s.objType == "Point"){
            ls.s = s;
            ls.t = t;
          }else{
            ls.s = Geometry.objTypes.Point.constr(ver, s, t, true);
            ls.t = Geometry.objTypes.Point.constr(ver, x2, y2, true);
          }
          ls.visual.objectStroke = "line";
          ls.visual.objectDimensions = 1;
          ls.visual.arrowShown = false;
          ls.visual.arrowDimensions = {w: Math.PI*0.15, h: 15};
          ls.visual.arrowShape = "lines";
          Geometry.addGeoObject(ver, ls);
          return ls;
        },
        draw: (ls, ctx) => {
          let b;
          let b2;
          let p = Canvas.coordsToPixel(ls.s.x, ls.s.y);
          let p2 = Canvas.coordsToPixel(ls.t.x, ls.t.y);
          if(ls.visual.arrowShown){
            let d = Geometry.distanceBetween(p, p2);
            let f = (d - ls.visual.arrowDimensions.h)/d;
            let a = {x: p.x + (p2.x - p.x)*f, y: p.y + (p2.y - p.y)*f};
            b = Geometry.rotatePointAround(a, p2, ls.visual.arrowDimensions.w);
            b2 = Geometry.rotatePointAround(a, p2, -ls.visual.arrowDimensions.w);
          }

          if(ls.visual.highlightShown){
            ctx.lineWidth = ls.visual.objectDimensions + ls.visual.highlightSize;
            ctx.strokeStyle = ls.visual.highlightColor;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p2.x, p2.y);
            if(ls.visual.arrowShown){
              if(ls.visual.arrowShape == "lines"){
                ctx.moveTo(b.x, b.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.moveTo(b2.x, b2.y);
                ctx.lineTo(p2.x, p2.y);
              }
            }
            ctx.closePath();
            ctx.stroke();
          }
          if(ls.visual.objectShown){
            ctx.lineWidth = ls.visual.objectDimensions;
            ctx.strokeStyle = ls.visual.objectColor;
            if(ls.visual.objectStroke = "line") ctx.setLineDash = ([]);
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p2.x, p2.y);
            if(ls.visual.arrowShown){
              if(ls.visual.arrowShape == "lines"){
                ctx.moveTo(b.x, b.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.moveTo(b2.x, b2.y);
                ctx.lineTo(p2.x, p2.y);
              }
            }
            ctx.closePath();
            ctx.stroke();
          }
          if(ls.visual.labelShown){
            ctx.font = ls.visual.labelSize + "px Arial";
            ctx.fillStyle = ls.visual.labelColor;
            if(ls.visual.labelPosition == "top") p.y -= 10;
            ctx.fillText(ls.visual.labelText, p.x, p.y);
          }
        },
        dupe: (ls, ver) => {
          ver.objectStore.idCounter = ls.id;
          let ls2 = Geometry.objTypes.LineSegment.constr(ver, ver.objectStore.objects[ls.s.id], ver.objectStore.objects[ls.t.id]);
          let others = Util.cloneDict(ver, ls, ["verID", "s", "t", "draw", "dupe", "asString"]);
          for(let x in others) ls2[x] = others[x];
          return ls2;
        }
      },
    },
    sideOffPointWRTLine: (p, a, b) => {
      return Math.sign((b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x));
    }, 
    ptDistSquared: (a, b) => {
      return (a.x-b.x)**2 + (a.y-b.y)**2;
    },
    distanceBetween: (a, b) => {
      if((a.objType == "Point" && b.objType == "Point") || (a.x && a.y && b.x && b.y)) return Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2); // a and b are points
      else if(a.objType == "Point" || b.objType == "Point"){
        if(b.objType == "Point"){
          let c = a;
          a = b;
          b = c;
        }
        if(b.objType == "LineSegment"){// src: https://stackoverflow.com/a/1501725
          let l2 = (b.s.x - b.t.x)**2 + (b.s.y - b.t.y)**2;
          if (l2 == 0) return (a.x - b.s.x)**2 + (a.y - b.s.y)**2;
          let t = ((a.x - b.s.x) * (b.t.x - b.s.x) + (a.y - b.s.y) * (b.t.y - b.s.y)) / l2;
          t = Math.max(0, Math.min(1, t));
          let c = Geometry.objTypes.Point.constr(Version.store[a.verID], b.s.x + t * (b.t.x - b.s.x), b.s.y + t * (b.t.y - b.s.y), true);
          return Geometry.distanceBetween(a, c);
          // if(b.s.x == b.t.x){
          //   if(Math.min(b.s.y, b.t.y) < a.y && a.y < Math.max(b.s.y, b.t.y)) return Math.abs(a.x - b.s.x); // b is vertical LS with point a in y-intervall
          //   else return Math.min(distanceBetween(a, b.s), distanceBetween(a, b.t)); // b is vertical LS with point a outside y-intervall
          // }else{
          //   let m = (b.s.y-b.t.y)/(b.s.x-b.t.x);
          //   let cx = (b.s.y-m*b.s.x-a.y-a.x/m)/(-1/m-m);
          //   let cy = m*cx+b.s.y-m*b.s.x;
          //   let c = Geometry.objTypes.Point.constr(cx, cy, true);
          //   let dst = distanceBetween(b.s, b.t);
          //   let dcs = distanceBetween(c, b.s);
          //   let dct = distanceBetween(c, b.t);
          //   if(dst > dcs && dst > dct) return distanceBetween(a, c); // b is non-vertical LS with point a in y-intervall
          //   else return Math.min(dcs, dct); // b is non-vertical LS with point a outside y-intervall
          // }
        }
      }
    }, 
    angleABC: (a, b, c) => {
      let ab = {x: b.x-a.x, y: b.y-a.y};
      let cb = {x: b.x-c.x, y: b.y-c.y};
      let ang = Math.atan2(cb.y, cb.x) - Math.atan2(ab.y, ab.x);
      if (ang < 0) ang += 2 * Math.PI;
      return ang;
    }, 
    rotatePointAround: (a, c, phi) => {
      let sinPhi = Math.sin(phi);
      let cosPhi = Math.cos(phi);
      let a2 = {x: a.x - c.x, y: a.y - c.y};
      let a3 = {x: a2.x * cosPhi - a2.y * sinPhi + c.x, y: a2.x * sinPhi + a2.y * cosPhi + c.y};
      return a3;
    }, 
    doLineSegsIntersect: (a, b) => {
      let x, y;
      if(a.x1 == a.x2 && b.x1 == b.x2) return false;
      else if(a.x1 == a.x2){
        b.m = (b.y1-b.y2)/(b.x1-b.x2);
        b.t = b.y1-b.m*b.x1;
        x = a.x1;
        y = b.m*x+b.t;
        return (x <= Math.max(b.x1, b.x2) && x >= Math.min(b.x1, b.x2) && y <= Math.max(a.y1, a.y2) && y >= Math.min(a.y1, a.y2));
      }else if(b.x1 == b.x2){
        a.m = (a.y1-a.y2)/(a.x1-a.x2);
        a.t = a.y1-a.m*a.x1;
        x = b.x1;
        y = a.m*x+a.t;
        return (x <= Math.max(a.x1, a.x2) && x >= Math.min(a.x1, a.x2) && y <= Math.max(b.y1, b.y2) && y >= Math.min(b.y1, b.y2));
      }else{
        a.m = (a.y1-a.y2)/(a.x1-a.x2);
        b.m = (b.y1-b.y2)/(b.x1-b.x2);
        if(a.m == b.m) return false;
        a.t = a.y1-a.m*a.x1;
        b.t = b.y1-b.m*b.x1;
        x = (b.t-a.t)/(a.m-b.m);
        y = a.m*x+a.t;
        return (x <= Math.min(Math.max(a.x1, a.x2), Math.max(b.x1, b.x2)) && x >= Math.max(Math.min(a.x1, a.x2), Math.min(b.x1, b.x2)) && y <= Math.min(Math.max(a.y1, a.y2), Math.max(b.y1, b.y2)) && y >= Math.max(Math.min(a.y1, a.y2), Math.min(b.y1, b.y2)));
      }
    }, 
    intersectionOfLineSegs: (a, b) => {
      let x, y;
      a.m = (a.y1-a.y2)/(a.x1-a.x2);
      b.m = (b.y1-b.y2)/(b.x1-b.x2);
      if(a.m == b.m) return false;
      a.t = a.y1-a.m*a.x1;
      b.t = b.y1-b.m*b.x1;
      x = (b.t-a.t)/(a.m-b.m);
      y = a.m*x+a.t;
      return [x, y];
    }, 
    isPointInAARect: (p, r) => {
      return p.x > Math.min(r.x1, r.x2) && p.x < Math.max(r.x1, r.x2) && p.y > Math.min(r.y1, r.y2) && p.y < Math.max(r.y1, r.y2);
    }, 
    intersectionsOfAARectAndLine: (r, l) => {
      let a = {x: l.x1, y: l.y1};
      let b = {x: l.x2, y: l.y2};
      let c = {x: Math.min(r.x1, r.x2), y: Math.min(r.y1, r.y2)};
      let d = {x: Math.max(r.x1, r.x2), y: Math.max(r.y1, r.y2)};
      let ret = [];
      let p = Geometry.intersectionOfAxisParallelAndLine(false, c.y, a, b);
      if(p && c.x < p && p < d.x) ret.push({x: p, y: c.y});
      p = Geometry.intersectionOfAxisParallelAndLine(true, c.x, a, b);
      if(p && c.y < p && p < d.y) ret.push({x: c.x, y: p});
      p = Geometry.intersectionOfAxisParallelAndLine(false, d.y, a, b);
      if(p && c.x < p && p < d.x) ret.push({x: p, y: d.y});
      p = Geometry.intersectionOfAxisParallelAndLine(true, d.x, a, b);
      if(p && c.y < p && p < d.y) ret.push({x: d.x, y: p});
      return ret;
    }, 
    intersectionOfAxisParallelAndLine: (isVertical, o, a, b) => {
      if(isVertical){
        if(a.x == b.x) return null;
        if(a.y == b.y) return a.y;
        let m = (a.y-b.y)/(a.x-b.x);
        let t = a.y-m*a.x;
        let p = m*o+t;
        if(Math.min(a.x, b.x) < o && Math.max(a.x, b.x) > o && Math.min(a.y, b.y) < p && Math.max(a.y, b.y) > p) return p;
        return null;
      }else{
        if(a.y == b.y) return null;
        if(a.x == b.x) return a.x;
        let m = (a.x-b.x)/(a.y-b.y);
        let t = a.x-m*a.y;
        let p = m*o+t;
        if(Math.min(a.x, b.x) < p && Math.max(a.x, b.x) > p && Math.min(a.y, b.y) < o && Math.max(a.y, b.y) > o) return p;
        return null;
      }
    }
  };

  var Canvas = {
    elem: document.getElementById("canvas"),
    imgElem: document.getElementById("imgCanvas"),
    ctx: null,
    viewport: {
      x: 9.88,
      y: -49.81,
      w: 0.1,
      h: 0.1
    },
    grid: {
      showAxes: true,
      showGrid: true,
      useTicks: true,
      showSubdivisions: true,
      showNumbers: false,
      useShortUnits: false,
      axesColor: "black",
      gridColor: "black",
      subdivisionColor: "grey",
      numberColor: "red"
    },
    bounds: null,
    Colors: {//https://coolors.co/ff595e-ffca3a-60defb-4c191b-7452a3-1b9d8e
      highlight: "#FF595E",
      highlight2: "#FFCA3A", //un-tools
      origVtx: "#4C191B",
      origEdge: "#4C191B",
      currentVtx: "#7452A3",
      currentEdge: "#7452A3",
      resultVtx: "#1B9D8E",//329A79
      resultEdge: "#1B9D8E",
      // highlight: "#ef476f",
      // highlight2: "#ffd166", //un-tools
      // origVtx: "#06d6a0",
      // origEdge: "#06d6a0",
      // currentVtx: "#118ab2",
      // currentEdge: "#118ab2",
      // resultVtx: "#073b4c",
      // resultEdge: "#073b4c",
      // highlight: "OrangeRed",
      // highlight2: "yellow", //un-tools
      // origVtx: "RoyalBlue",
      // origEdge: "RoyalBlue",
      // currentVtx: "SeaGreen",
      // currentEdge: "SeaGreen",
      // resultVtx: "RebeccaPurple",
      // resultEdge: "RebeccaPurple",
      dcHl1: "#60DEFB",
      dcHl2: "#4C191B",
      dcHl3: "#FFCA3A",
      eSel1: "#60DEFB",
      eSel2: "#FFCA3A",
      wSel1: "#FFCA3A",
    },
    // Dims: {
    //   origVtx: {w: 5, h: 5},
    //   origEdge: 3,
    //   currVtx: {w: 5, h: 5},
    //   currEdge: 3,
    //   resultVtx: {w: 5, h: 5},
    //   resultEdge: 3,
    //   highlight: 7
    // },
    redraw: () => {
      Canvas.ctx.clearRect(0, 0, Canvas.elem.width, Canvas.elem.height);
      Canvas.drawGrid(Canvas.ctx);
      for(let o in Version.current.objectStore.objects) Geometry.objTypes[Version.current.objectStore.objects[o].objType].draw(Version.current.objectStore.objects[o], Canvas.ctx);
    },
    imgSrcOfVer: (ver) => {
      let ctx = Canvas.imgElem.getContext('2d');
      ctx.clearRect(0, 0, Canvas.imgElem.width, Canvas.imgElem.height);
      let vp = Canvas.viewport;
      Canvas.viewport = ver.viewport;
      Canvas.drawGrid(ctx);
      for(let o in ver.objectStore.objects) Geometry.objTypes[ver.objectStore.objects[o].objType].draw(ver.objectStore.objects[o], ctx);
      Canvas.viewport = vp;
      return Canvas.imgElem.toDataURL("image/png");
    },
    drawGrid: (ctx) => {
      if(!Canvas.grid.showGrid) return;
      ctx.beginPath();
      let xStepSize = (10**Math.floor(Math.log10(Canvas.viewport.w)))/2;
      let yStepSize = (10**Math.floor(Math.log10(Canvas.viewport.h)))/2;
      let xOffset = Canvas.viewport.x%xStepSize;
      let yOffset = Canvas.viewport.y%yStepSize;
      let pxStepSize = {x: (Canvas.bounds.w/Canvas.viewport.w)*xStepSize, y: (Canvas.bounds.h/Canvas.viewport.h)*yStepSize};
      let pxStart = Canvas.coordsToPixel(Canvas.viewport.x-xOffset-xStepSize, Canvas.viewport.y-yOffset-yStepSize);
      let pxEnd = Canvas.coordsToPixel(Canvas.viewport.w+Canvas.viewport.x, Canvas.viewport.h+Canvas.viewport.y);
      let labelText = Canvas.viewport.x-xOffset-xStepSize;
      ctx.font = "12px Arial";
      ctx.lineWidth = 1;
      ctx.setLineDash = ([]);
      for(let i = pxStart.x; i < pxEnd.x; i+=pxStepSize.x){
        ctx.strokeStyle = Canvas.grid.gridColor;
        ctx.moveTo(i, 0);
        ctx.lineTo(i, Canvas.grid.useTicks?12:Canvas.bounds.h);
        if(Canvas.grid.showSubdivisions){
          ctx.closePath();
          ctx.stroke();
          ctx.beginPath();
          ctx.strokeStyle = Canvas.grid.subdivisionColor;
          for(let j = 0.2; j < 1; j+=0.2){
            ctx.moveTo(i+j*pxStepSize.x, 0);
            ctx.lineTo(i+j*pxStepSize.x, Canvas.grid.useTicks?6:Canvas.bounds.h);
          }
          ctx.closePath();
          ctx.stroke();
          ctx.beginPath();
        }
        if(Canvas.grid.showNumbers){
          ctx.fillStyle = Canvas.grid.numberColor;
          ctx.fillText(labelText, i, 10);
          labelText += xStepSize;
        }
      }
      labelText = Canvas.viewport.y-yOffset-yStepSize;
      for(let i = pxStart.y; i < pxEnd.y; i+=pxStepSize.y){
        ctx.strokeStyle = Canvas.grid.gridColor;
        ctx.moveTo(0, i);
        ctx.lineTo(Canvas.grid.useTicks?12:Canvas.bounds.w, i);
        if(Canvas.grid.showSubdivisions){
          ctx.closePath();
          ctx.stroke();
          ctx.beginPath();
          ctx.strokeStyle = Canvas.grid.subdivisionColor;
          for(let j = 0.2; j < 1; j+=0.2){
            ctx.moveTo(0, i+j*pxStepSize.y);
            ctx.lineTo(Canvas.grid.useTicks?6:Canvas.bounds.w, i+j*pxStepSize.y);
          }
          ctx.closePath();
          ctx.stroke();
          ctx.beginPath();
        }
        if(Canvas.grid.showNumbers){
          ctx.fillStyle = Canvas.grid.numberColor;
          ctx.fillText(labelText, 10, i);
          labelText += yStepSize;
        }
      }
      ctx.closePath();
      ctx.stroke();
    },
    zoomView: (wDiff, hDiff, x, y) => {
      let wDelta = wDiff*0.002*Canvas.viewport.w;
      let hDelta = hDiff*0.002*Canvas.viewport.h;
      Canvas.viewport.w -= wDelta;
      Canvas.viewport.h -= hDelta;
      Canvas.viewport.x += wDelta*x/Canvas.bounds.w;
      Canvas.viewport.y += hDelta*y/Canvas.bounds.h;
    },
    coordsToPixel: (x, y) => {
      return {x: (Canvas.bounds.w/Canvas.viewport.w)*(x-Canvas.viewport.x), y: (Canvas.bounds.h/Canvas.viewport.h)*(y-Canvas.viewport.y)};
    },
    pixelToCoords: (x, y) => {
      return {x: Canvas.viewport.w*x/Canvas.bounds.w+Canvas.viewport.x, y: Canvas.viewport.h*y/Canvas.bounds.h+Canvas.viewport.y};
    },
    mouseCoords: (event) => {
      let parentPosition = Util.getPosition(event.currentTarget);
      return Canvas.pixelToCoords(event.clientX-parentPosition.x, event.clientY-parentPosition.y);
    },
    pixelDistPToMouse: (p, event) => {
      let parentPosition = Util.getPosition(event.currentTarget);
      let b = Canvas.coordsToPixel(p.x, p.y);
      return Math.sqrt((event.clientX-parentPosition.x-b.x)**2 + (event.clientY-parentPosition.y-b.y)**2);
    },
    pixelDistEToMouse: (e, event, useEdgePath = false) => {
      if(useEdgePath){
        let d = Math.min(...e.edgePath.map(e2 => Canvas.pixelDistEToMouse(e2, event, false)));
        return d;
      }else{
        let coords = Canvas.mouseCoords(event);
        let d = (Canvas.bounds.w/Canvas.viewport.w)*Geometry.distanceBetween(Geometry.objTypes.Point.constr(Version.current, coords.x, coords.y, true), e.ls);
        return d;
      }
    },
    setup: () => {//src: https://www.html5rocks.com/en/tutorials/canvas/hidpi/
      // Get the device pixel ratio, falling back to 1.
      let dpr = window.devicePixelRatio || 1;
      // Get the size of the canvas in CSS pixels.
      let rect = Canvas.elem.getBoundingClientRect();
      // Give the canvas pixel dimensions of their CSS
      // size * the device pixel ratio.
      Canvas.bounds = {w: rect.width, h: rect.height};
      Canvas.elem.width = rect.width * dpr;
      Canvas.elem.height = rect.height * dpr;
      let ctx = Canvas.elem.getContext('2d');
      // Scale all drawing operations by the dpr, so you
      // don't have to worry about the difference.
      ctx.scale(dpr, dpr);
      Canvas.ctx = ctx;
      Canvas.redraw();
      
      
      // rect = Canvas.imgElem.getBoundingClientRect();
      Canvas.imgElem.width = rect.width * dpr;
      Canvas.imgElem.height = rect.height * dpr;
      Canvas.imgElem.getContext('2d').scale(dpr, dpr);
    }
  };

  var MetroMap = {
    location: "wurzburg",
    edgeOrderPrios: {posStation: 1, strEdge: 2},
    Post: {
      updateDijkstras: (ver, newDijkstras, updateLD = true) => {
        ver.results.resultDijkstras = ver.results.resultDijkstras.filter(e => ver.graphs.cG.edges[e[4].id] && !newDijkstras.some(e2 => e2[4].id == e[4].id));
        // console.log("after removing " + newDijkstras.length + " we got " + ver.results.resultDijkstras.length);
        for(let d of newDijkstras) ver.results.resultDijkstras.push(d);
        if(updateLD) MetroMap.Post.makeLineDrawing(ver, [newDijkstras.some(e => !e[0]), ver.results.resultDijkstras]);
      },
      localSearchStepAll: (ver, downloadImg = false) => {
        if(!ver) ver = Version.current;
        let g = ver.graphs.cG;
        let cost = MetroMap.Post.recalcCost(ver);
        sT = Date.now();
        let factorCombinations = [[0, 0], [0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1]];
        let movedCounter = 0;
        //costs["candidateRadius"] = 0;
        for(let v in ver.graphs.cG.vertices){
          v = ver.graphs.cG.vertices[v];
          // v.p.visual.objectDimensions = {w:8, h:8}
          let locCost = Number.MAX_SAFE_INTEGER;
          let startPos = {i: v.gridNode.gridCoords.i, j: v.gridNode.gridCoords.j};
          let bestPos = startPos;
          let startP = {x: v.gridNode.p.x, y: v.gridNode.p.y};

          movesLoop: for(let i = 0; i < 9; i++){
            if((ver.routeSettings.positionedStations[v.id]||v.es.some(e => ver.routeSettings.frozenEdges[e.id])) && i > 0) continue;
            MetroMap.Routing.unsettleVtx(v);
            let gn = ver.graphs.gridG.gridNodes[startPos.i+factorCombinations[i][0]][startPos.j+factorCombinations[i][1]];
            if(gn.origStation) continue;
            // v.p.x = gn.p.x;
            // v.p.y = gn.p.y;
            if(!MetroMap.Routing.routeEdgeSearch(ver, v, gn, false)) continue;
            // let newDijkstras = [];
            // v.es.sort((a, b) => a.edgeOrderIndex - b.edgeOrderIndex);
            // for(let e of v.es){
            //   newDijkstras.push(MetroMap.Routing.routeEdgeSearch(ver, e, e.s.id == v.id ? gn : false, e.t.id == v.id ? gn : false));
            //   if(!newDijkstras[newDijkstras.length-1][0]) continue movesLoop;
            // }
            // MetroMap.Post.updateDijkstras(ver, newDijkstras, false);
            // let newCost = ver.results.resultDijkstras.reduce((acc, dijkstra) => acc + dijkstra[1], 0);
            //let newCost = newDijkstras.reduce((acc, dijkstra) => acc + dijkstra[1], 0);
            let newCost = MetroMap.Post.recalcCost(ver);
            if(newCost < locCost){
              locCost = newCost;
              bestPos = gn.gridCoords;
            }
          }

          // console.log("IDS: ",v.gridNode.id, ver.graphs.gridG.gridNodes[startPos.i][startPos.j].id)
          MetroMap.Routing.unsettleVtx(v);
          // let newDijkstras = [];     
          let gn = ver.graphs.gridG.gridNodes[bestPos.i][bestPos.j];
          if(!MetroMap.Routing.routeEdgeSearch(ver, v, gn, true)) console.error("best option couldnt route edge");
          // v.es.sort((a, b) => a.edgeOrderIndex - b.edgeOrderIndex);
          // let first = true;
          // for(let e of v.es){
          //   newDijkstras.push(MetroMap.Routing.routeEdgeSearch(ver, e, first && e.s.id == v.id ? gn : false, first && e.t.id == v.id ? gn : false));
          //   if(!newDijkstras[newDijkstras.length-1][0]){console.warn("pos reset failed!");break;}
          //   first = false;
          // }
          // if(!newDijkstras[newDijkstras.length-1][0]) console.error("best option couldnt route edge");
          // MetroMap.Post.updateDijkstras(ver, newDijkstras, true);//v.id == ver.results.vertexOrder[ver.results.vertexOrder.length-1].id);
          
          if(bestPos.i != startPos.i || bestPos.j != startPos.j){
            movedCounter++;
            gn.p.visual.objectColor = "lime";
          }
        }
        
        let newCost = MetroMap.Post.recalcCost(ver);
        Canvas.redraw();
        document.getElementById("timeOut").innerText = "Finished in " + (Date.now()-sT) + "ms with cost " + newCost + " (moved " + movedCounter + " vtcs, " + (Math.round((cost-newCost)*100)/100) + " improvement)";
        Version.current.results.calcTime = Date.now()-sT;
        console.log("Finished in " + (Date.now()-sT) + "ms, improved by " + (cost-newCost));
        if(newCost < cost) stepCounter++;
        console.log("steps: ", stepCounter)
        if(downloadImg){
          let dataURL = Canvas.elem.toDataURL("image/png");
          let link = document.createElement("a");
          link.download = "stepAll"+stepCounter;
          link.href = dataURL;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          // delete link; TODO find replacement
        }
        // console.log(minCost,  " but now its ", ver.results.resultDijkstras.reduce((acc, dijkstra) => acc + dijkstra[1], 0))
        return newCost;
      },
      localSearchStep: (ver, downloadImg = false) => {
        if(!ver) ver = Version.current;
        let g = ver.graphs.cG;
        let cost = MetroMap.Post.recalcCost(ver);
        sT = Date.now();
        let factorCombinations = [[0, 0], [0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1]];
        let minCost = cost;
        let movedV, movedP;
        //costs["candidateRadius"] = 0;
        for(let v in ver.graphs.cG.vertices){
          v = ver.graphs.cG.vertices[v];
          // v.p.visual.objectDimensions = {w:8, h:8}
          let locCost = Number.MAX_SAFE_INTEGER;
          let bestPos;
          let startPos = {i: v.gridNode.gridCoords.i, j: v.gridNode.gridCoords.j};
          let startP = {x: v.gridNode.p.x, y: v.gridNode.p.y};

          movesLoop: for(let i = 0; i < 9; i++){
            if((ver.routeSettings.positionedStations[v.id]||v.es.some(e => ver.routeSettings.frozenEdges[e.id])) && i > 0) continue;
            MetroMap.Routing.unsettleVtx(v);
            let gn = ver.graphs.gridG.gridNodes[startPos.i+factorCombinations[i][0]][startPos.j+factorCombinations[i][1]];
            if(gn.origStation) continue;
            // v.p.x = gn.p.x;
            // v.p.y = gn.p.y;
            if(!MetroMap.Routing.routeEdgeSearch(ver, v, gn, false)) continue;
            // let newDijkstras = [];
            // v.es.sort((a, b) => a.edgeOrderIndex - b.edgeOrderIndex);
            // for(let e of v.es){
            //   newDijkstras.push(MetroMap.Routing.routeEdgeSearch(ver, e, e.s.id == v.id ? gn : false, e.t.id == v.id ? gn : false));
            //   if(!newDijkstras[newDijkstras.length-1][0]) continue movesLoop;
            // }
            // MetroMap.Post.updateDijkstras(ver, newDijkstras, false);
            // let newCost = ver.results.resultDijkstras.reduce((acc, dijkstra) => acc + dijkstra[1], 0);
            //let newCost = newDijkstras.reduce((acc, dijkstra) => acc + dijkstra[1], 0);
            let newCost = MetroMap.Post.recalcCost(ver);
            if(newCost < locCost){
              locCost = newCost;
              bestPos = gn.gridCoords;
            }
          }

          // console.log("IDS: ",v.gridNode.id, ver.graphs.gridG.gridNodes[startPos.i][startPos.j].id)
          MetroMap.Routing.unsettleVtx(v);
          // let newDijkstras = [];
          let gn = ver.graphs.gridG.gridNodes[startPos.i][startPos.j];
          // console.log(startPos, v)
          if(!MetroMap.Routing.routeEdgeSearch(ver, v, gn, true)) {console.warn("pos reset failed!"); gn.p.highlightShown = true;}
          // v.es.sort((a, b) => a.edgeOrderIndex - b.edgeOrderIndex);
          // let first = true;
          // for(let e of v.es){
          //   newDijkstras.push(MetroMap.Routing.routeEdgeSearch(ver, e, first && e.s.id == v.id ? gn : false, first && e.t.id == v.id ? gn : false));
          //   if(!newDijkstras[newDijkstras.length-1][0]){console.warn("pos reset failed!");break;}
          //   first = false;
          // }
          // if(!newDijkstras[newDijkstras.length-1][0]) return cost;
          // MetroMap.Post.updateDijkstras(ver, newDijkstras, false);
          // let oldCost = ver.results.resultDijkstras.reduce((acc, dijkstra) => acc + dijkstra[1], 0); TODO Why does this change so much?
          // //let oldCost = newDijkstras.reduce((acc, dijkstra) => acc + dijkstra[1], 0);
          // console.log(locCost, " vs old: ", oldCost)
          if(locCost < minCost){
            minCost = locCost;
            movedV = v;
            movedP = bestPos;
          }
        }

        if(movedV){
          MetroMap.Routing.unsettleVtx(movedV);
          let gn = ver.graphs.gridG.gridNodes[movedP.i][movedP.j];
          if(!MetroMap.Routing.routeEdgeSearch(ver, movedV, gn, true)) console.warn("best routing failed!");
          // let newDijkstras = [];
          // for(let e of movedV.es){
          //   newDijkstras.push(MetroMap.Routing.routeEdgeSearch(ver, e, e.s.id == movedV.id ? gn : false, e.t.id == movedV.id ? gn : false));
          // }    
          // MetroMap.Post.updateDijkstras(ver, newDijkstras);
          // for(let v of ver.results.vertexOrder) v.gridNode.p.visual.objectShown = true;
          movedV.gridNode.p.visual.objectColor = "lime";
        }

        Canvas.redraw();    
        document.getElementById("timeOut").innerText = "Finished in " + (Date.now()-sT) + "ms with cost " + minCost + " (" + (Math.round((cost-minCost)*100)/100) + " improvement)";
        Version.current.results.calcTime = Date.now()-sT;
        Version.current.results.cost = MetroMap.Post.recalcCost(Version.current);
        // console.log("Finished in " + (Date.now()-sT) + "ms, improved by " + (cost-minCost));
        if(minCost < cost) stepCounter++;
        // console.log("steps: ", stepCounter)
        if(downloadImg){
          let dataURL = Canvas.elem.toDataURL("image/png");
          let link = document.createElement("a");
          link.download = "step"+stepCounter;
          link.href = dataURL;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          // delete link; TODO
        }
        // console.log(minCost,  " but now its ", ver.results.resultDijkstras.reduce((acc, dijkstra) => acc + dijkstra[1], 0))
        return minCost;
        // return cost-minCost;
      },
      recalcCost: (ver) => {
        let bendCosts = [null, ver.costs.c45, ver.costs.c90, ver.costs.c135, ver.costs.c180, ver.costs.c135, ver.costs.c90, ver.costs.c45];
        let g = ver.graphs.cG; //TODO mb use mg (after reinserting contracted stations)
        let c = 0;
        for(let v in g.vertices){
          v = g.vertices[v];
          c += Geometry.distanceBetween(v.p, v.gridNode.p)*(ver.costs.ch+ver.costs.cm)/ver.graphs.gridG.D;
          for(let i = 0; i < v.es.length; i++){
            let p1 = v.gridNode.ports.indexOf(v.es[i].path[0].id == v.gridNode.id ? v.es[i].path[1] : v.es[i].path[v.es[i].path.length-2]);
            for(let j = i+1; j < v.es.length; j++){
              if(!v.es[j].path) console.log(v.es[j])
              let p2 = v.gridNode.ports.indexOf(v.es[j].path[0].id == v.gridNode.id ? v.es[j].path[1] : v.es[j].path[v.es[j].path.length-2]);
              c += bendCosts[Math.max(p1, p2) - Math.min(p1, p2)];
              // console.log(p1, p2, bendCosts[Math.max(p1, p2) - Math.min(p1, p2)])
            }
          }
        }
        for(let e in g.edges){
          c += 2*ver.costs.cs+ver.costs.ch;
          e = g.edges[e];
          for(let i = 2; i < e.path.length-2; i+=2){
            if(!e.path[i].parent) console.warn("trying to get ports badly", e, e.path[i])
            let p1 = e.path[i].parent.ports.indexOf(e.path[i]);
            let p2 = e.path[i].parent.ports.indexOf(e.path[i+1]);
            // console.log(bendCosts[Math.max(p1, p2) - Math.min(p1, p2)])
            c += bendCosts[Math.max(p1, p2) - Math.min(p1, p2)] + ver.costs.ch;
          }
          if(e.chain && e.chain.length > 1){
            let k = e.chain.length-1;
            let l = (e.edgePath.length-1)/2;
            if(k+1 > l){
              let springF = (ver.costs.cc*((k+1-l)**2))/(2*k);
              c += springF;
              // console.log(e.id,k,l,springF)
            }
          }
        }
        ver.results.cost = c;
        return c;
      },
      updateTimeOut: (ver, success, time, cost = null, change) => {
        if(!cost) cost = MetroMap.Post.recalcCost(ver);
        ver.results.cost = cost;
        ver.results.calcTime = time;
        document.getElementById("timeOut").innerText = (success?"Finished in ":"Failed after ") + time + "ms with cost " + (Math.round(cost*100)/100);
        if(change) document.getElementById("timeOut").innerText += (change>0?" (worse by ":" (better by ") + (Math.round(Math.abs(change)*100)/100) + ")";
      },
      makeLineDrawing: (ver, result, objectsShown = ver.checkBoxes.cbShowLineDrawing) => {
        if(ver.results.lineDrawing){
          for(let s of ver.results.lineDrawing[0]) Geometry.removeGeoObject(ver, s);
          for(let lb of ver.results.lineDrawing[1]){
            if(lb.expandedStations) for(let s of lb.expandedStations) Geometry.removeGeoObject(ver, s);
            Geometry.removeGeoObject(ver, lb);
          }
        }
        if(result[0]) return;
        let dijkstras = result[1]; 
        ver.results.lineDrawing = [[], []];
        lineCols = ["red", "blue", "green", "orange", "black", "purple", "yellow", "brown", "cyan", "salmon", "lime", "pink"];
        for(let d of dijkstras){
          if(d[2][0].station) delete d[2][0].station;
          if(d[2][d[2].length-1].station) delete d[2][d[2].length-1].station;
        }
        for(let d of dijkstras){
          let sOrient, tOrient;
          //if(d[4].s.es.length == 1) 
          sOrient = (d[2][0].ports.indexOf(d[2][1])+4)%8;
    //      else sOrient = 0;
          tOrient = (d[2][d[2].length-1].ports.indexOf(d[2][d[2].length-2])+4)%8;
          // sOrient = 0;
          // tOrient = 0;
          d[4].lb = Geometry.objTypes.LineBundle.constr(ver, d[4], sOrient, tOrient, d[4].lines.map(x => lineCols[x]));
          d[4].lb.visual.objectShown = objectsShown;
          if(d[4].lb.expandedStations) for(let s of d[4].lb.expandedStations) s.visual.objectShown = objectsShown;
          ver.results.lineDrawing[1].push(d[4].lb);
        }
        for(let d of dijkstras){
          if(!d[2][0].station){
            d[2][0].station = Geometry.objTypes.Station.constr(ver, d[2][0]);
            d[2][0].station.visual.objectShown = objectsShown;
            ver.results.lineDrawing[0].push(d[2][0].station);
          }
          if(!d[2][d[2].length-1].station){
            d[2][d[2].length-1].station = Geometry.objTypes.Station.constr(ver, d[2][d[2].length-1]);
            d[2][d[2].length-1].station.visual.objectShown = objectsShown;
            ver.results.lineDrawing[0].push(d[2][d[2].length-1].station);
          }
        }
      }
    },
    Routing: {
      getEdgeOrder: (g, startVtx) => {
        let eO = [];
        let dangling = [];
        let unprocessed = [];
        let eoi = 0;
        let vertexOrder = [];
        let maxLDegV = g.vertices[0];
        for(let v in g.vertices){
          v = g.vertices[v];
          if(!startVtx || v.id != startVtx.id) unprocessed.push(v);
          v.edgeOrderingStatus = "unprocessed";
          // v.settled = false;
          if(!startVtx && v.contractParent.ldeg > maxLDegV.contractParent.ldeg) maxLDegV = v;
        }
          
        unprocessed.sort((a, b) => a.ldeg-b.ldeg);
        let v1 = startVtx ? startVtx : maxLDegV;
        if(!startVtx) unprocessed.splice(unprocessed.indexOf(maxLDegV), 1);
        dangling.push(v1);
        v1.edgeOrderingStatus = "dangling";
        dangling.sort((a, b) => a.ldeg-b.ldeg);
        while(dangling.length > 0){
          v1 = dangling.pop();
          vertexOrder.push(v1);
          let edgesToAdd = [];
          for(let e of v1.es) if(Util.Edge.v2(e, v1).edgeOrderingStatus != "processed") edgesToAdd.push(e);
          edgesToAdd.sort((a, b) => Util.Edge.v2(b, v1).ldeg-Util.Edge.v2(a, v1).ldeg);
          for(let e of edgesToAdd){
            e.edgeOrderIndex = eoi++;
            eO.push(e);
            Util.Edge.v2(e, v1).edgeOrderingStatus = "dangling";
            unprocessed.splice(unprocessed.indexOf(Util.Edge.v2(e, v1)), 1);
            dangling.push(Util.Edge.v2(e, v1));
          }
          dangling.sort((a, b) => a.ldeg-b.ldeg);
          v1.edgeOrderingStatus = "processed";
        }
        if(unprocessed.length > 0)  console.log("G wasn't connected, didn't finish edge ordering");
        return [eO, vertexOrder];
      },
      recalcEdgeOrder: (ver) => {
        let eoPrios = {};
        let [eO, vO] = MetroMap.Routing.getEdgeOrder(ver.graphs.cG);
        let groups = {};
        for(let i = 0; i < eO.length; i++){
          let e = eO[i];
          if(ver.routeSettings.frozenEdges[e.id]){
            if(!groups[ver.routeSettings.frozenEdges[e.id].groupID]) groups[ver.routeSettings.frozenEdges[e.id].groupID] = [];
            groups[ver.routeSettings.frozenEdges[e.id].groupID].push(e);
            continue;
          }
          let p = 1-i/eO.length;
          if(ver.routeSettings.positionedStations[e.s.contractParent.id]) p += MetroMap.edgeOrderPrios.posStation;
          if(ver.routeSettings.positionedStations[e.t.contractParent.id]) p += MetroMap.edgeOrderPrios.posStation;
          if(ver.routeSettings.straightEdges.some(se => se.length == e.chain.length && se.every(e2 => e.chain.includes(e2)))) p += MetroMap.edgeOrderPrios.strEdge;

          // if(!ver.routeSettings.frozenEdges[e.id]) p += 5;
          eoPrios[eO[i].id] = p;
        }
        // console.log(groups)
        for(let gr in groups){
          gr = groups[gr];
          let i = 1;
          while(gr.length > 0){
            let maxP = Number.MIN_SAFE_INTEGER;
            let maxE;
            for(let e of gr){
              for(let e2 of e.s.es){
                if(eoPrios[e2.id] && eoPrios[e2.id] > maxP){
                  maxP = eoPrios[e2.id];
                  maxE = e;
                }
              }
              for(let e2 of e.t.es){
                if(eoPrios[e2.id] && eoPrios[e2.id] > maxP){
                  maxP = eoPrios[e2.id];
                  maxE = e;
                }
              }
            }
            gr.splice(gr.indexOf(maxE), 1)
            eoPrios[maxE.id] = maxP - (i/(gr.length+2))/eO.length;
            i++;
          }
        }
        // console.log(ver.results.edgeOrder)
        ver.results.edgeOrder = eO;
        ver.results.edgeOrder.sort((a, b) => eoPrios[b.id] - eoPrios[a.id]);
        ver.results.vertexOrder = vO; //TODO maybe sort smarter
        // let s = "";
        // for(let e of ver.results.edgeOrder) s += e.id +"(" + eoPrios[e.id] + ")\t"
        // console.log(s)
        return eoPrios;
      },
      redrawBtn: () => {
        let sT = Date.now();
        MetroMap.Routing.recalcAll(Version.current);
        Canvas.redraw();
        Version.current.results.calcTime = Date.now()-sT;
        Version.current.results.cost = MetroMap.Post.recalcCost(Version.current);
        // if(Version.current.versionIndex > 0 && !Version.current.isAlternative){ 
        //   let costChanges = [];
        //   let hi = -1;
        //   for(let i = 0; i < Version.history.length && hi == -1; i++) if(Version.history[i].includes(Version.store[Version.current.versionIndex])) hi = i;
        //   // console.log(hi)
        //   if(Version.history[hi-1]){
        //     for(let c in Version.history[hi-1][0].costs) costChanges.push([Version.history[hi-1][0].costs[c]-Version.current.costs[c], c]);
        //     // console.log(costChanges)
        //     let s = "";
        //     for(let cc of costChanges) if(cc[0] != 0) s += (cc[0]>0?"Decreased " : "Increased ") + cc[1] + ", ";
        //     if(s.length > 0) Version.edited("Changed Cost: " + s.substring(0, s.length-2));
        //   }
        // }
        Version.edited("Redrawn");
      },
      recalcAll: (ver) => {
        // console.log(ver.costs.c90);
        sT = Date.now();
        if(!ver) ver = Version.current;
        if(Writing.measurePerformance) Writing.times.s = performance.now();
        MetroMap.Routing.recalcCG(ver);
        let g = Version.current.graphs.cG;
        let es = [];
        for(let e in g.edges) es.push(g.edges[e]);

        let failed = !MetroMap.Routing.routeEdges(ver, es);

        // [ver.results.edgeOrder, ver.results.vertexOrder] = MetroMap.Routing.getEdgeOrder(ver.graphs.cG);

        // delete ver.graphs.gridG.s2sDijkstraIDSortedVtcs;
        // // MetroMap.Post.updateDijkstras(ver, dijkstras);
        // if(failed) ver.results.resultDijkstras = null;
        // else ver.results.resultDijkstras = dijkstras;

        // MetroMap.Post.makeLineDrawing(ver, [failed, dijkstras]);

        // Canvas.redraw();
        // let cost = MetroMap.Post.recalcCost(ver);//dijkstras.reduce((acc, dijkstra) => acc + dijkstra[1], 0);
        // MetroMap.Post.updateTimeOut(ver, !failed, Date.now()-sT, cost);


        // ver.results.cost = cost;
        // ver.results.calcTime = Date.now()-sT;
        // document.getElementById("timeOut").innerText = (failed ? "Failed" : "Finished") + " in " + (Date.now()-sT) + "ms with cost " + cost;
        document.getElementById("canvas").focus();
        // if(ver.versionIndex > 0 && ver.isCurrent){ 
        //   let costChanges = [];
        //   let hi = -1;
        //   for(let i = 0; i < Version.history.length && hi == -1; i++) if(Version.history[i].includes(Version.store[ver.versionIndex])) hi = i;
        //   console.log(hi)
        //   for(let c in Version.history[hi-1][0].costs) costChanges.push([Version.history[hi-1][0].costs[c]-ver.costs[c], c]);
        //   // console.log(costChanges)
        //   let s = "";
        //   for(let cc of costChanges) if(cc[0] != 0) s += (cc[0]>0?"Decreased " : "Increased ") + cc[1] + ", ";
        //   if(s.length > 0) Version.edited("Changed Cost: " + s.substring(0, s.length-2));
        // }
        //TODO make cost changes cooperate with other edits
        return !failed;
      },
      recalcCG: (ver) => {
        let feEntries = [];
        for(let fe in ver.routeSettings.frozenEdges) feEntries.push({sid: ver.graphs.cG.edges[fe].s.contractParent.id, tid: ver.graphs.cG.edges[fe].t.contractParent.id, val: ver.routeSettings.frozenEdges[fe]});
        for(let v in ver.graphs.cG.vertices){
          MetroMap.Routing.unsettleVtx(ver.graphs.cG.vertices[v]);
          for(let e of ver.graphs.cG.vertices[v].es) e.skipUnsettle = true;
        }
        for(let v in ver.graphs.cG.vertices){//might be unecessary
          for(let e of ver.graphs.cG.vertices[v].es) e.skipUnsettle = undefined;
        }
        Util.Graph.removeAll(ver.graphs.cG);
        ver.graphs.cG = MetroMap.GraphCreation.deg2Contract(ver, ver.graphs.mG);
        for(let v in ver.routeSettings.movedInputs) if(ver.graphs.mG.vertices[v].contract.v){
          ver.graphs.mG.vertices[v].contract.v.p.x = ver.routeSettings.movedInputs[v].x;
          ver.graphs.mG.vertices[v].contract.v.p.y = ver.routeSettings.movedInputs[v].y;
        }
        let fes = {};
        for(let fe of feEntries){
          let eid;
          for(let e in ver.graphs.cG.edges){
            e = ver.graphs.cG.edges[e];
            if((fe.sid == e.s.contractParent.id && fe.tid == e.t.contractParent.id) || (fe.sid == e.t.contractParent.id && fe.tid == e.s.contractParent.id)){
              eid = e.id;
              break;
            }
          }
          fes[eid] = fe.val;
        }
        ver.routeSettings.frozenEdges = fes;
      },
      unsettleVtx: (v) => {
        v.settled = false;
        if(v.gridNode){
          v.gridNode.origStation = undefined;
          v.gridNode.settleable = true;
          v.gridNode.p.visual.objectShown = false; //TODO maybe reset visuals
          v.gridNode.p.visual.objectDimensions = {w: 5, h: 5};
        }
        // if(v.ver.graphs.mGToGridConnectors) Geometry.removeGeoObject(ver, v.ver.graphs.mGToGridConnectors);
        v.gridNode = undefined;
        for(let e of v.es){
          // console.log("unsettling edge ", e.id)
          if(e.skipUnsettle) continue;
          let esToReset = [];
          e.settled = false;
          e.sPortUsed = undefined;
          e.tPortUsed = undefined;
          if(!e.edgePath) continue;
          for(let e2 of e.edgePath){
            if(e2.ls){
              e2.ls.visual.objectShown = false;
              e2.ls = undefined;
            }
            esToReset.push(e2);
            e2.origEdge = undefined;
            for(let e3 of e2.blockedDiagonals) esToReset.push(e3);
            e2.blockedDiagonals = undefined;
          }
          for(let e2 of e.path[0].es){
            esToReset.push(e2);
          }
          for(let p of e.path[0].ports){
            for(let e2 of p.es){
              if(e2.occupiedStatusDict[e.id]) esToReset.push(e2);
            }
          }
          for(let i = 2; i < e.path.length-2; i += 2){
            let u = e.path[i];
            if(!u.ports){
              u = u.parent;
              u.settleable = true;
              for(let p of u.ports){
                for(let e2 of p.es) if(e2.occupiedStatusDict[e.id]) esToReset.push(e2);
              }
            }
          }
          for(let e2 of e.path[e.path.length-1].es){
            esToReset.push(e2);
          }
          for(let p of e.path[e.path.length-1].ports){
            for(let e2 of p.es){
              if(e2.occupiedStatusDict[e.id]) esToReset.push(e2);
            }
          }

          for(let e2 of esToReset){
            delete e2.occupiedStatusDict[e.id];
            let maxOS = 0;
            for(let os in e2.occupiedStatusDict){
              if(e2.occupiedStatusDict[os] > maxOS) maxOS = e2.occupiedStatusDict[os];
              if(maxOS == 2) break;
            }
            e2.occupiedStatus = maxOS;
          }
          e.edgePath = undefined;
          e.path = undefined;
        }
      },
      edgeAngle: (a, b, c, e, e2) => {
        if(e.chain){
          let a2, c2;
          if(e.chain[0].s.contract.v && e.chain[0].s.contract.v.id == b.id) a2 = e.chain[0].t;
          else if(e.chain[0].t.contract.v && e.chain[0].t.contract.v.id == b.id) a2 = e.chain[0].s;
          else if(e.chain[e.chain.length-1].t.contract.v && e.chain[e.chain.length-1].t.contract.v.id == b.id) a2 = e.chain[e.chain.length-1].s;
          else if(e.chain[e.chain.length-1].s.contract.v && e.chain[e.chain.length-1].s.contract.v.id == b.id) a2 = e.chain[e.chain.length-1].t;
          else console.warn("thats not how you use this 1");
          if(e2.chain[0].s.contract.v && e2.chain[0].s.contract.v.id == b.id) c2 = e2.chain[0].t;
          else if(e2.chain[0].t.contract.v && e2.chain[0].t.contract.v.id == b.id) c2 = e2.chain[0].s;
          else if(e2.chain[e2.chain.length-1].t.contract.v && e2.chain[e2.chain.length-1].t.contract.v.id == b.id) c2 = e2.chain[e2.chain.length-1].s;
          else if(e2.chain[e2.chain.length-1].s.contract.v && e2.chain[e2.chain.length-1].s.contract.v.id == b.id) c2 = e2.chain[e2.chain.length-1].t;
          else console.warn("thats not how you use this 2");
          return Geometry.angleABC(a2.p, b.p, c2.p);
        }
        else return Geometry.angleABC(a.p, b.p, c.p)
      },
      routeEdge: (ver, e, sCandidate = false, tCandidate = false, frozen = false, objectsShown = ver.checkBoxes.cbShowResult) => {
        let endptsSet = sCandidate&&tCandidate?2:(sCandidate||tCandidate?1:0);
        if(Writing.measurePerformance2) Writing.times.ps[endptsSet].push(-1*performance.now());
        if(frozen){//TODO make a method that checks if the frozen part fits at a certain pos(tersyt for gridsize)
          // console.log(frozen, e)
          if(!e.s.settled && !e.t.settled) console.warn("frozen edge with no settled ends getting routed");
          let v1 = e.s.settled ? e.s.gridNode : ver.graphs.gridG.gridNodes[e.t.gridNode.gridCoords.i-frozen.iSTDiff][e.t.gridNode.gridCoords.j-frozen.jSTDiff];
          let v2 = e.t.settled ? e.t.gridNode : ver.graphs.gridG.gridNodes[e.s.gridNode.gridCoords.i+frozen.iSTDiff][e.s.gridNode.gridCoords.j+frozen.jSTDiff];
          // console.log("from", v1.gridCoords, "to", v2.gridCoords)
          let path = [v1, v1.ports[frozen.bendToPortSeq[0]]];
          let edgePath = [v1.es.find(e2 => Util.Edge.v2(e2, v1) == path[1])];
          for(let i = 1; i < frozen.bendToPortSeq.length+1; i++){
            let e2 = path[path.length-1].es.find(e3 => Util.Edge.v2(e3, path[path.length-1]).parent && Util.Edge.v2(e3, path[path.length-1]).parent != path[path.length-1].parent);
            edgePath.push(e2);
            path.push(Util.Edge.v2(e2, path[path.length-1]));
            let tp = i < frozen.bendToPortSeq.length ? path[path.length-1].parent.ports[frozen.bendToPortSeq[i]] : v2;
            edgePath.push(path[path.length-1].es.find(e3 => Util.Edge.v2(e3, path[path.length-1]) == tp));
            path.push(tp);
          }
          // console.log(path, edgePath)
          if(edgePath[0].occupiedStatus > 1 || edgePath[edgePath.length-1].occupiedStatus > 1) return false;
          for(let i = 1; i < edgePath.length-1; i++) if(edgePath[i].occupiedStatus > 0) return false;
          for(let i = 2; i < path.length-2; i += 2) if(!path[i].parent.settleable) return false;
          return MetroMap.Routing.routeEdgeCleanup(ver, [true, null, path, edgePath], e, [], [], sCandidate, tCandidate, [], [], objectsShown);
        }
        let grid = ver.graphs.gridG;
        // console.log("STARTING ", e, sCandidate?sCandidate.id:sCandidate, tCandidate?tCandidate.id:tCandidate, e.s.settled, e.t.settled)
        let r = (ver.costs.candidateRadius*ver.graphs.gridG.D)**2;
        let tempOpen = [];
        let tempClosed = [];
        let offSet = 1;
        let factorCombinations = [[0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1]];
        let bendCosts = [null, "c45", "c90", "c135", "c180", "c135", "c90", "c45"];

        // let S = sCandidate ? [sCandidate] : [MetroMap.Routing.findClosestGridNode(ver, e.s)];      
        // for(let e2 of S[0].es) e2.costKeys = ["cs", {a: S[0].p, b: e.s.p, l: "S-0"}];
        // S[0].settleable = false;
        // let T = tCandidate ? [tCandidate] : [MetroMap.Routing.findClosestGridNode(ver, e.t)];
        // for(let e2 of T[0].es) e2.costKeys = ["cs", {a: T[0].p, b: e.t.p, l: "T-0"}];
        // S[0].settleable = true;
        // let addedSomething = true;
        // while(addedSomething){
        //   addedSomething = false;
        //   let nodesToTest = [];
        //   for(let i = Math.max(0, S[0].gridCoords.i-offSet); i <= Math.min(grid.gridNodes.length-1, S[0].gridCoords.i+offSet); i++){
        //     let j = S[0].gridCoords.j-offSet;
        //     if(j >= 0) nodesToTest.push(grid.gridNodes[i][j]);
        //     j = S[0].gridCoords.j+offSet;
        //     if(j < grid.gridNodes[0].length) nodesToTest.push(grid.gridNodes[i][j]);
        //   }
        //   for(let j = Math.max(-1, S[0].gridCoords.j-offSet)+1; j <= Math.min(grid.gridNodes[0].length, S[0].gridCoords.j+offSet)-1; j++){
        //     let i = S[0].gridCoords.i-offSet;
        //     if(i >= 0) nodesToTest.push(grid.gridNodes[i][j]);
        //     i = S[0].gridCoords.i+offSet;
        //     if(i < grid.gridNodes.length) nodesToTest.push(grid.gridNodes[i][j]);
        //   }
        //   for(let v of nodesToTest){
        //     if(v.settleable && Geometry.distanceBetween(e.s.p, v.p) < r && (e.t.settled || Geometry.distanceBetween(e.s.p, v.p) <= Geometry.distanceBetween(e.t.p, v.p))){
        //       S.push(v);
        //       for(let e2 of v.es) e2.costKeys = ["cs", {a: v.p, b: e.s.p, l: "S-1"}];
        //       addedSomething = true;
        //     }
        //   }
        //   nodesToTest = [];
        //   for(let i = Math.max(0, T[0].gridCoords.i-offSet); i <= Math.min(grid.gridNodes.length-1, T[0].gridCoords.i+offSet); i++){
        //     let j = T[0].gridCoords.j-offSet;
        //     if(j >= 0) nodesToTest.push(grid.gridNodes[i][j]);
        //     j = T[0].gridCoords.j+offSet;
        //     if(j < grid.gridNodes[0].length) nodesToTest.push(grid.gridNodes[i][j]);
        //   }
        //   for(let j = Math.max(-1, T[0].gridCoords.j-offSet)+1; j <= Math.min(grid.gridNodes[0].length, T[0].gridCoords.j+offSet)-1; j++){
        //     let i = T[0].gridCoords.i-offSet;
        //     if(i >= 0) nodesToTest.push(grid.gridNodes[i][j]);
        //     i = T[0].gridCoords.i+offSet;
        //     if(i < grid.gridNodes.length) nodesToTest.push(grid.gridNodes[i][j]);
        //   }
        //   for(let v of nodesToTest){
        //     if(v.settleable && Geometry.distanceBetween(e.t.p, v.p) < r && (e.s.settled || Geometry.distanceBetween(e.t.p, v.p) < Geometry.distanceBetween(e.s.p, v.p))){
        //       T.push(v);
        //       for(let e2 of v.es) e2.costKeys = ["cs", {a: v.p, b: e.t.p, l: "T-1"}];
        //       addedSomething = true;
        //     }
        //   }
        //   offSet++;
        // }
        

        let S = sCandidate ? [sCandidate] : [];
        let T = tCandidate ? [tCandidate] : [];

        let occupiedPS = [];
        for(let ps in ver.routeSettings.positionedStations) occupiedPS.push(ver.routeSettings.positionedStations[ps]);

        let sDecided = e.s.settled || sCandidate;
        let tDecided = e.t.settled || tCandidate;

        if(!(sDecided && tDecided)) for(let i = 0; i < ver.graphs.gridG.gridNodes.length; i++){
          for(let j = 0; j < ver.graphs.gridG.gridNodes[i].length; j++){
            let v = ver.graphs.gridG.gridNodes[i][j];
            if(sDecided){
              if(v.settleable && !occupiedPS.includes(v) && Geometry.ptDistSquared(e.t.p, v.p) < r){
                T.push(v);
                for(let e2 of v.es) e2.costKeys = ["cs", {a: v.p, b: e.t.p, l: "T-1"}];
              }
            }else if(tDecided){
              if(v.settleable && !occupiedPS.includes(v) && Geometry.ptDistSquared(e.s.p, v.p) < r){
                S.push(v);
                for(let e2 of v.es) e2.costKeys = ["cs", {a: v.p, b: e.s.p, l: "S-1"}];
              }
            }else if(v.settleable && !occupiedPS.includes(v)){
              let sd = Geometry.ptDistSquared(e.s.p, v.p);
              let td = Geometry.ptDistSquared(e.t.p, v.p);
              if(Math.min(sd, td) < r){
                if(sd < td){
                  S.push(v);
                  for(let e2 of v.es) e2.costKeys = ["cs", {a: v.p, b: e.s.p, l: "S-1"}];
                }else{
                  T.push(v);
                  for(let e2 of v.es) e2.costKeys = ["cs", {a: v.p, b: e.t.p, l: "T-1"}];
                }
              }
            }
          }
        }

        // console.log(S.length, T.length, S[0].es[0].cost, T[0].es[0].cost)
        if(sCandidate){
          e.s.settled = true;
          e.s.gridNode = sCandidate;
          sCandidate.origStation = e.s;
          sCandidate.settleable = false;
          if(T.includes(sCandidate)) T.splice(T.indexOf(sCandidate), 1);
        }
        if(tCandidate){
          e.t.settled = true;
          e.t.gridNode = tCandidate;
          tCandidate.origStation = e.t;
          tCandidate.settleable = false;
          if(S.includes(tCandidate)) S.splice(S.indexOf(tCandidate), 1);
        }
        if(S.some(v => T.includes(v))) console.error("vtx in both S and T early", S, T, e, sCandidate, tCandidate, e.s.settled, e.t.settled);
        if(tCandidate && S.includes(tCandidate)) console.error("tcan in S", S, T, e, sCandidate, tCandidate, e.s.settled, e.t.settled);
        if(sCandidate && T.includes(sCandidate)) console.error("scan in T", S, T, e, sCandidate, tCandidate, e.s.settled, e.t.settled);
        if(tCandidate && e.s.settled && e.s.gridNode == tCandidate) console.error("tcan is e.s.gn", S, T, e, sCandidate, tCandidate, e.s.settled, e.t.settled);
        if(sCandidate && e.t.settled && e.t.gridNode == sCandidate) console.error("scan is e.t.gn", S, T, e, sCandidate, tCandidate, e.s.settled, e.t.settled);
        if(e.s.settled){
          if(sCandidate) S = [sCandidate];
          else S = [e.s.gridNode];
          for(let e2 of S[0].es) e2.costKeys = ["cs", {a: S[0].p, b: e.s.p, l: "s1"}];
          let v = S[0];
          if(!v.settleable){
            let ps, pt;
            let settledAdj = [];
            for(let e2 of e.s.es) if(e2.settled) settledAdj.push(e2);
            if(settledAdj.length == 0){
              ps = 0;
              pt = 8;
            }else{
              settledAdj.sort((a, b) => MetroMap.Routing.edgeAngle(e.t, e.s, Util.Edge.v2(a, e.s), e, a) - MetroMap.Routing.edgeAngle(e.t, e.s, Util.Edge.v2(b, e.s), e, b));
              pt = (e.s.id == settledAdj[0].s.id) ? settledAdj[0].sPortUsed : settledAdj[0].tPortUsed;
              ps = (e.s.id == settledAdj[settledAdj.length-1].s.id) ? settledAdj[settledAdj.length-1].sPortUsed : settledAdj[settledAdj.length-1].tPortUsed;
              //if(pt <= ps) pt += 8;
              if((e.s.id != settledAdj[0].s.id && e.s.id != settledAdj[0].t.id) || e.s.id != settledAdj[settledAdj.length-1].s.id && e.s.id != settledAdj[settledAdj.length-1].t.id)console.warn("seems wrong")
              let a1 = MetroMap.Routing.edgeAngle(e.t, e.s, Util.Edge.v2(settledAdj[0], e.s), e, settledAdj[0]);
              let a2 = MetroMap.Routing.edgeAngle(e.t, e.s, Util.Edge.v2(settledAdj[settledAdj.length-1], e.s), e, settledAdj[settledAdj.length-1]);
              // console.log("allowed area is " + ps + " - " + pt + "between " + a1 + " and " + a2);
              for(let e2 of e.s.es){
                if(!e2.settled && e2.id != e.id){
                  let a3 = MetroMap.Routing.edgeAngle(e.t, e.s, Util.Edge.v2(e2, e.s), e, e2);
                  // console.log("a3 = "+ a3)
                  if(a3 < a1) pt--;
                  else if(a3 > a2) ps++;
                }
              }
              ps = (ps+1)%8;
              pt = (pt+7)%8;
            }
            // console.log("allowed area is now " + ps + " - " + pt)
            for(let e2 of v.es){
              let i = v.ports.indexOf(Util.Edge.v2(e2, v));
              if(i == -1) continue;
              // console.log("aa " + ps + ", " + i + ", "  + pt+ " -> " + ((ps < pt && i >= ps && i <= pt) || (ps > pt && (i >= ps || i <= pt))) +  " and " +  (e2.occupiedStatus == 1))
              if(((ps <= pt && i >= ps && i <= pt) || (ps > pt && (i >= ps || i <= pt))) && e2.occupiedStatus != 2){
                // console.log("coloring S", ps, i, pt)
                // let ls = Geometry.objTypes.LineSegment.constr(v.p, v.ports[i].p);
                // ls.visual.objectColor = "cyan"
                // v.ports[i].p.visual.objectColor = "cyan"
                let c = 0;
                e2.costKeys = ["cs", {a: v.p, b: e.s.p, l: "s2"}];
                for(let e3 of settledAdj){
                  psa = (e.s.id == e3.s.id) ? e3.sPortUsed : e3.tPortUsed;
                  if(psa > i && !bendCosts[psa-i] || psa <= i && !bendCosts[i-psa]) console.warn("invalid cost key", psa, i, e3, e)
                  if(psa > i && ver.costs[bendCosts[psa-i]] < Number.MAX_SAFE_INTEGER) e2.costKeys.push(bendCosts[psa-i]);
                  else if(ver.costs[bendCosts[i-psa]] < Number.MAX_SAFE_INTEGER) e2.costKeys.push(bendCosts[i-psa]);
                }
                // console.log("exit "+ i +" got cost " + c)
                // console.log("using bend " + c)
                // console.log(e2.cost)
                // console.log("updatedS")
                // console.log(e2.cost)
                if(e2.occupiedStatus == 1) e2.occupiedStatus = -1;
                tempOpen.push(e2);
              }else if(e2.occupiedStatus == 1){//TODO does this belong here
                tempClosed.push(e2);
                e2.occupiedStatus = 3;
              }
            }
          }//else console.warn("s")
        }
        if(S.some(v => T.includes(v))) console.error("vtx in both S and T middle", S, T, e, sCandidate, tCandidate, e.s.settled, e.t.settled);
        if(e.t.settled){
          if(tCandidate) T = [tCandidate];
          else T = [e.t.gridNode];
          for(let e2 of T[0].es) e2.costKeys = ["cs", {a: T[0].p, b: e.t.p, l: "t1"}];
          let v = T[0];
          if(!v.settleable){
            let ps, pt;
            let settledAdj = [];
            for(let e2 of e.t.es) if(e2.settled) settledAdj.push(e2);
            if(settledAdj.length == 0){
              ps = 0;
              pt = 8;
            }else{
              settledAdj.sort((a, b) => MetroMap.Routing.edgeAngle(e.s, e.t, Util.Edge.v2(a, e.t), e, a) - MetroMap.Routing.edgeAngle(e.s, e.t, Util.Edge.v2(b, e.t), e, b));
              pt = (e.t.id == settledAdj[0].s.id) ? settledAdj[0].sPortUsed : settledAdj[0].tPortUsed;
              ps = (e.t.id == settledAdj[settledAdj.length-1].s.id) ? settledAdj[settledAdj.length-1].sPortUsed : settledAdj[settledAdj.length-1].tPortUsed;
              if((e.t.id != settledAdj[0].s.id && e.t.id != settledAdj[0].t.id) || e.t.id != settledAdj[settledAdj.length-1].s.id && e.t.id != settledAdj[settledAdj.length-1].t.id)console.warn("seems wrong")
              let a1 = MetroMap.Routing.edgeAngle(e.s, e.t, Util.Edge.v2(settledAdj[0], e.t), e, settledAdj[0]);
              let a2 = MetroMap.Routing.edgeAngle(e.s, e.t, Util.Edge.v2(settledAdj[settledAdj.length-1], e.t), e, settledAdj[settledAdj.length-1]);
              // console.log("allowed area is " + ps + " - " + pt + "between " + a1 + " and " + a2);
              for(let e2 of e.t.es){
                if(!e2.settled && e2.id != e.id){
                  let a3 = MetroMap.Routing.edgeAngle(e.s, e.t, Util.Edge.v2(e2, e.t), e, e2);
                  // console.log("a3 = "+ a3)
                  if(a3 < a1) pt--;
                  else if(a3 > a2) ps++;
                }
              }
              ps = (ps+1)%8;
              pt = (pt+7)%8;
              // console.log("allowed area is now " + ps + " - " + pt)
            }
            for(let e2 of v.es){
              let i = v.ports.indexOf(Util.Edge.v2(e2, v));
              if(i == -1) continue;
              // console.log("aa " + ps + ", " + i + ", "  + pt+ " -> " + ((ps < pt && i >= ps && i <= pt) || (ps > pt && (i >= ps || i <= pt))) +  " and " +  (e2.occupiedStatus == 1))
              if(((ps <= pt && i >= ps && i <= pt) || (ps > pt && (i >= ps || i <= pt))) && e2.occupiedStatus != 2){
                // console.log("coloring T", ps, i, pt)
                // let ls = Geometry.objTypes.LineSegment.constr(v.p, v.ports[i].p);
                // ls.visual.objectColor = "cyan"
                // v.ports[i].p.visual.objectColor = "cyan"
                let c = 0;
                e2.costKeys = ["cs", {a: v.p, b: e.t.p, l: "t2"}];
                for(let e3 of settledAdj){
                  psa = (e.t.id == e3.s.id) ? e3.sPortUsed : e3.tPortUsed;
                  if(psa > i && !bendCosts[psa-i] || psa <= i && !bendCosts[i-psa]) console.warn("invalid cost key", psa, i, e3, e)
                  if(psa > i && ver.costs[bendCosts[psa-i]] < Number.MAX_SAFE_INTEGER) e2.costKeys.push(bendCosts[psa-i]);
                  else if(ver.costs[bendCosts[i-psa]] < Number.MAX_SAFE_INTEGER) e2.costKeys.push(bendCosts[i-psa]);
                }
                // console.log("exit "+ i +" got cost " + c)

                // console.log("using bend " + c)
                // console.log(e2.cost)
                // console.log("updatedT")
                // console.log(e2.cost)

                if(e2.occupiedStatus == 1) e2.occupiedStatus = -1;
                tempOpen.push(e2);
              }else if(e2.occupiedStatus == 1){//TODO does this belong here?
                tempClosed.push(e2);
                e2.occupiedStatus = 3;
              }
            }
          }//else console.warn("t")
        }
        
        // console.log(S[0].id, T[0].id, S.length, T.length)

        // for(let v of S){
        //   // v.p.visual.objectColor = "yellow"
        //   // v.p.visual.objectDimensions = {w:10, h:3}
        //   console.log("S costs")
        //   for(let ed of v.es) console.log(ed.cost);
        // }
        // for(let v of T){
        //   // v.p.visual.objectColor = "green"
        //   // v.p.visual.objectDimensions = {w:3, h:10}
        //   console.log("T costs")
        //   for(let ed of v.es) console.log(ed.cost);
        // }
        if(S.some(v => T.includes(v))) console.error("vtx in both S and T", S, T, e, sCandidate, tCandidate, e.s.settled, e.t.settled, occupiedPS);
        ret = MetroMap.Routing.routeEdgeCleanup(ver, MetroMap.Routing.s2sDijkstra(ver, S, T, grid), e, S, T, sCandidate, tCandidate, tempOpen, tempClosed, objectsShown);
        if(Writing.measurePerformance2) Writing.times.ps[endptsSet][Writing.times.ps[endptsSet].length-1] += performance.now();
        return ret;
      },
      routeEdgeCleanup: (ver, dijkstra, e, S, T, sCandidate, tCandidate, tempOpen, tempClosed, objectsShown) => {
        let grid = Version.current.graphs.gridG;
        // console.log(dijkstra);
        if(!dijkstra[0]){
          //for(let v of S) v.p.visual.objectDimensions = {w: 15, h: 15};
          //for(let v of T) v.p.visual.objectDimensions = {w: 10, h: 10};
          // MetroMap.Routing.s2sDijkstra(S, T, grid, true);
          // console.log(S)
          // console.log(T)
          console.warn("Routing target unreachable");
          return false;
        }
        let path = dijkstra[2];
        let edgePath = dijkstra[3];
        e.settled = true;
        e.sPortUsed = path[0].ports.indexOf(path[1]);
        e.tPortUsed = path[path.length-1].ports.indexOf(path[path.length-2]);
        e.edgePath = edgePath;
        e.path = path;
        e.s.gridNode = path[0];
        if(!e.s.settled || sCandidate){
          e.s.gridNode.p.visual.objectShown = objectsShown;
          e.s.gridNode.p.visual.objectColor = Canvas.Colors.resultVtx;
          // e.s.mgToGridConnectors = Geometry.objTypes.LineSegment.constr(e.s.p, e.s.gridNode.p);
          // e.s.mgToGridConnectors.visual.objectShown = false && objectsShown && document.getElementById("cbShowMG").checked && (objectsShown || document.getElementById("cbShowLineDrawing").checked);
          // e.s.mgToGridConnectors.visual.objectColor = "grey";
        }
        e.s.settled = true;
        path[0].origStation = e.s;
        path[0].settleable = false;
        e.t.gridNode = path[path.length-1];
        if(!e.t.settled || tCandidate){
          e.t.gridNode.p.visual.objectShown = objectsShown;
          e.t.gridNode.p.visual.objectColor = Canvas.Colors.resultVtx;
          // e.t.mgToGridConnectors = Geometry.objTypes.LineSegment.constr(e.t.p, e.t.gridNode.p);
          // e.t.mgToGridConnectors.visual.objectShown =  false && objectsShown && document.getElementById("cbShowMG").checked && (objectsShown || document.getElementById("cbShowLineDrawing").checked);
          // e.t.mgToGridConnectors.visual.objectColor = "grey";
        }
        e.t.settled = true;
        path[path.length-1].origStation = e.t;
        path[path.length-1].settleable = false;
        for(let v of S){
          for(let e2 of v.es) e2.costKeys = ["cs"]; 
        }
        for(let v of T){
          for(let e2 of v.es) e2.costKeys = ["cs"]; 
        }
        for(let e2 of tempOpen){
          e2.occupiedStatus = 1;
        }
        for(let e2 of tempClosed){
          if(e2.occupiedStatus == 3) e2.occupiedStatus = 1;
        }
        for(let e2 of edgePath){
          if(!e2.ls) e2.ls = Geometry.objTypes.LineSegment.constr(ver, e2.s.p, e2.t.p);
          // e2.ls.e = e2;
          e2.ls.visual.objectColor = Canvas.Colors.resultEdge;
          e2.ls.visual.objectDimensions = 3;
          e2.ls.visual.objectShown = objectsShown;
          e2.occupiedStatus = 2;
          e2.occupiedStatusDict[e.id] = 2;
          e2.origEdge = e;
          e2.blockedDiagonals = [];
          let i, j, pNr;
          if(e2.s.ports){
            continue;
          }else{
            i = e2.s.parent.gridCoords.i;
            j = e2.s.parent.gridCoords.j;
            pNr = e2.s.parent.ports.indexOf(e2.s);
          }
          if(pNr == -1) continue;
          if(pNr == 1){
            for(let e3 of grid.gridNodes[i][j-1].ports[3].es){
              if(Util.Edge.v2(e3, grid.gridNodes[i][j-1].ports[3]) == grid.gridNodes[i+1][j].ports[7]){
                e3.occupiedStatus = 2;
                e3.occupiedStatusDict[e.id] = 2;
                e2.blockedDiagonals.push(e3);
              }
            }
          }else if(pNr == 3){
            for(let e3 of grid.gridNodes[i][j+1].ports[1].es){
              if(Util.Edge.v2(e3, grid.gridNodes[i][j+1].ports[1]) == grid.gridNodes[i+1][j].ports[5]){
                e3.occupiedStatus = 2;
                e3.occupiedStatusDict[e.id] = 2;
                e2.blockedDiagonals.push(e3);
              }
            }
          }else if(pNr == 5){
            for(let e3 of grid.gridNodes[i][j+1].ports[7].es){
              if(Util.Edge.v2(e3, grid.gridNodes[i][j+1].ports[7]) == grid.gridNodes[i-1][j].ports[3]){
                e3.occupiedStatus = 2;
                e3.occupiedStatusDict[e.id] = 2;
                e2.blockedDiagonals.push(e3);
              }
            }
          }else if(pNr == 7){
            for(let e3 of grid.gridNodes[i][j-1].ports[5].es){
              if(Util.Edge.v2(e3, grid.gridNodes[i][j-1].ports[5]) == grid.gridNodes[i-1][j].ports[1]){
                e3.occupiedStatus = 2;
                e3.occupiedStatusDict[e.id] = 2;
                e2.blockedDiagonals.push(e3);
              }
            }
          }
        }
        for(let e2 of path[0].es){
          if(e2.occupiedStatus != 2) e2.occupiedStatus = 1;
          e2.occupiedStatusDict[e.id] = 1;
        }
        for(let p of path[0].ports){
          for(let e2 of p.es){
            if(Util.Edge.v2(e2, p).parent && Util.Edge.v2(e2, p).parent.id == path[0].id){
              e2.occupiedStatus = 2;
              e2.occupiedStatusDict[e.id] = 2;
            }
          }
        }
        for(let i = 2; i < path.length-2; i += 2){
          let v = path[i];
          if(!v.ports){
            v = v.parent;
            v.settleable = false;
            for(let p of v.ports){
              for(let e2 of p.es) if(!Util.Edge.v2(e2, p).parent || Util.Edge.v2(e2, p).parent.id == v.id){
                e2.occupiedStatus = 2;
                e2.occupiedStatusDict[e.id] = 2;
              }
            }
          }
        }
        for(let e2 of path[path.length-1].es){
          if(e2.occupiedStatus != 2) e2.occupiedStatus = 1;
          e2.occupiedStatusDict[e.id] = 1;
        }
        for(let p of path[path.length-1].ports){
          for(let e2 of p.es){
            if(Util.Edge.v2(e2, p).parent && Util.Edge.v2(e2, p).parent.id == path[path.length-1].id){
              e2.occupiedStatus = 2;
              e2.occupiedStatusDict[e.id] = 2;
            }
          }
        }
        dijkstra.push(e);
        return dijkstra;
      },
      routeVertices: (ver, vArr) => {
        let es = [];
        let tempPS = [];
        for(let v of vArr){
          MetroMap.Routing.unsettleVtx(v);
          for(let e of v.es){
            if(!es.includes(e)){
              es.push(e);
              e.skipUnsettle = true;
            }
          }
        }
        for(let v of vArr){
          for(let e of v.es) e.skipUnsettle = undefined;
        }
        let success = MetroMap.Routing.routeEdges(ver, es);
        return success;
      },
      routeEdges: (ver, eArr) => {
        let newDijkstras = [];
        let gids = {};
        for(let e of eArr) if(ver.routeSettings.frozenEdges[e.id] && !gids[ver.routeSettings.frozenEdges[e.id].groupID]) gids[ver.routeSettings.frozenEdges[e.id].groupID] = true;
        // console.log(eArr.length, gids);
        for(let fe in ver.routeSettings.frozenEdges) if(gids[ver.routeSettings.frozenEdges[fe].groupID] && !eArr.includes(ver.graphs.cG.edges[fe])) eArr.push(ver.graphs.cG.edges[fe]);
        // console.log(eArr.length);
        let eO = MetroMap.Routing.recalcEdgeOrder(ver);
        eArr.sort((a, b) => eO[b.id] - eO[a.id]);
        let success = true;
        for(let e of eArr){
          if(!success) break;
          if(Writing.measurePerformance3) Writing.times.estim = MetroMap.Routing.estimateRouteEdgesDistance(Version.current, [e], []);
          // console.log(ver.routeSettings.positionedStations[e.s.contractParent.id], ver.routeSettings.positionedStations[e.t.contractParent.id])
          if(ver.routeSettings.straightEdges.some(se => se.length == e.chain.length && se.every(e2 => e.chain.includes(e2)))){
            let oldCosts = {};
            for(let ck of ["c135", "c90", "c45", "candidateRadius"]){
              oldCosts[ck] = Version.current.costs[ck];
              Version.current.costs[ck] = Number.MAX_SAFE_INTEGER;
            }
            Version.current.costs["candidateRadius"] = oldCosts["candidateRadius"]*2;
            if(Writing.measurePerformance2) Writing.times.se.push(-1*performance.now());
            newDijkstras.push(MetroMap.Routing.routeEdge(ver, e, ver.routeSettings.positionedStations[e.s.contractParent.id], ver.routeSettings.positionedStations[e.t.contractParent.id], ver.routeSettings.frozenEdges[e.id]));
            if(Writing.measurePerformance2) Writing.times.se[Writing.times.se.length-1] += performance.now();
            for(let ck of ["c135", "c90", "c45", "candidateRadius"]) Version.current.costs[ck] = oldCosts[ck];
          }else{
            if(Writing.measurePerformance2) Writing.times.nse.push(-1*performance.now());
            newDijkstras.push(MetroMap.Routing.routeEdge(ver, e, ver.routeSettings.positionedStations[e.s.contractParent.id], ver.routeSettings.positionedStations[e.t.contractParent.id], ver.routeSettings.frozenEdges[e.id]));
            if(Writing.measurePerformance2) Writing.times.nse[Writing.times.nse.length-1] += performance.now();
          }
          if(!newDijkstras[newDijkstras.length-1]) success = false;
          if(success && Writing.measurePerformance3) Writing.times.es[Writing.times.es.length-1] = [(newDijkstras[newDijkstras.length-1][3].length-1)/2, Geometry.distanceBetween(newDijkstras[newDijkstras.length-1][4].s.p, newDijkstras[newDijkstras.length-1][4].t.p), Writing.times.estim, Writing.times.es[Writing.times.es.length-1]];
        }
        if(Writing.measurePerformance) Writing.times.e = performance.now(); 
        if(success) MetroMap.Post.updateDijkstras(ver, newDijkstras);
        else{
          if(!Writing.suppressDialogue && confirm("Routing failed! Do you want to undo the last change? Otherwise the program might not function properly anymore."))
            Version.load(Version.current.versionIndex-1); //TODO this isnt necessarily the previous  state i think and mb delete a verssion from the list
        }
        return success;
      },
      routeEdgeSearch: (ver, v, gn, firstOnly) => {
        let del = true;
        if(ver.routeSettings.positionedStations[v.contractParent.id]) del = false;
        ver.routeSettings.positionedStations[v.contractParent.id] = gn;
        let newDijkstras = [];
        let eO = MetroMap.Routing.recalcEdgeOrder(ver);
        let eArr = v.es;
        eArr.sort((a, b) => eO[b.id] - eO[a.id]);
        let success = true;
        for(let e of eArr){
          if(!success) break;
          if(ver.routeSettings.straightEdges.some(se => se.length == e.chain.length && se.every(e2 => e.chain.includes(e2)))){
            let oldCosts = {};
            for(let ck of ["c135", "c90", "c45", "candidateRadius"]){
              oldCosts[ck] = Version.current.costs[ck];
              Version.current.costs[ck] = Number.MAX_SAFE_INTEGER;
            }
            Version.current.costs["candidateRadius"] = oldCosts["candidateRadius"]*2;
            // newDijkstras.push(MetroMap.Routing.routeEdge(ver, e, firstOnly && e.s.id == v.id ? gn : false, firstOnly && e.t.id == v.id ? gn : false));
            newDijkstras.push(MetroMap.Routing.routeEdge(ver, e, ver.routeSettings.positionedStations[e.s.contractParent.id], ver.routeSettings.positionedStations[e.t.contractParent.id], ver.routeSettings.frozenEdges[e.id]));

            for(let ck of ["c135", "c90", "c45", "candidateRadius"]) Version.current.costs[ck] = oldCosts[ck];
          }else{
            // newDijkstras.push(MetroMap.Routing.routeEdge(ver, e, firstOnly && e.s.id == v.id ? gn : false, firstOnly && e.t.id == v.id ? gn : false));
            newDijkstras.push(MetroMap.Routing.routeEdge(ver, e, ver.routeSettings.positionedStations[e.s.contractParent.id], ver.routeSettings.positionedStations[e.t.contractParent.id], ver.routeSettings.frozenEdges[e.id]));

          }
          if(!newDijkstras[newDijkstras.length-1]) success = false;
          firstOnly = false;
        }
        if(success) MetroMap.Post.updateDijkstras(ver, newDijkstras);
        if(del) delete ver.routeSettings.positionedStations[v.contractParent.id];
        return success;
      },
      estimateRouteVerticesDistance: (ver, vArr, settings = {}) => {
        let es = [];
        for(let v of vArr) for(let e of v.es) if(!es.includes(e)) es.push(e);
        return MetroMap.Routing.estimateRouteEdgesDistance(ver, es, vArr, settings);
      },
      estimateRouteEdgesDistance: (ver, eArr, vArr, settings = {}) => {
        let d = 0;
        for(let e of eArr){
          let sp = e.s.p;
          let tp = e.t.p;
          if(settings.positionedStations && settings.positionedStations[e.s.id]) sp = settings.positionedStations[e.s.id].p;
          else if(ver.routeSettings.positionedStations[e.s.contractParent.id]) sp = ver.routeSettings.positionedStations[e.s.contractParent.id].p;
          else if(e.s.settled && !vArr.includes(e.s)) sp = e.s.gridNode.p;
          if(settings.positionedStations && settings.positionedStations[e.t.id]) tp = settings.positionedStations[e.t.id].p;
          else if(ver.routeSettings.positionedStations[e.t.contractParent.id]) tp = ver.routeSettings.positionedStations[e.t.contractParent.id].p;
          else if(e.t.settled && !vArr.includes(e.t)) tp = e.t.gridNode.p;
          d += Geometry.distanceBetween(sp, tp)/Version.current.graphs.gridG.D;
        }
        // console.log(Math.round(d))
        return d;
      },
      findClosestGridNode: (ver, v) => {
        let grid = Version.current.graphs.gridG;
        let minD = Number.MAX_SAFE_INTEGER;
        let minV;
        for(let i = 0; i < grid.gridNodes.length; i++){
          for(let j = 0; j < grid.gridNodes[0].length; j++){
            let u = grid.gridNodes[i][j];
            if(u.settleable && Geometry.distanceBetween(v.p, u.p) < minD){
              minD = Geometry.distanceBetween(v.p, u.p);
              minV = u;
            }
          }
        }
        return minV;
      },
      aStarHeuristic: (ver, s, Tsides) => {
        let gn = s.ports ? s : s.parent;
        if(!gn) return MetroMap.Routing.aStarHeuristic(ver, Util.Edge.v2(s.es[0], s), Tsides); //s2sV
        let xDiff, yDiff, cost;
        if(gn.gridCoords.i >= Tsides.l && gn.gridCoords.i <= Tsides.r) xDiff = 0;
        else if(gn.gridCoords.i < Tsides.l) xDiff = Tsides.l - gn.gridCoords.i;
        else xDiff = gn.gridCoords.i - Tsides.r;
        if(gn.gridCoords.j >= Tsides.t && gn.gridCoords.j <= Tsides.b) yDiff = 0;
        else if(gn.gridCoords.j < Tsides.t) yDiff = Tsides.t - gn.gridCoords.j;
        else yDiff = gn.gridCoords.j - Tsides.b;
        let diagPart = Math.min(xDiff, yDiff);
        let aaPart = Math.max(xDiff, yDiff) - diagPart;
        cost = ver.costs["ch"] * (diagPart+aaPart) + ver.costs["c180"] * Math.max(0, diagPart+aaPart-1);
        if(diagPart != 0 && aaPart != 0) cost += ver.costs["c135"];
        return cost;
      },
      s2sDijkstra: (ver, S, T, g, colorVisited = false) => {
        if(Writing.measurePerformance3) Writing.times.es.push(-1*performance.now());
        // console.warn(S[0].id, T[0].id, S.length, T.length)
        // if(S[0].id == 1350 && T[0].id == 1620) colorVisited = true;
        // if(S[0].id == 1350 && T[0].id == 1620){
        //   for(let t of S) for(let e of t.es) console.log(e.cost)
        //   console.log("................")
        //   for(let t of T) for(let e of t.es) console.log(e.cost)
        // }
        let useAStar = false;
        let excessStepsAStar = 0;
        let s2sV = Util.Graph.addVertex(g);
        s2sV.p = Geometry.objTypes.Point.constr(ver, 0, 0);
        let sortTime = 0;
        let inLoopTime = 0;
        let startTime = Date.now();
        let unvisited = [[s2sV], []];; //outer sorted by d, inner by id
        let Tsides = {t: Number.MAX_SAFE_INTEGER, h: 0, r: Number.MIN_SAFE_INTEGER, b: Number.MIN_SAFE_INTEGER, l: Number.MAX_SAFE_INTEGER}; //top, right, bottom, left
        let tCount = 0;
        let minDistanceInT = Number.MAX_SAFE_INTEGER;
        if(useAStar){
          for(let t of T){
            Tsides.t = Math.min(t.gridCoords.j, Tsides.t);
            Tsides.r = Math.max(t.gridCoords.i, Tsides.r);
            Tsides.b = Math.max(t.gridCoords.j, Tsides.b);
            Tsides.l = Math.min(t.gridCoords.i, Tsides.l);
          }
        }
        if(!g.s2sDijkstraIDSortedVtcs){
          g.s2sDijkstraIDSortedVtcs = [];
          for(let v in g.vertices){
            v = g.vertices[v];
            v.dijkstra = {d: Number.MAX_SAFE_INTEGER, h: 0, p: undefined, pe: undefined, visited: false, inT: false};
            if(v != s2sV){
              let i = Util.binarySearch(v, unvisited[1], (a, b) => a.id-b.id, 0, unvisited[1].length)[1];
              unvisited[1].splice(i, 0, v);
              g.s2sDijkstraIDSortedVtcs.splice(i, 0, v);
            }
          }
          if(useAStar) s2sV.dijkstra.h = S.reduce((acc, s) => Math.min(acc, MetroMap.Routing.aStarHeuristic(ver, s, Tsides)), Number.MAX_SAFE_INTEGER);
          s2sV.dijkstra.d = s2sV.dijkstra.h;
        }else{
          for(let v of g.s2sDijkstraIDSortedVtcs){
            v.dijkstra = {d: Number.MAX_SAFE_INTEGER, h: 0, p: undefined, pe: undefined, visited: false, inT: false};
            unvisited[1].push(v);
          }
          s2sV.dijkstra = {d: 0, h: useAStar ? S.reduce((acc, s) => Math.min(acc, MetroMap.Routing.aStarHeuristic(ver, s, Tsides)), Number.MAX_SAFE_INTEGER) : 0, p: undefined, pe: undefined, visited: false, inT: false};
          if(useAStar) s2sV.dijkstra.d = s2sV.dijkstra.h;
        }
        for(let v of S){
          let e2 = Util.Graph.addEdge(g, s2sV.id, v.id);
          e2.costKeys = ["min"];
        }
        for(let v of T){
          v.dijkstra.inT = true;
        }
        let initTime = Date.now()-startTime;
        while(unvisited.length > 0){
          let loopStart = Date.now();
          let u = unvisited[0].length == 1 ? unvisited.shift()[0] : unvisited[0].shift();
          if(u.dijkstra.d >= Number.MAX_SAFE_INTEGER){
            // console.log("cheapest next nodes has inf cost, cancelling")
            //for(let i = 0; i < Math.min(6000, unvisited.length);i++)if(unvisited[i].dijkstra.d < Number.MAX_SAFE_INTEGER) console.log("cheaper not 1st:" + i +" = " + unvisited[i].dijkstra.d);
            break;
          }
          u.dijkstra.visited = true;
          if(colorVisited){
            u.p.visual.objectColor = "black"
          }
          // if(useAStar && minDistanceInT < u.dijkstra.d - u.dijkstra.h) break;
          if(useAStar && tCount >= T.length){
            excessStepsAStar--;
            if(excessStepsAStar <= 0) break;
          }
          if(u.dijkstra.inT){
            if(!useAStar) break;
            // minDistanceInT = Math.min(minDistanceInT, u.dijkstra.d - u.dijkstra.h);
            tCount++;
            u.dijkstra.inT = false;
            //if(tCount == T.length) break;

            // console.log("finsished!!");
            //console.log(T)
            
          }
          if(u.ports && !T.includes(u) && !u.dijkstra.pe.costKeys.includes("min")) {
            // console.log("stopped from going to sink", u.dijkstra.d,u,u.dijkstra.pe.costKeys);u.p.visual.objectShown=true; 
            continue;}
          inLoopTime += (Date.now()-loopStart);
          for(let e of u.es){
            loopStart = Date.now();
            if(colorVisited){
              if(!e.ls) e.ls = Geometry.objTypes.LineSegment.constr(ver, e.s.p, e.t.p);
              e.ls.visual.objectColor = "black"
            }
            let v = Util.Edge.v2(e, u);
            inLoopTime += (Date.now()-loopStart);
            if((!v.dijkstra.visited || useAStar) && Util.Edge.calcCost(e) < Number.MAX_SAFE_INTEGER && e.occupiedStatus <= 0){
              let d = Util.Edge.calcCost(e) + u.dijkstra.d;
              if(useAStar){
                if(v.dijkstra.h == 0) v.dijkstra.h = MetroMap.Routing.aStarHeuristic(ver, v, Tsides);
                d += v.dijkstra.h - u.dijkstra.h;
              }
              //let d = 1 + u.dijkstra.d;
              if(ver.routeSettings.disallowBends){
                let gc = v.parent ? v.parent.gridCoords : v.gridCoords;
                let gc2 = S[0].gridCoords;

                if(gc && gc.i != gc2.i && gc.j != gc2.j && gc.i+gc.j != gc2.i+gc2.j && gc.j-gc.i != gc2.j-gc2.i) d = Number.MAX_SAFE_INTEGER;
              }
              if(d < v.dijkstra.d){
                let sortStart = Date.now();
                let i;
                if(!v.dijkstra.visited){
                  i = Util.binarySearch([v], unvisited, (a, b) => a[0].dijkstra.d-b[0].dijkstra.d, 0, unvisited.length);
                  // let splicedV;
                  // if(!i[0]){console.log("+++++++++++++++++++++");for(let un of unvisited)console.log(un[0].dijkstra.d + "  -  " + un.length);console.log(i);unv=unvisited;return;}
                  // i=i[1]
                  // if(unvisited[i][unvisited[i].length-1].dijkstra.d != v.dijkstra.d) console.warn("what a mess");
                  // if(unvisited[i].length == 1){ console.log("remm" + i);splicedV=unvisited.splice(i, 1)}
                  // else{ console.log("////////" + unvisited[i][0].dijkstra.d + " - " + unvisited[i].length);splicedV= unvisited[i].splice(binarySearch(v, unvisited[i], (a, b) => a.id-b.id, 0, unvisited[i].length)[1], 1)};
                  // if(!unvCheck(unvisited)) {console.warn("AFTER REMOVE"); return}
                  // if(v.id != splicedV[0].id){ console.log(unvisited[i]); console.warn("NON MATCHIN IDS" + binarySearch(v, unvisited[i], (a, b) => a.id-b.id, 0, unvisited[i].length) + " d=" + v.dijkstra.d + " ,id="+v.id)}
                  if(!i[0]){console.log("+++++++++++++++++++++");for(let un of unvisited)console.log(un[0].dijkstra.d + "  -  " + un.length);console.log(i);unv=unvisited;return;}
                  let splicedV;
                  i=i[1]
                  if(unvisited[i][unvisited[i].length-1].dijkstra.d != v.dijkstra.d) console.log("what a mess");
                  if(unvisited[i].length == 1) splicedV = unvisited.splice(i, 1);
                  else splicedV=unvisited[i].splice(Util.binarySearch(v, unvisited[i], (a, b) => a.id-b.id, 0, unvisited[i].length)[1], 1);
                  // if(!unvCheck(unvisited)) {console.log("AFTER REMOVE"); return}
                  //if(v.dijkstra.d != unvisited[i[1]].dijkstra.d){
                    // console.log("pffffffffffffffffff" + i + " (" + unvisited.indexOf(v)+") ... " + v.dijkstra.d  +  " - " +  unvisited[i[1]-1].dijkstra.d+  ", " +  unvisited[i[1]].dijkstra.d)
                    // binarySearch(v, unvisited, (a, b) => a.dijkstra.d-b.dijkstra.d, 0, unvisited.length, true);
                    // unv = unvisited;
                    // return [false, false];
                    //}  
                  // i = i[1];
                  if(i > unvisited.length) i--;
                }
                v.dijkstra.d = d;
                v.dijkstra.p = u;
                v.dijkstra.pe = e;
                // console.log(d + " at "  + i);
                // unvisited.splice(i, 1);
                // while(i > 0 && unvisited[i].dijkstra.d > d) i--;
                // unvisited.splice(i, 0, v);
                // let ind = binarySearch([v], unvisited, (a, b) => a[0].dijkstra.d-b[0].dijkstra.d, 0, i);
                // if(ind[0]) {console.log("***********");console.log(v.id); console.log(binarySearch(v, unvisited[ind[1]], (a, b) => a.id-b.id, 0, unvisited[ind[1]].length));unvisited[ind[1]].splice(binarySearch(v, unvisited[ind[1]], (a, b) => a.id-b.id, 0, unvisited[ind[1]].length)[1], 0, v);for(let un of unvisited[ind[1]])console.log(un.dijkstra.d + " id=" + un.id);}
                // else{unvisited.splice(ind[1], 0, [v]);console.log("---------------");for(let un of unvisited)console.log(un[0].dijkstra.d + "  -  " + un.length);}
                // if(!unvCheck(unvisited)) {console.warn("AFTER INSERT"); unv = unvisited;return}
                let ind = Util.binarySearch([v], unvisited, (a, b) => a[0].dijkstra.d-b[0].dijkstra.d, 0, v.dijkstra.visited ? unvisited.length : i);
                if(ind[0]) {unvisited[ind[1]].splice(Util.binarySearch(v, unvisited[ind[1]], (a, b) => a.id-b.id, 0, unvisited[ind[1]].length)[1], 0, v);}
                else{unvisited.splice(ind[1], 0, [v]);}
                // if(!unvCheck(unvisited)) {console.log("AFTER INSERT"); unv = unvisited;return}
                // if(ind > 0 && unvisited[ind-1].dijkstra.d>unvisited[ind].dijkstra.d) console.log("ALARM" +ind + " : " +unvisited[ind-1].dijkstra.d + ", " + v.dijkstra.d  + ", " + unvisited[ind+1].dijkstra.d )
                // if(ind < unvisited.length-1 && unvisited[ind+1].dijkstra.d<unvisited[ind].dijkstra.d) console.log("2ALARM" +ind + " : " +unvisited[ind-1].dijkstra.d + ", " + v.dijkstra.d  + ", " + unvisited[ind+1].dijkstra.d )
                sortTime += (Date.now()-sortStart);
              }
            }
          }
        }
        let cleanupS = Date.now();
        let minD = Number.MAX_SAFE_INTEGER;
        let minV = T[0];
        for(let t of T){
          if(t.dijkstra.d - t.dijkstra.h < minD){
            minD = t.dijkstra.d - t.dijkstra.h;
            minV = t;
          }
        }
        let cost = minV.dijkstra.d - minV.dijkstra.h - Util.Edge.calcCost(s2sV.es[0]);
        let path = [minV];
        let edgePath = [];
        let v = minV;
        while(v.dijkstra.p && v.dijkstra.p != s2sV){
          path.unshift(v.dijkstra.p);
          edgePath.unshift(v.dijkstra.pe);
          v = v.dijkstra.p;
        }
        let reachable = true;
        if(!v.dijkstra.p) reachable = false;
        if(reachable && path.length == 1){
          for(let v of S){
            v.p.visual.objectShown = true;
            v.p.visual.objectColor = "lime";
          }
          for(let v of T){
            v.p.visual.objectShown = true;
            v.p.visual.objectColor = "pink";
          }
          minV.p.visual.highlightShown = true
          Canvas.redraw();
          console.error("short path...", path, v, minV, minV.dijkstra.d, v.dijkstra.p, S.indexOf(minV), T.indexOf(minV));
        }
        Util.Graph.removeVertex(g, s2sV);
        if(Writing.measurePerformance3) Writing.times.es[Writing.times.es.length-1] += performance.now();
        // console.log("s2sd took a total of " + (Date.now()-startTime) + "ms of which sorting: " + sortTime + "ms, init: " + initTime + "ms, cleanup: " + (Date.now()-cleanupS) + "ms , inLoop: " + inLoopTime + "ms")
        return [reachable, cost, path, edgePath];
      }
    },
    GraphCreation: {
      deg2Contract: (ver, g, objectsShown = ver.checkBoxes.cbShowCG) => {
        let g2 = Util.Graph.constr(ver, "cG");
        let v;
        let unvisited = [];
        for(let v2 in g.vertices){
          v2 = g.vertices[v2];
          v2.contract = {visited: false};
          if(ver.routeSettings.contractAllowed[v2.id] > 1){
            if(unvisited.length == 0) unvisited.push(v2);
            let v3 = Util.Graph.addVertex(g2);
            v3.p = Geometry.objTypes.Point.constr(ver, v2.p.x, v2.p.y);
            v3.p.visual.objectColor = Canvas.Colors.currentVtx;
            v3.p.visual.objectShown = objectsShown;
            v3.p.visual.objectDimensions = {w:4, h:4};
            v2.contract.v = v3;
            v3.contractParent = v2;
          }
        }
        for(let e in g.edges){
          g.edges[e].contract = {visited: false};
        }
        while(unvisited.length > 0){ 
          v = unvisited.pop();
          v.contract.visited = true;
          for(let e of v.es){
            let u = Util.Edge.v2(e, v);
            if(e.contract.visited) continue;
            //if(u.contract.visited) continue;
            let chain = [e];
            e.contract.visited = true;
            let lines = e.lines;
            while(!u.contract.v){
              e = u.es[0].id == e.id ? u.es[1] : u.es[0];
              if(e.lines.length != lines.length || !e.lines.every(l => lines.includes(l))) break;
              chain.push(e);
              u.contract.visited = true;
              e.contract.visited = true;
              u = Util.Edge.v2(e, u);
            }
            if(u.id == v.id){
              if(chain.length < 3) console.warn("short chain at self edge");
              else{
                let m = Math.floor(chain.length/3);
                let m2 = Math.floor(2*chain.length/3);
                let v2;
                if(chain[m].s.id == chain[m-1].t.id) v2 = chain[m].s;
                else if(chain[m].s.id == chain[m-1].s.id) v2 = chain[m].s;
                else if(chain[m].t.id == chain[m-1].s.id) v2 = chain[m].t;
                else if(chain[m].t.id == chain[m-1].t.id) v2 = chain[m].t;
                let v3 = Util.Graph.addVertex(g2);
                v3.p = Geometry.objTypes.Point.constr(ver, v2.p.x, v2.p.y);
                v3.p.visual.objectColor = Canvas.Colors.currentVtx;
                v3.p.visual.objectShown = objectsShown;
                v3.p.visual.objectDimensions = {w:4, h:4};
                v2.contract.v = v3;
                v3.contractParent = v2;
                let e2 = Util.Graph.addEdge(g2, v.contract.v.id, v3.id);
                e2.chain = chain.slice(0, m);
                e2.lines = lines;
                e2.ls = Geometry.objTypes.LineSegment.constr(ver, e2.s.p, e2.t.p);
                e2.ls.visual.objectColor = Canvas.Colors.currentEdge;
                e2.ls.visual.objectShown = objectsShown;
                e2.ls.visual.objectDimensions = 2;
                if(chain[m2].s.id == chain[m2-1].t.id) v2 = chain[m2].s;
                else if(chain[m2].s.id == chain[m2-1].s.id) v2 = chain[m2].s;
                else if(chain[m2].t.id == chain[m2-1].s.id) v2 = chain[m2].t;
                else if(chain[m2].t.id == chain[m2-1].t.id) v2 = chain[m2].t;
                let v4 = Util.Graph.addVertex(g2);
                v4.p = Geometry.objTypes.Point.constr(ver, v2.p.x, v2.p.y);
                v4.p.visual.objectColor = Canvas.Colors.currentVtx;
                v4.p.visual.objectShown = objectsShown;
                v2.contract.v = v4;
                v4.contractParent = v2;
                e2 = Util.Graph.addEdge(g2, v3.id, v4.id);
                e2.chain = chain.slice(m, m2);
                e2.lines = lines;
                e2.ls = Geometry.objTypes.LineSegment.constr(ver, e2.s.p, e2.t.p);
                e2.ls.visual.objectColor = Canvas.Colors.currentEdge;
                e2.ls.visual.objectShown = objectsShown;
                e2.ls.visual.objectDimensions = 2;
                e2 = Util.Graph.addEdge(g2, v4.id, u.contract.v.id);
                e2.chain = chain.slice(m2);
                e2.lines = lines;
                e2.ls = Geometry.objTypes.LineSegment.constr(ver, e2.s.p, e2.t.p);
                e2.ls.visual.objectColor = Canvas.Colors.currentEdge;
                e2.ls.visual.objectShown = objectsShown;
                e2.ls.visual.objectDimensions = 2;
                if(!u.contract.visited){
                  unvisited.push(u);
                }
              }
            }else if(u.contract.v.es.some(e => Util.Edge.v2(e, u.contract.v).id == v.contract.v.id)){
              if(chain.length < 2) console.warn("short chain at multiedge");
              else{
                let m = Math.floor(chain.length/2);
                let v2;
                if(chain[m].s.id == chain[m-1].t.id) v2 = chain[m].s;
                else if(chain[m].s.id == chain[m-1].s.id) v2 = chain[m].s;
                else if(chain[m].t.id == chain[m-1].s.id) v2 = chain[m].t;
                else if(chain[m].t.id == chain[m-1].t.id) v2 = chain[m].t;
                let v3 = Util.Graph.addVertex(g2);
                v3.p = Geometry.objTypes.Point.constr(ver, v2.p.x, v2.p.y);
                v3.p.visual.objectColor = Canvas.Colors.currentVtx;
                v3.p.visual.objectShown = objectsShown;
                v3.p.visual.objectDimensions = {w:4, h:4};
                v2.contract.v = v3;
                v3.contractParent = v2;
                let e2 = Util.Graph.addEdge(g2, v.contract.v.id, v3.id);
                e2.chain = chain.slice(0, m);
                e2.lines = lines;
                e2.ls = Geometry.objTypes.LineSegment.constr(ver, e2.s.p, e2.t.p);
                e2.ls.visual.objectColor = Canvas.Colors.currentEdge;
                e2.ls.visual.objectShown = objectsShown;
                e2.ls.visual.objectDimensions = 2;
                console.log(v)
                console.log(e2.chain)
                console.log(v2)
                
                e2 = Util.Graph.addEdge(g2, v3.id, u.contract.v.id);
                e2.chain = chain.slice(m);
                e2.lines = lines;
                e2.ls = Geometry.objTypes.LineSegment.constr(ver, e2.s.p, e2.t.p);
                e2.ls.visual.objectColor = Canvas.Colors.currentEdge;
                e2.ls.visual.objectShown = objectsShown;
                e2.ls.visual.objectDimensions = 2;
                console.log(e2.chain)
                console.log(u)
                if(!u.contract.visited){
                  unvisited.push(u);
                }
              }
            }else{
              let e2 = Util.Graph.addEdge(g2, v.contract.v.id, u.contract.v.id);
              e2.chain = chain;
              e2.lines = lines;
              e2.ls = Geometry.objTypes.LineSegment.constr(ver, e2.s.p, e2.t.p);
              e2.ls.visual.objectColor = Canvas.Colors.currentEdge;
              e2.ls.visual.objectShown = objectsShown;
              e2.ls.visual.objectDimensions = 2;
              if(!u.contract.visited){
                unvisited.push(u);
              }
            }
          }
        }
        return g2;
      },
      initCG: ver => {
        for(let v in ver.graphs.mG.vertices){
          let v2 = ver.graphs.mG.vertices[v];
          ver.routeSettings.contractAllowed[v] = ["londonX", "sydneyX"].includes(MetroMap.location) ? 0 : 3;
          if(v2.es.length != 2 || (v2.es.length == 2 && (v2.es[0].lines.length != v2.es[1].lines.length || !v2.es[0].lines.every(l => v2.es[1].lines.includes(l)))))
            ver.routeSettings.contractAllowed[v] = 2;
        }
        ver.graphs.cG = MetroMap.GraphCreation.deg2Contract(ver, ver.graphs.mG);
      },
      octiGrid: (ver, startX, startY, w, h, stepSize, showDrawing = false) => {
        let portOffset = 0.1*stepSize;
        let bendCosts = [null, ver.costs.c45, ver.costs.c90, ver.costs.c135, ver.costs.c180, ver.costs.c135, ver.costs.c90, ver.costs.c45];
        let g = Util.Graph.constr(ver, "gridG");
        g.D = stepSize;
        let prevCol = [];
        let currCol = [];
        g.gridNodes = [];
        for(let i = 0; (i-1)*stepSize <= w; i++){
          let prev;
          g.gridNodes.push([]);
          for(let j = 0; (j-1)*stepSize <= h; j++){
            let v = Util.Graph.addVertex(g);
            v.p = Geometry.objTypes.Point.constr(ver, startX+i*stepSize, startY+j*stepSize);
            v.p.visual.objectShown = showDrawing;
            v.settleable = true;
            //console.log(startX+i*(endX-startX)/dim + ", " + startY+j*(endY-startY)/dim)
            v.ports = [];
            g.gridNodes[i].push(v);
            v.gridCoords = {i: i, j: j};
            for(let k = 0; k < 8; k++) v.ports.push(Util.Graph.addVertex(g));
            v.ports[0].p = Geometry.objTypes.Point.constr(ver, v.p.x, v.p.y-portOffset);
            v.ports[1].p = Geometry.objTypes.Point.constr(ver, v.p.x+portOffset, v.p.y-portOffset);
            v.ports[2].p = Geometry.objTypes.Point.constr(ver, v.p.x+portOffset, v.p.y);
            v.ports[3].p = Geometry.objTypes.Point.constr(ver, v.p.x+portOffset, v.p.y+portOffset);
            v.ports[4].p = Geometry.objTypes.Point.constr(ver, v.p.x, v.p.y+portOffset);
            v.ports[5].p = Geometry.objTypes.Point.constr(ver, v.p.x-portOffset, v.p.y+portOffset);
            v.ports[6].p = Geometry.objTypes.Point.constr(ver, v.p.x-portOffset, v.p.y);
            v.ports[7].p = Geometry.objTypes.Point.constr(ver, v.p.x-portOffset, v.p.y-portOffset);
            for(let k = 0; k < 8; k++){
              v.ports[k].p.visual.objectDimensions = {w: 1, h: 1};
              v.ports[k].p.visual.objectShown = showDrawing;
              v.ports[k].parent = v;
              let e = Util.Graph.addEdge(g, v.id, v.ports[k].id)//.ls = Geometry.objTypes.LineSegment.constr(v.p, v.ports[k].p);
              e.costKeys = ["cs"];
              for(let k2 = k+1; k2 < 8; k2++){
                e = Util.Graph.addEdge(g, v.ports[k].id, v.ports[k2].id)//.ls = Geometry.objTypes.LineSegment.constr(v.ports[k].p, v.ports[k2].p);
                e.costKeys = [[null, "c45", "c90", "c135", "c180", "c135", "c90", "c45"][k2-k]];
              }
            }
            if(i > 0){
              let e = Util.Graph.addEdge(g, v.ports[6].id, prevCol[j].ports[2].id);
              // e.ls = Geometry.objTypes.LineSegment.constr(ver, v.ports[6].p, prevCol[j].ports[2].p);
              e.costKeys = ["ch"];
              if(j > 0){
                e = Util.Graph.addEdge(g, v.ports[7].id, prevCol[j-1].ports[3].id);
                // e.ls = Geometry.objTypes.LineSegment.constr(ver, v.ports[7].p, prevCol[j-1].ports[3].p);
                e.costKeys = ["ch"];
              }
              if(j*stepSize < h){
                e = Util.Graph.addEdge(g, v.ports[5].id, prevCol[j+1].ports[1].id);
                // e.ls = Geometry.objTypes.LineSegment.constr(ver, v.ports[5].p, prevCol[j+1].ports[1].p);
                e.costKeys = ["ch"];
              }
            }
            if(j > 0){
              let e = Util.Graph.addEdge(g, v.ports[0].id, prev.ports[4].id);
              // e.ls = Geometry.objTypes.LineSegment.constr(ver, v.ports[0].p, prev.ports[4].p);
              e.costKeys = ["ch"];
            }
            currCol.push(v);
            prev = v;
          }
          prevCol = currCol;
          currCol = [];
        }
        g.simpleVis = [];
        for(let i = 0; (i-1)*stepSize <= w; i++) g.simpleVis.push(Geometry.objTypes.LineSegment.constr(ver, g.gridNodes[i][0].p, g.gridNodes[i][g.gridNodes[i].length-1].p));
        for(let i = 0; (i-1)*stepSize < h; i++) g.simpleVis.push(Geometry.objTypes.LineSegment.constr(ver, g.gridNodes[0][i].p, g.gridNodes[g.gridNodes.length-1][i].p));
        for(let ls of g.simpleVis){
          ls.simpleVisLine = true;
          ls.visual.objectColor = "black";
          ls.visual.objectDimensions = 0.1;
          ls.visual.objectShown = ver.checkBoxes.cbShowGrid;
        }
        return g;
      },
      denseGraph: (ver) => {
        let xs = [0, -1, 0, 1, -1, 1, -1, 0, 1, 0, -1.5];
        let ys = [0, -1, -1, -1, 0, 0, 1, 1, 1, -1.5, 1.3];
        let es = [[0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [1, 2], [1, 9], [2, 9], [3, 9], [4, 6], [4, 10], [6, 10], [8, 10]];
        let g = Util.Graph.constr(ver, "mG");
        let vtcs = [];
        for(let i = 0; i < xs.length; i++){
          let v1 = Util.Graph.addVertex(g);
          vtcs.push(v1);
          v1.p = Geometry.objTypes.Point.constr(ver, xs[i], ys[i]);
          v1.p.visual.objectColor = Canvas.Colors.origVtx;
          v1.p.visual.objectDimensions = {w: 8, h: 8};
          // if(i > 0){
          //   let e = g.addEdge(vtcs[i-1].id, v1.id);
          //   e.ls = Geometry.objTypes.LineSegment.constr(vtcs[i-1].p, v1.p);
          // }
        }
        for(let i = 0; i < es.length; i++){
          let e = Util.Graph.addEdge(g, vtcs[es[i][0]].id, vtcs[es[i][1]].id);
          let ls = Geometry.objTypes.LineSegment.constr(ver, vtcs[es[i][0]].p, vtcs[es[i][1]].p);
          ls.visual.objectDimensions = 3;
          e.ls = ls;
          // ls.e = e;
          e.lines = [0];
        }
        for(let v of vtcs){
          let ls = [];
          for(let e of v.es){
            for(let l of e.lines) if(!ls.includes(l)) ls.push(l);
          }
          v.ldeg = ls.length;
        }

        Canvas.viewport = {
          x: -1.7,
          y: -1.7,
          w: 3.5,
          h: 3.5
        }
        return g;
      },
      basicGraph: (ver) => {
        let xs = [0.63333, -1, 0, 1];
        let ys = [-0.55327, -1, -1, 1];
        let es = [[0, 1], [0, 2], [0, 3]];
        // xs = [0.63333, -1];
        // ys = [-0.55327, -1];
        // es = [[0, 1]];
        let g = Util.Graph.constr(ver, "mG");
        let vtcs = [];
        for(let i = 0; i < xs.length; i++){
          let v1 = Util.Graph.addVertex(g);
          vtcs.push(v1);
          v1.p = Geometry.objTypes.Point.constr(ver, xs[i], ys[i]);
          v1.p.visual.objectColor = Canvas.Colors.origVtx;
          v1.p.visual.objectDimensions = {w: 8, h: 8};
          // if(i > 0){
          //   let e = g.addEdge(vtcs[i-1].id, v1.id);
          //   e.ls = Geometry.objTypes.LineSegment.constr(vtcs[i-1].p, v1.p);
          // }
        }
        for(let i = 0; i < es.length; i++){
          let e = Util.Graph.addEdge(g, vtcs[es[i][0]].id, vtcs[es[i][1]].id);
          let ls = Geometry.objTypes.LineSegment.constr(ver, vtcs[es[i][0]].p, vtcs[es[i][1]].p);
          ls.visual.objectDimensions = 3;
          e.ls = ls;
          // ls.e = e;
          e.lines = [0];
        }
        for(let v of vtcs){
          let ls = [];
          for(let e of v.es){
            for(let l of e.lines) if(!ls.includes(l)) ls.push(l);
          }
          v.ldeg = ls.length;
        }
        Canvas.viewport = {
          x: -1.7,
          y: -1.7,
          w: 3.5,
          h: 3.5
        }
        return g;
      },
      rebuildGrid: () => {//TODO maybe scale set positions&frozen edges
        let sT = Date.now();
        let gr = 1*document.getElementById("GridResIn").innerText;
        let minX = Number.MAX_SAFE_INTEGER;
        let minY = Number.MAX_SAFE_INTEGER;
        let maxX = Number.MIN_SAFE_INTEGER;
        let maxY = Number.MIN_SAFE_INTEGER;
        for(let v in Version.current.graphs.mG.vertices){
          v = Version.current.graphs.mG.vertices[v];
          minX = Math.min(minX, v.p.x);
          minY = Math.min(minY, v.p.y);
          maxX = Math.max(maxX, v.p.x);
          maxY = Math.max(maxY, v.p.y);
        }
        for(let ls of Version.current.graphs.gridG.simpleVis) Geometry.removeGeoObject(Version.current, ls);
        Util.Graph.removeAll(Version.current.graphs.gridG);
        Version.current.costs["gr"] = gr;
        Version.current.graphs.gridG = MetroMap.GraphCreation.octiGrid(Version.current, minX-0.1*(maxX-minX), minY-0.1*(maxY-minY), 1.2*(maxX-minX), 1.2*(maxY-minY), gr*Version.current.graphs.mG.averageAdjacentDistances, false);
        MetroMap.Routing.recalcAll(Version.current);
        Version.current.results.cost = MetroMap.Post.recalcCost(Version.current);
        Version.current.results.calcTime = Date.now()-sT;
        Version.edited("Changed Grid Resolution");
      },
      loadLocation: (sel) => {
        console.log("loading location")
        MetroMap.location = sel.value;
        Version.setup();
        Version.nextFreeIndex = 1;
        Util.updateCosts();
        document.getElementById("versionList").innerHTML = "";
        let gr = {"wurzburg": 0.75, "wien": 0.75, "washington": 0.6, "montreal": 0.75, "london": 0.5, "sydney": 0.75}[sel.value];//syd 3.5 when no contr
        let cm = {"wurzburg": 0.5, "wien": 0.5, "washington": 0.5, "montreal": 0.5, "london": 0.5, "sydney": 3}[sel.value];//syd 3.5 when no contr
        Version.current.costs["gr"] = gr;
        Version.current.costs["cm"] = cm;
        document.getElementById("GridResIn").innerText = gr;
        document.getElementById("MoveCostIn").innerText = cm;
        if(sel.value == "wurzburg"){
          let sT = Date.now();
          Version.current.graphs.mG = MetroMap.GraphCreation.wurzburg(Version.current);
          MetroMap.GraphCreation.initCG(Version.current);
          document.title = "Metro Maps - wurzburg";
          MetroMap.Routing.recalcAll(Version.current);
          Version.current.results.cost = MetroMap.Post.recalcCost(Version.current);
          Version.current.results.calcTime = Date.now()-sT;
          Version.edited("Start");
        }else{
          MetroMap.GraphCreation.fromGML(Version.current, sel.value); 
        }
      },
      wurzburg: (ver, objectsShown = ver.checkBoxes.cbShowMG) => {
        let xs = [9.892565944337413, 9.898180359305982, 9.903823485671403, 9.911295078447145, 9.915912978438719, 9.917905987353482, 9.920681790194713, 9.925196486011911, 9.928421129649296, 9.929202949951478, 9.932240657725831, 9.935058326411392, 9.936315275365459, 9.94169649679777, 9.943950437021352, 9.94749442942476, 9.951971153894771, 9.954113127325392, 9.95396318918525, 9.95123801480691, 9.948362902288425, 9.9448714855965, 9.930971144760564, 9.928921368799864, 9.928602947987125, 9.929116320317862, 9.929457021304083, 9.931795511179546, 9.933642908897742, 9.93530928020637, 9.93629424954256, 9.938279041663915, 9.938630882736886, 9.938743211944873, 9.925046475294385, 9.925366752788236,9.926532748534, 9.928567671045709, 9.937325635906802, 9.941474389878003, 9.94663874842393, 9.944629819447945, 9.943017291891904, 9.954403388883765, 9.957975643366005, 9.961010388662903, 9.960483091223734, 9.95747743078739, 9.96517456518463];
        let ys = [-49.79496414115665, -49.794328161861756, -49.79432913548603, -49.79431842561887, -49.79437684307609, -49.79694136944713, -49.79793349259524, -49.79799093642815, -49.79664149316685, -49.796830376278464, -49.797467126561976, -49.800589539649266, -49.80034905445041, -49.799412427886644, -49.801709207578845, -49.80246279277673, -49.80232843262516, -49.80211520890641, -49.80148040587148, -49.8016245022659, -49.801809490880345, -49.80185 /*-49.80200811023483 changed for planarity*/, -49.79416641497743, -49.793235289393905, -49.79236172092519, -49.790453981070556, -49.79013277523616, -49.78686408811781, -49.7840196526363, -49.78159297040759, -49.77975114273279, -49.77679066468106, -49.77630421422657, -49.774246083200914, -49.78614183916107, -49.78290193060008, -49.77922198861279, -49.774763168894104, -49.76920148058828, -49.767394001514404, -49.76600334735278, -49.76242273780564, -49.75948453992726, -49.74740961423908, -49.74622876504447, -49.74183214414333, -49.73888002115648, -49.73703231291601, -49.72209417060423];
        let es = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12], [12, 13], [13, 14], [14, 15], [15, 16], [16, 17], [17, 18], [18, 19], [19, 20], [20, 21], [21, 14], [9, 22], [10, 22], [22, 23], [23, 24], [24, 25], [25, 26], [26, 27], [27, 28], [28, 29], [29, 30], [30, 31], [31, 32], [32, 33], [27, 34], [34, 35], [35, 36], [36, 37], [37, 38], [38, 39], [39, 40], [40, 41], [41, 42], [42, 43], [43, 44], [44, 45], [45, 46], [46, 47], [46, 48]];
        let lines = [[2, 4], [2, 4], [2, 4], [2, 4], [2, 4], [2, 4], [2, 4], [2, 4], [2, 4], [2], [1, 2, 3, 5], [1, 5], [1, 5], [1, 5], [1, 5], [1, 5], [1, 5], [1, 5], [1, 5], [1, 5], [1, 5], [1, 5], [4], [1, 3, 5], [1, 3, 4, 5], [1, 3, 4, 5], [1, 3, 4, 5], [1, 3, 4, 5], [1, 3, 4, 5], [1, 4], [1, 4], [1, 4], [1, 4], [1, 4], [1, 4], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3, 5], [3], [5]];
        let g = Util.Graph.constr(ver, "mG");
        let vtcs = [];
        let minX = Number.MAX_SAFE_INTEGER;
        let minY = Number.MAX_SAFE_INTEGER;
        let maxX = Number.MIN_SAFE_INTEGER;
        let maxY = Number.MIN_SAFE_INTEGER;
        let sumAdjacentDistances = 0;
        let adjacentCount = 0;
        for(let i = 0; i < xs.length; i++){
          let v1 = Util.Graph.addVertex(g);
          vtcs.push(v1);
          v1.p = Geometry.objTypes.Point.constr(ver, xs[i], ys[i]);
          // v1.p.v = v1;
          v1.p.visual.objectColor = Canvas.Colors.origVtx;
          v1.p.visual.objectDimensions = {w: 3, h: 3};
          v1.p.visual.objectShown = objectsShown;
          minX = Math.min(minX, v1.p.x);
          minY = Math.min(minY, v1.p.y);
          maxX = Math.max(maxX, v1.p.x);
          maxY = Math.max(maxY, v1.p.y);
          // if(i > 0){
          //   let e = g.addEdge(vtcs[i-1].id, v1.id);
          //   e.ls = Geometry.objTypes.LineSegment.constr(vtcs[i-1].p, v1.p);
          // }
        }
        for(let i = 0; i < es.length; i++){
          //if(!lines[i].includes(4)) continue;
          let e = Util.Graph.addEdge(g, vtcs[es[i][0]].id, vtcs[es[i][1]].id);
          let ls = Geometry.objTypes.LineSegment.constr(ver, vtcs[es[i][0]].p, vtcs[es[i][1]].p);
          ls.visual.objectDimensions = 1;
          e.ls = ls;
          // ls.e = e;
          ls.visual.objectShown = objectsShown;
          e.lines = lines[i];
          adjacentCount++;
          sumAdjacentDistances += Geometry.distanceBetween(ls.s, ls.t);
        }
        for(let v of vtcs){
          let ls = [];
          for(let e of v.es){
            for(let l of e.lines) if(!ls.includes(l)) ls.push(l);
          }
          v.ldeg = ls.length;
        }
        let br = Math.max(maxX-minX, maxY-minY);
        Canvas.viewport = {
          x: minX-(1.2*br-maxX+minX)/2,
          y: minY-(1.2*br-maxY+minY)/2,
          w: 1.2*br,
          h: 1.2*br
        }
        g.averageAdjacentDistances = sumAdjacentDistances/adjacentCount;
        ver.graphs.gridG = MetroMap.GraphCreation.octiGrid(ver, minX-0.1*(maxX-minX), minY-0.1*(maxY-minY), 1.2*(maxX-minX), 1.2*(maxY-minY), ver.costs["gr"]*g.averageAdjacentDistances, false);
        
        // Canvas.viewport = {
        //   x: 9.88,
        //   y: -49.81,
        //   w: 0.1,
        //   h: 0.1
        // }
        // ver.graphs.gridG = MetroMap.GraphCreation.octiGrid(ver, 9.885, -49.81, 45, 0.1);
        // [ver.results.edgeOrder, ver.results.vertexOrder] = MetroMap.Routing.getEdgeOrder(g);
        return g;
      },
      fromGPX: () => {
        let xmlhttp = new XMLHttpRequest();
        xmlhttp.onreadystatechange = function() {
          if (this.readyState == 4 && this.status == 200) {
            let g = Util.Graph.constr(ver, "mG");
            let wpts = this.responseXML.getElementsByTagName("wpt");
            for(let w of wpts){
              Geometry.objTypes.Point.constr(ver, w.getAttribute("lon"), "-"+w.getAttribute("lat"));
            }
            let trks = this.responseXML.getElementsByTagName("trk");
            let cols = ["red", "yellow", "green", "pink", "aqua", "darkorange", "gold", "indigo", "maroon", "orchid", "salmon", "slategray"];
            let colI = 0;
            for(let t of trks){
              for(let c of t.childNodes){
                if(c.tagName == "trkseg"){
                  let prev;
                  for(let p of c.childNodes){
                    let curr = Geometry.objTypes.Point.constr(ver, p.getAttribute("lon"), "-"+p.getAttribute("lat"));
                    curr.visual.objectShown = false;
                    if(prev){
                      let ls = Geometry.objTypes.LineSegment.constr(ver, prev, curr);
                      ls.visual.objectColor = cols[colI];
                    }
                    prev = curr;
                  }
                  // let closestS = vtcs[0];
                  // let sDis = 300000;
                  // let closestT = vtcs[0];
                  // let tDis = 300000;
                  // for(let v of vtcs){
                  //   if((v.p.x-c.firstChild.getAttribute("lon"))**2+(v.p.y-("-"+c.firstChild.getAttribute("lat")))**2 < sDis){
                  //     closestS = v;
                  //     sDis = (v.p.x-c.firstChild.getAttribute("lon"))**2+(v.p.y-("-"+c.firstChild.getAttribute("lat")))**2;
                  //   }
                  //   if((v.p.x-c.lastChild.getAttribute("lon"))**2+(v.p.y-("-"+c.lastChild.getAttribute("lat")))**2 < tDis){
                  //     closestT = v;
                  //     tDis = (v.p.x-c.lastChild.getAttribute("lon"))**2+(v.p.y-("-"+c.lastChild.getAttribute("lat")))**2;
                  //   }
                  // }
                  // let e = g.addEdge(closestS.id, closestT.id);
                  //e.ls = Geometry.objTypes.LineSegment.constr(closestS.p, closestT.p);
                  // console.log(closestS.id)
                  // console.log(Math.sqrt(sDis) + "  " + Math.sqrt(tDis));
                  // console.log(closestS.p.x + "  " + closestS.p.y);
                  // console.log(c.firstChild);
                  // console.log(closestT.p.x + "  " + closestT.p.y);
                  // console.log(c.lastChild);
                }
              }
              colI++;
              console.log(trks.length)
              //for(let w of )
            }
            Canvas.redraw();
          }
        };
        xmlhttp.open("GET", "http://" + IP + "/tram.gpx", true);
        xmlhttp.send();
      },
      fromGML: (ver, filename, objectsShown = ver.checkBoxes.cbShowMG) => {
        let sT = Date.now();
        document.title = "Metro Maps - " + filename;
        let xmlhttp = new XMLHttpRequest();
        xmlhttp.onreadystatechange = function() {
          if (this.readyState == 4 && this.status == 200) {
            let highlightIsec = false;
            let xmlDoc = (new DOMParser()).parseFromString(xmlhttp.responseText, "application/xml");
            let g = Util.Graph.constr(ver, "mG");
            let vtcs = {};
            let nodes = xmlDoc.getElementsByTagName("node");
            let minX = Number.MAX_SAFE_INTEGER;
            let minY = Number.MAX_SAFE_INTEGER;
            let maxX = Number.MIN_SAFE_INTEGER;
            let maxY = Number.MIN_SAFE_INTEGER;
            let sumAdjacentDistances = 0;
            let adjacentCount = 0;
            for(let v of nodes){
              let v1 = Util.Graph.addVertex(g);
              vtcs[v.getAttribute("id")] = v1;
              let x, y;
              for(let c of v.children){
                if(c.getAttribute("key") == "x") x = c.textContent;
                else if(c.getAttribute("key") == "y") y = -1*c.textContent;
              }
              minX = Math.min(minX, x);
              minY = Math.min(minY, y);
              maxX = Math.max(maxX, x);
              maxY = Math.max(maxY, y);
              v1.p = Geometry.objTypes.Point.constr(ver, x, y);
              // v1.p.v = v1;
              v1.p.visual.objectColor = Canvas.Colors.origVtx;
              v1.p.visual.objectDimensions = {w: 3, h: 3};
              v1.p.visual.objectShown = objectsShown;
            }
            let edges = xmlDoc.getElementsByTagName("edge");
            for(let e of edges){
              //if(!lines[i].includes(4)) continue;
              let e1 = Util.Graph.addEdge(g, vtcs[e.getAttribute("source")].id, vtcs[e.getAttribute("target")].id);
              let ls = Geometry.objTypes.LineSegment.constr(ver, vtcs[e.getAttribute("source")].p, vtcs[e.getAttribute("target")].p);
              ls.visual.objectDimensions = 1;
              e1.ls = ls;
              // ls.e = e1;
              ls.visual.objectShown = objectsShown;
              e1.lines = [];
              for(let c of e.children){
                if(c.textContent.toLowerCase() == "true") e1.lines.push(1*c.getAttribute("key").substr(1));
              }
              // if(e1.lines[0] == 0) ls.visual.objectColor = "green";
              // else if(e1.lines[0] == 1) ls.visual.objectColor = "red";
              // else if(e1.lines[0] == 2) ls.visual.objectColor = "blue";
              // else if(e1.lines[0] == 3) ls.visual.objectColor = "yellow";
              adjacentCount++;
              sumAdjacentDistances += Geometry.distanceBetween(ls.s, ls.t);
            }
            let isecC = 0;
            outer: for(let i = 0; i < Object.keys(g.edges).length; i++){
              let e1 = g.edges[i];
              for(let j = i+1; j < Object.keys(g.edges).length; j++){
                let e2 = g.edges[j];
                if(!e2 || !e1) continue;
                if(!e2.ls.t) console.log(e2)
                if(e1.s.id != e2.t.id && e1.s.id != e2.s.id && e1.t.id != e2.t.id && e1.t.id != e2.s.id && Geometry.doLineSegsIntersect({x1: e1.ls.s.x, y1: e1.ls.s.y, x2: e1.ls.t.x, y2: e1.ls.t.y}, {x1: e2.ls.s.x, y1: e2.ls.s.y, x2: e2.ls.t.x, y2: e2.ls.t.y})){
                  let vi = Util.Graph.addVertex(g);
                  vtcs["vi" + isecC] = vi;
                  vi.p = Geometry.objTypes.Point.constr(ver, ...Geometry.intersectionOfLineSegs({x1: e1.ls.s.x, y1: e1.ls.s.y, x2: e1.ls.t.x, y2: e1.ls.t.y}, {x1: e2.ls.s.x, y1: e2.ls.s.y, x2: e2.ls.t.x, y2: e2.ls.t.y}));
                  // vi.p.v = vi;
                  vi.p.visual.objectColor = Canvas.Colors.origVtx;
                  vi.p.visual.objectDimensions = {w: 3, h: 3};
                  vi.p.visual.objectShown = objectsShown;
                  let e3 = Util.Graph.addEdge(g, e1.s.id, vi.id);
                  e3.ls = Geometry.objTypes.LineSegment.constr(ver, e1.s.p, vi.p);
                  // e3.ls.e = e3;
                  e3.ls.visual.objectDimensions = 1;
                  e3.ls.visual.objectShown = objectsShown;
                  e3.ls.visual.highlightShown = highlightIsec;
                  e3.lines = e1.lines;
                  e3 = Util.Graph.addEdge(g, e2.s.id, vi.id);
                  e3.ls = Geometry.objTypes.LineSegment.constr(ver, e2.s.p, vi.p);
                  // e3.ls.e = e3;
                  e3.ls.visual.objectDimensions = 1;
                  e3.ls.visual.objectShown = objectsShown;
                  e3.ls.visual.highlightShown = highlightIsec;
                  e3.lines = e2.lines;
                  e3 = Util.Graph.addEdge(g, vi.id, e1.t.id);
                  e3.ls = Geometry.objTypes.LineSegment.constr(ver, vi.p, e1.t.p);
                  // e3.ls.e = e3;
                  e3.ls.visual.objectDimensions = 1;
                  e3.ls.visual.objectShown = objectsShown;
                  e3.ls.visual.highlightShown = highlightIsec;
                  e3.lines = e1.lines;
                  e3 = Util.Graph.addEdge(g, vi.id, e2.t.id);
                  e3.ls = Geometry.objTypes.LineSegment.constr(ver, vi.p, e2.t.p);
                  // e3.ls.e = e3;
                  e3.ls.visual.objectDimensions = 1;
                  e3.ls.visual.objectShown = objectsShown;
                  e3.ls.visual.highlightShown = highlightIsec;
                  e3.lines = e2.lines;
                  console.log(e1.id, e2.id)
                  Util.Graph.removeEdge(g, e1);
                  Util.Graph.removeEdge(g, e2);
                  isecC++;
                  continue outer;
                }
              }
            }
            console.log("found and replaced " + isecC + " intersections")
            for(let v in vtcs){
              v = vtcs[v];
              let ls = [];
              for(let e of v.es){
                for(let l of e.lines) if(!ls.includes(l)) ls.push(l);
              }
              v.ldeg = ls.length;
            }
            let br = Math.max(maxX-minX, maxY-minY);
            Canvas.viewport = {
              x: minX-(1.2*br-maxX+minX)/2,
              y: minY-(1.2*br-maxY+minY)/2,
              w: 1.2*br,
              h: 1.2*br
            }
            g.averageAdjacentDistances = sumAdjacentDistances/adjacentCount;
            ver.graphs.mG = g;
            MetroMap.GraphCreation.initCG(ver);
            //ver.graphs.mG = MetroMap.GraphCreation.deg2Contract(ver, ver.graphs.mG);
            ver.graphs.gridG = MetroMap.GraphCreation.octiGrid(ver, minX-0.1*(maxX-minX), minY-0.1*(maxY-minY), 1.2*(maxX-minX), 1.2*(maxY-minY), ver.costs["gr"]*g.averageAdjacentDistances, false);
            // [ver.results.edgeOrder, ver.results.vertexOrder] = MetroMap.Routing.getEdgeOrder(ver.graphs.mG);
            MetroMap.Routing.recalcAll(ver);
            Version.current.results.cost = MetroMap.Post.recalcCost(Version.current);
            Version.current.results.calcTime = Date.now()-sT;
            Version.edited("Start");
            //Canvas.redraw();
          }
        };
        xmlhttp.open("GET", "http://" + IP + "/" + filename + ".graphml", true);
        xmlhttp.send();
      }
    }
  };

  var stepCounter = 0; //for saving imgs of local search

  Version.setup();
  Canvas.setup();
  Tool.setup();
  Util.updateCosts();
  MetroMap.GraphCreation.loadLocation({value: "wurzburg"}); //Available locations: wurzburg wien washington montreal london sydney
  



  

  // Version.current.graphs.mG = MetroMap.GraphCreation.basicGraph(Version.current);
  // Version.current.graphs.gridG = MetroMap.GraphCreation.octiGrid(Version.current, -1.53, -1.57, 8, 4);
  // edgeOrder = MetroMap.Routing.getEdgeOrder(Version.current.graphs.mG);
  // MetroMap.Routing.recalcAll(Version.current);
  // Version.edited("Start");
  

  // let og = MetroMap.GraphCreation.octiGrid(Version.current, -10, -10, 20, 20, true);
  // viewport = {x: -11, y: -11, w: 22, h:22};
  // let S = [og.gridNodes[2][3]];
  // let T = [og.gridNodes[17][9]];
  // let ds = MetroMap.Routing.s2sDijkstra(S, T, og, true);
  // console.log(ds);
  // console.log(ds[2].map(e => e.dijkstra));
  // S[0].p.visual.objectColor = "lime";
  // S[0].p.visual.objectDimensions = {w: 12, h: 12};
  // T[0].p.visual.objectColor = "lime";
  // T[0].p.visual.objectDimensions = {w: 12, h: 12};
</script>

</body>
</html>
